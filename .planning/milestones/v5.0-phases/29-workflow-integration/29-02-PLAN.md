---
phase: 29-workflow-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/gsd-tools.cjs
autonomous: true
requirements:
  - WKFL-03
outcome_ids:
  - DO-10

must_haves:
  truths:
    - "Running `codebase-impact <file>` uses the cached dependency graph when codebase-intel.json has dependencies data"
    - "Running `codebase-impact <file>` falls back to grep-based scanning when no cached graph exists"
    - "Output format is consistent regardless of which path executes (files_analyzed, total_dependents, overall_risk, files[])"
  artifacts:
    - path: "bin/gsd-tools.cjs"
      provides: "Updated features cmdCodebaseImpact with graph-first logic"
      contains: "intel.dependencies"
  key_links:
    - from: "bin/gsd-tools.cjs features cmdCodebaseImpact"
      to: "require_codebase_intel readIntel"
      via: "Import readIntel, check intel.dependencies"
      pattern: "readIntel.*dependencies"
    - from: "bin/gsd-tools.cjs features cmdCodebaseImpact"
      to: "require_deps getTransitiveDependents"
      via: "Use graph-based dependents when available"
      pattern: "getTransitiveDependents"
---

<objective>
Update the features module's `codebase-impact` command to use the cached dependency graph from codebase-intel.json when available, falling back to the existing grep-based scanning when no graph exists.

Purpose: Two `codebase-impact` implementations exist — the codebase module (graph-based, requires `codebase analyze`) and the features module (grep-based, standalone). This unifies them so the standalone command benefits from cached intelligence (DO-10) while maintaining backward compatibility.
Output: Updated `bin/gsd-tools.cjs` with graph-first logic in features `cmdCodebaseImpact`.
</objective>

<execution_context>
@__OPENCODE_CONFIG__/get-shit-done/workflows/execute-plan.md
@__OPENCODE_CONFIG__/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-workflow-integration/29-RESEARCH.md
@bin/gsd-tools.cjs (lines 13954-14044 features cmdCodebaseImpact, lines 9795-9822 codebase cmdCodebaseImpact, lines 7920-7930 readIntel)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add graph-first logic to features cmdCodebaseImpact</name>
  <files>bin/gsd-tools.cjs</files>
  <action>
In `bin/gsd-tools.cjs`, modify the features module's `cmdCodebaseImpact` function (line 13954) to check for a cached dependency graph before falling back to grep:

1. **Add import at top of require_features module** (after existing requires around line 13487):
   ```javascript
   var { readIntel } = require_codebase_intel();
   var { getTransitiveDependents, buildDependencyGraph } = require_deps();
   ```

2. **Add graph-first path at the start of cmdCodebaseImpact** (after the filePaths validation, before the grep loop):
   ```javascript
   // Try cached dependency graph first (WKFL-03)
   try {
     const intel = readIntel(cwd);
     if (intel && intel.dependencies) {
       const graphResults = [];
       for (const filePath of filePaths) {
         const fullPath = path.join(cwd, filePath);
         if (!fs.existsSync(fullPath)) {
           graphResults.push({ path: filePath, exists: false, dependent_count: 0, dependents: [], risk: "low" });
           continue;
         }
         const result = getTransitiveDependents(intel.dependencies, filePath);
         const dependents = (result.dependents || []).slice(0, 20);
         graphResults.push({
           path: filePath,
           exists: true,
           dependent_count: result.dependent_count || dependents.length,
           dependents: dependents,
           risk: dependents.length > 10 ? "high" : dependents.length > 5 ? "medium" : "low"
         });
       }
       const totalDependents = graphResults.reduce((sum, r) => sum + r.dependent_count, 0);
       output({
         files_analyzed: graphResults.length,
         total_dependents: totalDependents,
         overall_risk: totalDependents > 20 ? "high" : totalDependents > 10 ? "medium" : "low",
         files: graphResults,
         source: "cached_graph"
       }, raw);
       return;
     }
   } catch (e) {
     debugLog("feature.codebaseImpact", "graph fallback to grep", e);
   }
   ```

3. **Keep the entire existing grep-based implementation unchanged** as the fallback path. The try/catch ensures any graph errors silently fall through to grep.

4. **Output format consistency:** The graph path produces the same shape as the grep path: `{ files_analyzed, total_dependents, overall_risk, files[] }` where each file has `{ path, exists, dependent_count, dependents[], risk }`. The only addition is `source: "cached_graph"` so callers can tell which path was used.

Key details:
- `readIntel` is from `require_codebase_intel()` — same function the codebase module uses (line 7920)
- `getTransitiveDependents` is from `require_deps()` — same function the codebase module uses
- `intel.dependencies` is the cached graph object (forward + reverse adjacency lists) built by Phase 25
- The graph path returns BEFORE the grep loop runs, so there's zero performance overhead when graph is available
  </action>
  <verify>
Test the codebase-impact command with and without cached intel:

```bash
# Test with cached intel (should use graph path, show source: cached_graph)
node bin/gsd-tools.cjs codebase-impact bin/gsd-tools.cjs --raw 2>/dev/null | python3 -c "import json,sys; d=json.load(sys.stdin); print(f'source: {d.get(\"source\",\"grep\")}, files: {d[\"files_analyzed\"]}, risk: {d[\"overall_risk\"]}')"

# Verify output format has all expected fields
node bin/gsd-tools.cjs codebase-impact bin/gsd-tools.cjs --raw 2>/dev/null | python3 -c "import json,sys; d=json.load(sys.stdin); f=d['files'][0]; print(f'has path: {\"path\" in f}, has exists: {\"exists\" in f}, has risk: {\"risk\" in f}, has dependents: {\"dependents\" in f}')"
```
  </verify>
  <done>Features module `cmdCodebaseImpact` uses cached dependency graph when available, falls back to grep when not, output format is consistent across both paths</done>
</task>

<task type="auto">
  <name>Task 2: Add test coverage for graph-first codebase-impact</name>
  <files>bin/gsd-tools.cjs</files>
  <action>
Add test cases to the existing test suite in `bin/gsd-tools.cjs` (find the test section, search for existing codebase-impact or feature tests):

1. **Test: graph path used when intel has dependencies**
   - Setup: Ensure codebase-intel.json exists with dependencies data (run `codebase analyze` first if needed, or use existing intel)
   - Run: `node bin/gsd-tools.cjs codebase-impact bin/gsd-tools.cjs --raw`
   - Assert: Output has `source: "cached_graph"` field
   - Assert: Output has `files_analyzed`, `total_dependents`, `overall_risk`, `files[]` fields
   - Assert: Each file has `path`, `exists`, `dependent_count`, `dependents`, `risk`

2. **Test: grep fallback when no intel**
   - This is the existing behavior — just verify it still works by running the command against a file that exists
   - Run from a directory without codebase-intel.json (or mock the readIntel to return null)
   - Assert: Output has standard fields, no `source: "cached_graph"`

3. **Test: non-existent file handling**
   - Run: `node bin/gsd-tools.cjs codebase-impact nonexistent-file.js --raw`
   - Assert: Output has file with `exists: false`

Find the test section by searching for `test codebase` or `runTests` or similar patterns in gsd-tools.cjs. Add tests following the existing pattern.
  </action>
  <verify>
Run the test suite:
```bash
node bin/gsd-tools.cjs test 2>&1 | grep -i "codebase-impact\|WKFL-03\|graph"
```
Verify all new tests pass.
  </verify>
  <done>Test coverage confirms graph-first path, grep fallback, and non-existent file handling all work correctly</done>
</task>

</tasks>

<verification>
1. `node bin/gsd-tools.cjs codebase-impact bin/gsd-tools.cjs --raw` — returns `source: "cached_graph"` when intel exists
2. Output format matches: `{ files_analyzed, total_dependents, overall_risk, files[] }` with each file having `{ path, exists, dependent_count, dependents[], risk }`
3. Non-existent files return `exists: false` in both graph and grep paths
4. Existing `codebase impact` (codebase module) command still works unchanged
5. All tests pass
</verification>

<success_criteria>
- `codebase-impact` command uses cached graph when available (source: "cached_graph" in output)
- `codebase-impact` command falls back to grep when no cached graph exists
- Output format is identical between graph and grep paths (except optional `source` field)
- No changes to the codebase module's `codebase impact` command
- Test coverage for graph path, grep fallback, and edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/29-workflow-integration/29-02-SUMMARY.md`
</output>
