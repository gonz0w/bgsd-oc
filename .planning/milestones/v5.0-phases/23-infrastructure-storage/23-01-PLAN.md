---
phase: 23-infrastructure-storage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/codebase-intel.js
  - src/commands/codebase.js
  - src/router.js
autonomous: true
requirements:
  - INFRA-01
  - INFRA-02
  - INFRA-03

must_haves:
  truths:
    - "Running `codebase analyze` creates .planning/codebase/codebase-intel.json with file inventory and language stats"
    - "codebase-intel.json contains a git_commit_hash watermark matching the HEAD commit at analysis time"
    - "Running `codebase status` returns stale/fresh with reason and list of changed files when stale"
    - "Running `codebase analyze` after modifying one file only re-analyzes that file (incremental mode)"
    - "Cached reads of codebase-intel.json complete in <10ms; staleness check completes in <50ms"
  artifacts:
    - path: "src/lib/codebase-intel.js"
      provides: "Storage format, staleness detection, incremental file scanning, language detection"
      min_lines: 200
    - path: "src/commands/codebase.js"
      provides: "CLI commands: codebase analyze, codebase status"
      exports: ["cmdCodebaseAnalyze", "cmdCodebaseStatus", "readCodebaseIntel", "checkCodebaseIntelStaleness", "autoTriggerCodebaseIntel"]
      min_lines: 80
  key_links:
    - from: "src/commands/codebase.js"
      to: "src/lib/codebase-intel.js"
      via: "require('../lib/codebase-intel')"
      pattern: "require.*codebase-intel"
    - from: "src/router.js"
      to: "src/commands/codebase.js"
      via: "lazy-loaded codebase module"
      pattern: "lazyCodebase.*require.*commands/codebase"
---

<objective>
Create the codebase intelligence storage engine and CLI commands.

Purpose: Build the foundational data layer that all subsequent codebase intelligence features (convention extraction, dependency graphs, lifecycle analysis) will store data into and read from. This is the v5.0 milestone's bedrock.

Output: `src/lib/codebase-intel.js` (core library), `src/commands/codebase.js` (CLI commands), updated `src/router.js` (routing), rebuilt `bin/gsd-tools.cjs`
</objective>

<execution_context>
@__OPENCODE_CONFIG__/get-shit-done/workflows/execute-plan.md
@__OPENCODE_CONFIG__/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/INTENT.md
@.planning/phases/23-infrastructure-storage/23-CONTEXT.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/STACK.md
@src/commands/env.js (reference: staleness detection pattern, autoTrigger pattern)
@src/router.js (reference: lazy-loading pattern, command routing)
@src/lib/output.js (reference: output/error/debugLog helpers)
@src/lib/helpers.js (reference: safeReadFile, cachedReadFile)
@src/lib/git.js (reference: execGit helper)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create codebase-intel.js core library</name>
  <files>src/lib/codebase-intel.js</files>
  <action>
Create `src/lib/codebase-intel.js` — the core storage and analysis library. Follow the env.js module pattern (pure functions, no CLI concerns).

**Storage Format (codebase-intel.json):**
```json
{
  "version": 1,
  "generated_at": "2026-02-26T12:00:00.000Z",
  "git_commit_hash": "abc123def",
  "git_branch": "main",
  "analysis_duration_ms": 340,
  "source_dirs": ["src/", "lib/"],
  "languages": {
    "javascript": { "count": 45, "extensions": [".js", ".cjs"], "lines": 12000 },
    "markdown": { "count": 32, "extensions": [".md"], "lines": 8500 }
  },
  "files": {
    "src/index.js": { "language": "javascript", "size_bytes": 1234, "lines": 56, "last_modified": "2026-02-26T12:00:00.000Z" }
  },
  "stats": {
    "total_files": 77,
    "total_lines": 20500,
    "languages_detected": 2
  }
}
```
Storage path: `.planning/codebase/codebase-intel.json`

**Functions to implement:**

1. `INTEL_PATH(cwd)` — Returns `.planning/codebase/codebase-intel.json` path.

2. `LANGUAGE_MAP` — Map file extensions to language names. Cover at minimum: `.js`, `.cjs`, `.mjs` (javascript), `.ts`, `.tsx` (typescript), `.py` (python), `.go` (go), `.ex`, `.exs` (elixir), `.rs` (rust), `.rb` (ruby), `.java`, `.kt` (java/kotlin), `.c`, `.h`, `.cpp`, `.hpp` (c/cpp), `.md` (markdown), `.json` (json), `.yaml`, `.yml` (yaml), `.toml` (toml), `.sh`, `.bash` (shell).

3. `SKIP_DIRS` — Set of directory names to always skip: `node_modules`, `vendor`, `deps`, `_build`, `.git`, `.next`, `target`, `dist`, `build`, `__pycache__`, `.elixir_ls`, `.cache`, `.planning`. Reuse the pattern from env.js.

4. `getSourceDirs(cwd)` — Auto-detect source directories. Walk top-level dirs, return those containing source files. Respect .gitignore by checking `git check-ignore` or using a simple gitignore parser. If no git, fall back to skipping SKIP_DIRS.

5. `walkSourceFiles(cwd, sourceDirs, skipDirs)` — Recursively walk source directories, yield file paths. Skip directories in SKIP_DIRS. Skip binary files (check extension against known binary extensions like `.png`, `.jpg`, `.woff`, `.woff2`, `.ttf`, `.ico`, `.exe`, `.dll`, `.so`, `.dylib`, `.zip`, `.tar`, `.gz`). Use `fs.readdirSync` with `withFileTypes: true` for performance.

6. `analyzeFile(filePath)` — For a single file: detect language from extension, count lines (`Buffer` split on `\n`), get size from `fs.statSync`, get mtime. Return `{ language, size_bytes, lines, last_modified }`.

7. `getGitInfo(cwd)` — Get current HEAD commit hash and branch name via `execGit`. Return `{ commit_hash, branch }` or `{ commit_hash: null, branch: null }` for non-git repos.

8. `getChangedFilesSinceCommit(cwd, commitHash)` — Run `git diff --name-only <commitHash> HEAD` via `execGit`. Return array of changed file paths. On error (e.g., commit no longer exists), return null (signals full rescan needed).

9. `checkStaleness(cwd)` — Core staleness detection:
   - Read existing intel JSON. If missing: `{ stale: true, reason: 'no_intel' }`.
   - If intel has `git_commit_hash`: run `getChangedFilesSinceCommit()`. If changed files exist: `{ stale: true, reason: 'files_changed', changed_files: [...] }`. If commit hash matches HEAD: `{ stale: false }`.
   - If git unavailable or hash missing: fall back to comparing file mtimes against `generated_at` timestamp. If any source file is newer: `{ stale: true, reason: 'mtime_newer', changed_files: [...] }`.
   - Performance target: <50ms for staleness check (git diff is fast on small repos, mtime check is stat-only).

10. `performAnalysis(cwd, options)` — Main analysis function:
    - `options.incremental` (boolean): If true and previous intel exists, only re-analyze changed files.
    - `options.previousIntel` (object): Previous intel data for incremental mode.
    - `options.changedFiles` (string[]): Files to re-analyze in incremental mode.
    - Full mode: walk all source files, analyze each, build languages/stats aggregates.
    - Incremental mode: start from `previousIntel.files`, remove deleted files, re-analyze changed files, recalculate aggregates.
    - Add `getGitInfo()` result as watermark.
    - Return the complete intel JSON object.

11. `readIntel(cwd)` — Read and parse codebase-intel.json. Return parsed object or null. Use `cachedReadFile` pattern for <10ms reads.

12. `writeIntel(cwd, intel)` — Write intel JSON to `.planning/codebase/codebase-intel.json`. Ensure directory exists. Use `JSON.stringify(intel, null, 2)`.

**Module exports:** `{ INTEL_PATH, LANGUAGE_MAP, SKIP_DIRS, getSourceDirs, walkSourceFiles, analyzeFile, getGitInfo, getChangedFilesSinceCommit, checkStaleness, performAnalysis, readIntel, writeIntel }`

Use `require('../lib/output')` for `debugLog`. Use `require('../lib/git')` for `execGit`. Use `require('fs')` and `require('path')` only — zero external dependencies.
  </action>
  <verify>
Run `node -e "require('./src/lib/codebase-intel.js')"` to verify module loads without errors. Check all exported functions exist.
  </verify>
  <done>
`src/lib/codebase-intel.js` exists with 12+ exported functions. Module loads cleanly. Language map covers 20+ extensions. SKIP_DIRS matches env.js pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create codebase.js CLI commands and wire router</name>
  <files>src/commands/codebase.js, src/router.js</files>
  <action>
Create `src/commands/codebase.js` — CLI command handlers for the `codebase` command group.

**Commands to implement:**

1. `cmdCodebaseAnalyze(cwd, args, raw)`:
   - Parse flags: `--full` (force full analysis even if incremental possible).
   - Call `checkStaleness(cwd)` to determine if incremental is possible.
   - If previous intel exists and no `--full`: use incremental mode with `changedFiles` from staleness check.
   - If no previous intel or `--full`: use full analysis mode.
   - Call `performAnalysis(cwd, { incremental, previousIntel, changedFiles })`.
   - Call `writeIntel(cwd, result)`.
   - Output JSON result via `output()`: `{ success: true, mode: 'full'|'incremental', files_analyzed: N, total_files: N, languages: [...], duration_ms: N, path: '.planning/codebase/codebase-intel.json' }`.
   - Show progress: `debugLog('codebase.analyze', 'analyzing N files...')`.

2. `cmdCodebaseStatus(cwd, args, raw)`:
   - Call `checkStaleness(cwd)`.
   - If no intel exists: `{ exists: false, message: 'No codebase intel. Run: codebase analyze' }`.
   - If stale: `{ exists: true, stale: true, reason: staleness.reason, changed_files: staleness.changed_files, intel_commit: cachedHash, current_commit: HEAD, generated_at: timestamp }`.
   - If fresh: `{ exists: true, stale: false, generated_at: timestamp, git_commit_hash: hash, total_files: N, languages: [...] }`.
   - Group changed files by type (added/modified/deleted) per CONTEXT.md decision. Use git diff `--diff-filter=A` (added), `--diff-filter=M` (modified), `--diff-filter=D` (deleted) or parse the combined diff output.
   - Output via `output()`.

3. `autoTriggerCodebaseIntel(cwd)` — Auto-trigger function (for Plan 02 to wire into init):
   - If no `.planning/` dir: return null.
   - Read existing intel. If none: return null (first run requires explicit `codebase analyze` per CONTEXT.md decision).
   - Check staleness. If fresh: return existing intel.
   - If stale: run incremental analysis, write results, return new intel.
   - Wrap in try/catch — never crash init commands (return existing or null on failure).
   - `debugLog('codebase.autoTrigger', ...)` for transparency.

**Wire into router (`src/router.js`):**

1. Add lazy loader: `function lazyCodebase() { return _modules.codebase || (_modules.codebase = require('./commands/codebase')); }`

2. Add `case 'codebase':` in the main switch statement (near the existing `codebase-impact` case):
   ```javascript
   case 'codebase': {
     const sub = args[1];
     if (sub === 'analyze') {
       lazyCodebase().cmdCodebaseAnalyze(cwd, args.slice(2), raw);
     } else if (sub === 'status') {
       lazyCodebase().cmdCodebaseStatus(cwd, args.slice(2), raw);
     } else {
       error('Usage: codebase <analyze|status>');
     }
     break;
   }
   ```

3. Update the help string in the usage error message to include `codebase`.

**Build and verify:**
Run `node build.js` to bundle. Then test:
- `node bin/gsd-tools.cjs codebase analyze --raw` (should analyze this project)
- `node bin/gsd-tools.cjs codebase status --raw` (should show fresh)
- Verify `.planning/codebase/codebase-intel.json` exists with correct schema
- Verify `git_commit_hash` matches `git rev-parse HEAD`
- Modify a file, run `codebase status --raw` — should show stale
- Run `codebase analyze --raw` again — should report incremental mode
  </action>
  <verify>
```bash
node build.js && \
node bin/gsd-tools.cjs codebase analyze --raw 2>/dev/null | node -e "const d=JSON.parse(require('fs').readFileSync('/dev/stdin','utf-8')); console.log('analyze:', d.success, 'files:', d.total_files, 'mode:', d.mode)" && \
node bin/gsd-tools.cjs codebase status --raw 2>/dev/null | node -e "const d=JSON.parse(require('fs').readFileSync('/dev/stdin','utf-8')); console.log('status:', d.stale===false ? 'fresh' : 'stale')"
```
  </verify>
  <done>
`codebase analyze` produces valid codebase-intel.json with git hash watermark. `codebase status` reports fresh after analyze, stale after file changes. Incremental mode works (re-analyzes only changed files). Build succeeds. Both commands produce valid JSON via --raw.
  </done>
</task>

</tasks>

<verification>
1. `node bin/gsd-tools.cjs codebase analyze --raw` creates `.planning/codebase/codebase-intel.json`
2. JSON contains `version`, `git_commit_hash`, `files`, `languages`, `stats` fields
3. `node bin/gsd-tools.cjs codebase status --raw` returns `stale: false` immediately after analyze
4. Touch a source file, `codebase status --raw` returns `stale: true` with changed file listed
5. Second `codebase analyze --raw` reports `mode: "incremental"` and only re-analyzes changed file
6. `node --test bin/gsd-tools.test.cjs` passes (existing tests not broken)
</verification>

<success_criteria>
- INFRA-01: `codebase analyze` creates codebase-intel.json with git hash watermark ✓
- INFRA-02: `codebase status` detects staleness via git diff in <50ms ✓
- INFRA-03: Incremental mode re-analyzes only changed files ✓
- New `src/lib/codebase-intel.js` and `src/commands/codebase.js` modules created ✓
</success_criteria>

<output>
After completion, create `.planning/phases/23-infrastructure-storage/23-01-SUMMARY.md`
</output>
