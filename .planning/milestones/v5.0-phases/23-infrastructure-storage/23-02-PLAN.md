---
phase: 23-infrastructure-storage
plan: 02
type: execute
wave: 2
depends_on:
  - 23-01
files_modified:
  - src/commands/init.js
  - bin/gsd-tools.test.cjs
autonomous: true
requirements:
  - INFRA-04

must_haves:
  truths:
    - "Init commands (execute-phase, plan-phase, progress, phase-op) include codebase_summary when intel exists and is fresh"
    - "Init commands auto-trigger incremental analysis when intel is stale"
    - "First project use (no existing codebase-intel.json) does NOT auto-trigger — returns null"
    - "Auto-trigger failures never crash init commands — gracefully return null"
    - "All codebase commands and integration points have test coverage"
  artifacts:
    - path: "src/commands/init.js"
      provides: "Auto-trigger integration for codebase intel in init commands"
      contains: "autoTriggerCodebaseIntel"
    - path: "bin/gsd-tools.test.cjs"
      provides: "Test coverage for codebase analyze, codebase status, staleness detection, incremental analysis, and init auto-trigger"
      min_lines: 50
  key_links:
    - from: "src/commands/init.js"
      to: "src/commands/codebase.js"
      via: "require('./codebase') for autoTriggerCodebaseIntel"
      pattern: "autoTriggerCodebaseIntel"
    - from: "src/commands/init.js"
      to: "src/lib/codebase-intel.js"
      via: "indirect through codebase.js autoTrigger"
      pattern: "codebase_summary"
---

<objective>
Wire codebase intelligence into init commands and add comprehensive test coverage.

Purpose: Complete the INFRA-04 requirement by making codebase analysis transparent — init commands automatically keep intel fresh following the proven env.js autoTrigger pattern. Test coverage ensures stability as subsequent phases (24-29) build on this foundation.

Output: Updated `src/commands/init.js` with auto-trigger, updated `bin/gsd-tools.test.cjs` with new test section, rebuilt `bin/gsd-tools.cjs`
</objective>

<execution_context>
@__OPENCODE_CONFIG__/get-shit-done/workflows/execute-plan.md
@__OPENCODE_CONFIG__/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/23-infrastructure-storage/23-CONTEXT.md
@.planning/phases/23-infrastructure-storage/23-01-SUMMARY.md
@src/commands/init.js (reference: existing autoTriggerEnvScan integration pattern)
@src/commands/env.js (reference: autoTriggerEnvScan implementation)
@src/commands/codebase.js (created in plan 01)
@src/lib/codebase-intel.js (created in plan 01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire auto-trigger into init commands</name>
  <files>src/commands/init.js</files>
  <action>
Add codebase intel auto-trigger to init commands, following the exact pattern used for `autoTriggerEnvScan`.

**Import:**
Add to init.js imports (near line 11 where `autoTriggerEnvScan` is imported):
```javascript
const { autoTriggerCodebaseIntel } = require('./codebase');
```

**Integration points — add to these init functions:**

1. `cmdInitExecutePhase` (line ~14) — Most important. Executor agents need codebase context.
   - After the existing `autoTriggerEnvScan(cwd)` call, add: `const codebaseIntel = autoTriggerCodebaseIntel(cwd);`
   - Add to the result object: `codebase_summary: codebaseIntel ? formatCodebaseSummary(codebaseIntel) : null`

2. `cmdInitPlanPhase` (find in init.js) — Planner benefits from knowing project structure.
   - Same pattern: call `autoTriggerCodebaseIntel(cwd)`, add `codebase_summary` to result.

3. `cmdInitProgress` (find in init.js) — Progress report should show codebase intel status.
   - Same pattern. Add `codebase_intel_exists: !!codebaseIntel` to result.

4. `cmdInitPhaseOp` (find in init.js) — Phase operations benefit from codebase awareness.
   - Same pattern.

**Do NOT add to:** `cmdInitQuick`, `cmdInitTodos`, `cmdInitMemory` — these are lightweight commands that don't benefit from codebase context (per CONTEXT.md: "Only relevant init commands include codebase context").

**formatCodebaseSummary function:**
Create a helper in init.js (or import from codebase.js if exported):
```javascript
function formatCodebaseSummary(intel) {
  if (!intel || !intel.stats) return null;
  const langs = Object.entries(intel.languages || {})
    .sort((a, b) => b[1].count - a[1].count)
    .slice(0, 5)
    .map(([lang, info]) => `${lang}(${info.count})`)
    .join(', ');
  return {
    total_files: intel.stats.total_files,
    total_lines: intel.stats.total_lines,
    top_languages: langs,
    git_commit: intel.git_commit_hash,
    generated_at: intel.generated_at
  };
}
```
This keeps the summary compact (<500 tokens) for context injection, aligning with Phase 26 requirements (CTXI-01).

**Build and quick-test:**
Run `node build.js`. Then:
- `node bin/gsd-tools.cjs codebase analyze --raw` (ensure intel exists first)
- `node bin/gsd-tools.cjs init execute-phase 23 --raw 2>/dev/null | node -e "const d=JSON.parse(require('fs').readFileSync('/dev/stdin','utf-8')); console.log('codebase_summary:', d.codebase_summary)"`
- Verify codebase_summary field appears in output with total_files, top_languages
  </action>
  <verify>
```bash
node build.js && \
node bin/gsd-tools.cjs init execute-phase 23 --raw 2>/dev/null | node -e "const d=JSON.parse(require('fs').readFileSync('/dev/stdin','utf-8')); console.log('has_codebase_summary:', !!d.codebase_summary)"
```
  </verify>
  <done>
Init commands (execute-phase, plan-phase, progress, phase-op) include `codebase_summary` field. Auto-trigger runs when stale. First run without existing intel returns null (no auto-trigger). Init commands never crash from codebase intel failures.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive test coverage</name>
  <files>bin/gsd-tools.test.cjs</files>
  <action>
Add a new `describe('codebase intelligence', ...)` test section to `bin/gsd-tools.test.cjs`. Follow the existing test patterns (use `node:test`, `node:assert`, `runGsdTools` helper, temp directories).

**Test cases to cover:**

**codebase analyze:**
1. `codebase analyze --raw` succeeds on a project with source files — returns `{ success: true, mode: 'full', total_files: N }`
2. `codebase analyze --raw` creates `.planning/codebase/codebase-intel.json`
3. Intel JSON has required fields: `version`, `git_commit_hash`, `generated_at`, `files`, `languages`, `stats`
4. Running `codebase analyze --raw` twice — second run reports `mode: 'incremental'` (if no files changed)
5. `codebase analyze --full --raw` forces full analysis even when incremental is possible

**codebase status:**
6. `codebase status --raw` before any analyze returns `{ exists: false }`
7. `codebase status --raw` after analyze returns `{ exists: true, stale: false }`
8. After modifying a tracked file, `codebase status --raw` returns `{ stale: true, reason: 'files_changed' }`

**Staleness detection:**
9. Staleness check with valid git hash returns stale/fresh correctly
10. Staleness check with invalid/missing git hash triggers full rescan indicator

**Incremental analysis:**
11. After modifying one file, analyze only re-processes that file (check `files_analyzed` count)

**Error handling:**
12. `codebase analyze` on a directory with no `.planning/` — creates it or handles gracefully
13. Corrupt `codebase-intel.json` — analyze handles gracefully (full rescan)

**Init integration (if testable with existing helpers):**
14. Init execute-phase includes `codebase_summary` when intel exists

Use the existing test patterns:
- `const result = runGsdTools('codebase analyze --raw', tmpDir);`
- `assert.ok(result.success, 'message');`
- Create temp directories with sample source files for isolated testing
- Clean up after tests with `afterEach` or `after` hooks

Build after adding tests:
```bash
node build.js && node --test bin/gsd-tools.test.cjs
```

All existing tests (502+) MUST continue to pass. No regressions.
  </action>
  <verify>
```bash
node build.js && node --test bin/gsd-tools.test.cjs 2>&1 | tail -5
```
All tests pass, including the new codebase intelligence test section. Zero regressions in existing tests.
  </verify>
  <done>
New `describe('codebase intelligence', ...)` section exists with 10+ test cases covering analyze, status, staleness, incremental, error handling, and init integration. All tests pass. Zero regressions.
  </done>
</task>

</tasks>

<verification>
1. `node bin/gsd-tools.cjs init execute-phase 23 --raw` includes `codebase_summary` field
2. `node bin/gsd-tools.cjs init plan-phase 24 --raw` includes `codebase_summary` field
3. Deleting codebase-intel.json → init commands return `codebase_summary: null` (no auto-trigger on first run)
4. Making intel stale (modify file) → init commands auto-refresh and return updated summary
5. `node --test bin/gsd-tools.test.cjs` passes with 510+ tests (existing 502 + new ~10)
6. Build succeeds within 700KB bundle budget
</verification>

<success_criteria>
- INFRA-04: Init commands auto-trigger analysis when stale (follows env.js pattern) ✓
- First run requires explicit `codebase analyze` — no auto-trigger on virgin projects ✓
- Auto-trigger failures never crash init commands ✓
- 10+ new test cases covering all codebase intelligence functionality ✓
- Zero regressions in existing test suite ✓
</success_criteria>

<output>
After completion, create `.planning/phases/23-infrastructure-storage/23-02-SUMMARY.md`
</output>
