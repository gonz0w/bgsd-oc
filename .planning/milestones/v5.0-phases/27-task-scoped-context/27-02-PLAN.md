---
phase: 27-task-scoped-context
plan: 02
type: execute
wave: 2
depends_on: [27-01]
files_modified:
  - src/commands/codebase.js
  - bin/gsd-tools.cjs
  - bin/gsd-tools.test.cjs
autonomous: true
requirements: [CTXI-03, CTXI-04]
intent:
  outcome_ids: [DO-07, SC-06]

must_haves:
  truths:
    - "Context results are ranked by heuristic relevance score (graph distance 50%, plan scope 30%, git recency 20%)"
    - "Total output never exceeds 5K tokens regardless of how many files are requested"
    - "When budget is tight, output degrades gracefully: drop dependents → drop imports to top-3 → drop conventions → drop to file+risk only → drop lowest-scored files"
    - "Truncated results include truncated:true flag and omitted_files count"
    - "Single file gets richest context; 10+ files get sparse summaries"
    - "Plan scope signal works via --plan flag reading files_modified from plan frontmatter"
    - "Git recency signal boosts files modified in last 10 commits"
  artifacts:
    - path: "src/commands/codebase.js"
      provides: "scoreRelevance and enforceTokenBudget functions integrated into cmdCodebaseContext"
      contains: "scoreRelevance"
    - path: "bin/gsd-tools.test.cjs"
      provides: "Test cases for scoring, budget enforcement, and degradation"
      contains: "codebase context"
  key_links:
    - from: "src/commands/codebase.js"
      to: "src/lib/context.js"
      via: "require for estimateJsonTokens"
      pattern: "estimateJsonTokens"
    - from: "src/commands/codebase.js"
      to: "src/lib/git.js"
      via: "require for execGit (git recency)"
      pattern: "execGit"
    - from: "src/commands/codebase.js"
      to: "src/lib/frontmatter.js"
      via: "require for extractFrontmatter (plan scope)"
      pattern: "extractFrontmatter"
---

<objective>
Add heuristic relevance scoring and 5K token budget enforcement to `codebase context`, ensuring agents get the most relevant context within a hard token cap with graceful degradation.

Purpose: Without scoring and budgeting, raw context dumps would overwhelm agent context windows. The scoring ensures agents see what matters most; the budget cap prevents context bloat.
Output: Scored, budget-enforced context command with comprehensive test coverage.
</objective>

<execution_context>
@__OPENCODE_CONFIG__/get-shit-done/workflows/execute-plan.md
@__OPENCODE_CONFIG__/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-task-scoped-context/27-CONTEXT.md
@.planning/phases/27-task-scoped-context/27-RESEARCH.md
@.planning/phases/27-task-scoped-context/27-01-SUMMARY.md
@src/commands/codebase.js
@src/lib/context.js
@src/lib/git.js
@src/lib/frontmatter.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add heuristic scoring and token budget enforcement</name>
  <files>src/commands/codebase.js</files>
  <action>
Add three pure functions and integrate them into the existing `cmdCodebaseContext` from Plan 01.

**1. `scoreRelevance(file, targetFiles, graph, planFiles, recentFiles)` — returns 0.0–1.0**

Per CONTEXT.md locked decisions (weights are NON-NEGOTIABLE):
- **Graph distance (50% weight):**
  - 1-hop: file is in `graph.forward[target]` or `graph.reverse[target]` for any target → +0.50
  - 2-hop: file is reachable in 2 hops from any target via forward/reverse edges → +0.25
  - 3+ hop: excluded (score 0 for graph distance)
  - Implementation: for each target file, check if `file` is in forward[target] or reverse[target] (1-hop). If not, for each 1-hop neighbor of target, check if `file` is in their forward/reverse (2-hop). Short-circuit on first match at each level.
- **Plan scope (30% weight):** if `planFiles.includes(file)` → +0.30
- **Git recency (20% weight):** if `recentFiles.has(file)` → +0.20

Also score the TARGET files themselves: each target file gets a base score of 1.0 (they are what was requested — always included).

**2. `getRecentlyModifiedFiles(cwd, commitCount = 10)` — returns Set of file paths**

Use `execGit(cwd, ["log", `-${commitCount}`, "--name-only", "--pretty=format:", "--no-merges"])`. Parse stdout, split by newlines, filter empty, return as Set. If execGit fails (not a git repo, etc.), return empty Set. Import `execGit` from `../lib/git`.

**3. `enforceTokenBudget(fileContexts, maxTokens = 5000)` — returns { files, truncated, omitted_files }**

Import `estimateJsonTokens` from `../lib/context`.

Algorithm per CONTEXT.md locked degradation order:
1. Estimate tokens on full output wrapper: `{ success: true, files: {...}, file_count, truncated, ... }`
2. If fits → return `{ files: fileContexts, truncated: false, omitted_files: 0 }`
3. Degradation levels (applied to ALL files equally per CONTEXT.md atomic rule):
   - Level 1: Trim dependents to top 3 for each file
   - Level 2: Trim imports to top 3 for each file
   - Level 3: Remove conventions from each file
   - Level 4: Remove imports and dependents entirely (keep file + risk_level only)
4. After each level, re-estimate. If fits → return with `truncated: true`
5. Last resort: sort files by relevance_score descending, drop lowest-scored files one by one until fits
6. Return `{ files: remainingContexts, truncated: true, omitted_files: droppedCount }`

**Important:** Always estimate on the FULL serialized output (the complete result object), not on individual files. Per research pitfall #1.

**4. Integration into cmdCodebaseContext:**

Update the function (from Plan 01) to:
- Parse `--plan <path>` flag → call `getPlanFiles(planPath)` to get plan's `files_modified` list
- Call `getRecentlyModifiedFiles(cwd)` to get recent file Set
- After assembling per-file contexts, call `scoreRelevance` for each file's imports and dependents (NOT for the target files themselves — targets always included)
- Add `relevance_score` field to each file context object
- Sort each file's imports and dependents by their relevance scores (highest first), then apply the existing fan-in/fan-out sorting as tiebreaker
- Call `enforceTokenBudget` on the assembled result
- Merge truncated/omitted_files into the output JSON

**Helper: `getPlanFiles(planPath)`:**
- If no planPath, return []
- `path.resolve(cwd, planPath)` → read file → `extractFrontmatter(content)` → return `fm.files_modified` array (or [] if missing)
- Import `extractFrontmatter` from `../lib/frontmatter`
- Wrap in try/catch, return [] on any failure
  </action>
  <verify>
After `node build.js`:
1. `node bin/gsd-tools.cjs codebase context --files src/commands/codebase.js --raw` — output should include `relevance_score` per file and `truncated` flag
2. `node bin/gsd-tools.cjs codebase context --files src/commands/codebase.js --plan .planning/phases/27-task-scoped-context/27-01-PLAN.md --raw` — plan scope should boost files listed in that plan's files_modified
3. Request many files: `node bin/gsd-tools.cjs codebase context --files src/commands/codebase.js src/lib/deps.js src/lib/conventions.js src/lib/context.js src/lib/git.js src/lib/frontmatter.js src/lib/output.js src/lib/helpers.js src/lib/config.js src/router.js --raw` — should fit within 5K tokens, may show truncated:true
4. Verify the JSON output's token count: pipe through `wc -c` and confirm well under 20K chars (~5K tokens)
  </verify>
  <done>
Each file in context output has a `relevance_score`. Scoring uses three signals: graph distance (50%), plan scope (30%), git recency (20%). Token budget enforced at 5K with graceful degradation. --plan flag reads plan frontmatter for scope signal. Git recency checks last 10 commits.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add test coverage for context command</name>
  <files>bin/gsd-tools.test.cjs</files>
  <action>
Add a new `describe('codebase context', ...)` block in `bin/gsd-tools.test.cjs` with test cases covering the three requirements (CTXI-02, CTXI-03, CTXI-04).

**Tests to add (aim for 10-14 tests):**

1. **Basic output structure:** Run `codebase context --files src/commands/codebase.js --raw` → parse JSON → verify `success: true`, `files` object has the requested file key, `file_count >= 1`

2. **Per-file fields present:** For a known file in intel → verify output has `imports` (array), `dependents` (array), `risk_level` (string, one of "high"/"caution"/"normal"), `relevance_score` (number)

3. **No-data stub:** Request context for `nonexistent-file-12345.js` → verify output has `status: "no-data"`, `conventions: null`

4. **Import cap at 8:** Pick a file with many imports (or mock) → verify `imports.length <= 8`

5. **Dependent cap at 8:** Pick a file with many dependents (or mock) → verify `dependents.length <= 8`

6. **Risk level high:** Test the `computeRiskLevel` function directly — file with >10 reverse edges → "high"

7. **Risk level caution:** File in a cycle → "caution" (may need to construct test data)

8. **Risk level normal:** File with few dependents, not in cycle → "normal"

9. **Relevance score present:** Run with `--plan` pointing to a plan file → verify `relevance_score` is a number between 0 and 1

10. **Token budget respected:** Request context for 10+ files → verify output JSON stringified is under 20K chars (conservative proxy for 5K tokens)

11. **Truncation flag:** Request context for many files → if output was trimmed, verify `truncated` is boolean

12. **Usage error on no files:** Run `codebase context` with no args → verify error output

13. **Multiple files:** Request 3 files → verify all 3 appear in output (or omitted_files accounts for missing ones)

14. **Conventions field:** For a known file → verify conventions is either null or has `naming` property

Follow existing test patterns in the file — use `execSync` to run the CLI command and parse JSON output.

Rebuild bundle with `node build.js` before running tests. Run full test suite to verify zero regressions.
  </action>
  <verify>
Run `node bin/gsd-tools.test.cjs 2>&1 | tail -5` to verify all tests pass with zero failures. The new 'codebase context' describe block should show 10+ passing tests. No regressions in existing test suites.
  </verify>
  <done>
10+ test cases covering CTXI-02 (per-file context), CTXI-03 (heuristic scoring), CTXI-04 (token budget). All tests pass. Zero regressions on existing tests (500+).
  </done>
</task>

</tasks>

<verification>
1. `node bin/gsd-tools.cjs codebase context --files src/commands/codebase.js --raw` includes `relevance_score` per file
2. `node bin/gsd-tools.cjs codebase context --files <10 files> --raw | wc -c` is under 20K chars
3. Token budget enforced: large requests produce `truncated: true` with `omitted_files` count
4. Degradation order correct: dependents trimmed first → imports → conventions → file+risk only → drop files
5. `--plan` flag boosts files in plan's files_modified
6. All new tests pass, zero regressions on existing 500+ tests
7. Response time <100ms for cached intel
</verification>

<success_criteria>
- Heuristic relevance scoring implemented with correct weights (50/30/20)
- 5K token budget hard cap enforced with graceful degradation
- --plan flag provides plan-scope signal from frontmatter
- Git recency signal checks last 10 commits
- 10+ test cases covering all three requirements
- CTXI-03 and CTXI-04 requirements fully satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/27-task-scoped-context/27-02-SUMMARY.md`
</output>
