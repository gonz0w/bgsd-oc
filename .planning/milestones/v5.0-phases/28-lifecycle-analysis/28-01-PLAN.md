---
phase: 28-lifecycle-analysis
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/lifecycle.js
autonomous: true
requirements: [LIFE-01, LIFE-02, LIFE-03]
outcome_ids: [DO-07, DO-09]

must_haves:
  truths:
    - "LIFECYCLE_DETECTORS registry exists with extensible detector pattern matching FRAMEWORK_DETECTORS"
    - "Generic migration detector finds numbered/timestamped files in migration directories and builds ordering"
    - "Elixir/Phoenix detector identifies application.ex boot, config ordering, migration→seed dependency, router compilation"
    - "Lifecycle DAG is built with correct must_run_before/must_run_after symmetry"
    - "Topological sort produces linear chains from DAG nodes"
    - "Cycles in lifecycle graph are detected via Tarjan's SCC from deps.js"
  artifacts:
    - path: "src/lib/lifecycle.js"
      provides: "LIFECYCLE_DETECTORS registry, buildLifecycleGraph(), topologicalSort(), chain flattening"
      exports: ["LIFECYCLE_DETECTORS", "buildLifecycleGraph"]
  key_links:
    - from: "src/lib/lifecycle.js"
      to: "src/lib/deps.js"
      via: "findCycles() import for cycle detection"
      pattern: "require.*deps.*findCycles"
    - from: "src/lib/lifecycle.js"
      to: "src/lib/codebase-intel.js"
      via: "readIntel() for loading cached intel data"
      pattern: "require.*codebase-intel.*readIntel"
---

<objective>
Create the core lifecycle analysis library with detector registry, DAG construction, topological sort, and chain flattening.

Purpose: Enable detection of execution order relationships (seeds after migrations, config at boot, framework-specific initialization patterns) by scanning existing codebase-intel.json data. This is the foundation library that Plan 02 will expose via CLI.

Output: `src/lib/lifecycle.js` module with `LIFECYCLE_DETECTORS` array, `buildLifecycleGraph()` function, and all supporting logic (topological sort, chain building, cycle detection integration).
</objective>

<execution_context>
@__OPENCODE_CONFIG__/get-shit-done/workflows/execute-plan.md
@__OPENCODE_CONFIG__/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-lifecycle-analysis/28-CONTEXT.md
@.planning/phases/28-lifecycle-analysis/28-RESEARCH.md

# Source patterns to follow
@src/lib/conventions.js
@src/lib/deps.js
@src/lib/codebase-intel.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lifecycle.js with detector registry and DAG builder</name>
  <files>src/lib/lifecycle.js</files>
  <action>
Create `src/lib/lifecycle.js` following the patterns from `src/lib/conventions.js` (FRAMEWORK_DETECTORS) and `src/lib/deps.js` (findCycles).

**LIFECYCLE_DETECTORS registry** — Array of detector objects, each with:
- `name`: string identifier (e.g., 'generic-migrations', 'elixir-phoenix')
- `detect(intel)`: returns boolean — whether this detector applies to the codebase
- `extractLifecycle(intel, cwd)`: returns array of lifecycle nodes

**Generic migration detector** (`generic-migrations`):
- `detect()`: Check if any path in `Object.keys(intel.files || {})` matches `migrations/`, `db/migrate/`, or `priv/repo/migrations/` (regex: `/(?:^|\/)(migrations|db\/migrate|priv\/[^/]*\/migrations)\//`)
- `extractLifecycle()`: For each migration directory found:
  1. Collect files in that directory (one level deep — no subdirectory recursion)
  2. Sort by filename (natural sort order — this is what gives the ordering)
  3. Classify prefix: 14+ digits = timestamp (confidence 95), 1-4 digits = sequence number (confidence 90), 8 digits = date (confidence 85), else alphabetical (confidence 70)
  4. Build sequential chain: each file depends on previous (must_run_after = [prevId])
  5. Maintain symmetry: update previous node's must_run_before to include current
  6. Node shape per CONTEXT.md: `{ id: 'migration:{basename_no_ext}', file_or_step: relPath, type: 'migration', must_run_before: [], must_run_after: [], framework: 'generic', confidence: N }`

**Elixir/Phoenix detector** (`elixir-phoenix`):
- `detect()`: Check `intel.conventions && intel.conventions.frameworks` for entry with `framework === 'elixir-phoenix'`. If no conventions data, return false (don't re-detect frameworks).
- `extractLifecycle()`: Detect these patterns from `intel.files` paths:
  1. **Config ordering:** `config/config.exs` → `config/runtime.exs` (config → config, confidence 95/90)
  2. **Boot:** `lib/*/application.ex` — type 'boot', must_run_after configs (confidence 95)
  3. **Seeds depend on migrations:** Find `**/seeds.exs`, link must_run_after the last migration node ID (confidence 90). Note: migration nodes may come from the generic detector — look for them by checking existing nodes or by scanning for migration files.
  4. **Router:** `**/router.ex` — type 'compilation', must_run_after boot:application (confidence 85)
  - Use `must_run_after` as the primary direction, then derive `must_run_before` symmetry in post-processing.

**buildLifecycleGraph(intel, cwd)** — Main entry point:
1. Run each detector: `for (const d of LIFECYCLE_DETECTORS) { if (d.detect(intel)) { nodes.push(...d.extractLifecycle(intel, cwd)); } }`
2. **Merge duplicate nodes:** If both generic and Phoenix detectors produce migration nodes for the same file, keep the one with higher confidence. Use `file_or_step` as dedup key.
3. **Post-process symmetry:** For each node, if it has `must_run_after: ['X']`, ensure node X has `must_run_before` including this node's id. Build this by iterating all nodes once.
4. **Cycle detection:** Convert to `{ forward: {} }` shape for `findCycles()` from deps.js: `forward[node.id] = node.must_run_before`. Import `findCycles` from `../lib/deps`.
5. **Chain flattening** via Kahn's topological sort:
   - Build in-degree map from must_run_before edges
   - BFS from zero in-degree nodes
   - Group into connected components first, then topo-sort each component into a separate chain
   - Only include chains with length > 1 (single nodes aren't chains)
6. **Cap migration nodes:** If a single migration directory has > 20 files, keep only the 20 most recent (by filename sort order, last 20). Add a summary node: `{ id: 'migration:earlier-N', file_or_step: '... and N earlier migrations', type: 'migration', framework, confidence: 0, must_run_before: [first_kept_id], must_run_after: [] }`
7. **Return:** `{ nodes: [...], edges: edgeCount, chains: [...], cycles: cycleData.cycles || [], detectors_used: [...detectorNames], stats: { node_count, edge_count, chain_count, cycle_count }, built_at: new Date().toISOString() }`

**Exports:** `module.exports = { LIFECYCLE_DETECTORS, buildLifecycleGraph }`

Use `debugLog` from `require('../lib/output')` (or inline `require_output()` pattern — check how conventions.js and deps.js get it). Follow the same `var` declaration style used throughout the codebase (not `const`/`let` at module level).
  </action>
  <verify>
Run `node -e "const m = require('./src/lib/lifecycle'); console.log(Object.keys(m)); console.log(m.LIFECYCLE_DETECTORS.map(d => d.name));"` — should output exports and detector names ['generic-migrations', 'elixir-phoenix'].

Run `node -e "const m = require('./src/lib/lifecycle'); const result = m.buildLifecycleGraph({ files: {}, conventions: {} }, '.'); console.log(JSON.stringify(result));"` — should return valid structure with empty nodes/chains when no lifecycle patterns found.
  </verify>
  <done>
src/lib/lifecycle.js exists with LIFECYCLE_DETECTORS registry (2 detectors: generic-migrations, elixir-phoenix), buildLifecycleGraph() function, topological sort, chain flattening, and cycle detection integration. Module loads without errors and returns correct empty result for projects with no lifecycle patterns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify lifecycle detection</name>
  <files>src/lib/lifecycle.js</files>
  <action>
Test the lifecycle module against a project with relevant codebase intel.

1. First, check if the current project has codebase intel:
   ```
   node bin/gsd-tools.cjs codebase status --raw
   ```
   If no intel exists, run `codebase analyze` first.

2. Load the intel and run buildLifecycleGraph:
   ```
   node -e "
   const { readIntel } = require('./src/lib/codebase-intel');
   const { buildLifecycleGraph } = require('./src/lib/lifecycle');
   const cwd = '.';
   const intel = readIntel(cwd);
   if (!intel) { console.log('No intel'); process.exit(1); }
   const result = buildLifecycleGraph(intel, cwd);
   console.log(JSON.stringify(result, null, 2));
   "
   ```

3. Verify the output:
   - Appropriate detectors activate based on project type
   - Any detected patterns produce correct nodes/chains
   - Empty or missing data handled gracefully
   </action>
  <verify>
Run the lifecycle detection — output should have `nodes.length > 0` if the project has relevant files. Also test with empty intel: `node -e "const { buildLifecycleGraph } = require('./src/lib/lifecycle'); console.log(JSON.stringify(buildLifecycleGraph({ files: {} }, '.')));"` — should return `{ nodes: [], chains: [], cycles: [], ... }` without errors.
  </verify>
  <done>
Lifecycle detection produces correct results against real project data. Generic migration detector orders numbered/timestamped files correctly. Empty/missing data handled gracefully without crashes.
  </done>
</task>

</tasks>

<verification>
1. `node -e "require('./src/lib/lifecycle')"` loads without errors
2. `LIFECYCLE_DETECTORS` has 2 entries (generic-migrations, elixir-phoenix)
3. `buildLifecycleGraph()` returns correct shape: `{ nodes, edges, chains, cycles, detectors_used, stats, built_at }`
4. Empty intel produces empty result (no crashes)
5. Migration ordering is sequential (each file depends on previous)
6. must_run_before/must_run_after symmetry is maintained
7. Cycle detection works via findCycles from deps.js
8. Migration node cap (20) works correctly
</verification>

<success_criteria>
- src/lib/lifecycle.js exists with 2 lifecycle detectors
- buildLifecycleGraph() produces valid DAG with nodes, chains, and cycle detection
- Tested against real project data
- No crashes on edge cases (empty intel, no frameworks, no migrations)
</success_criteria>

<output>
After completion, create `.planning/phases/28-lifecycle-analysis/28-01-SUMMARY.md`
</output>
