---
phase: 28-lifecycle-analysis
plan: 02
type: execute
wave: 2
depends_on: [28-01]
files_modified:
  - src/commands/codebase.js
  - src/router.js
  - bin/gsd-tools.cjs
  - bin/gsd-tools.test.cjs
autonomous: true
requirements: [LIFE-01, LIFE-02, LIFE-03]
outcome_ids: [DO-07, DO-09]

must_haves:
  truths:
    - "User can run `codebase lifecycle` to see execution order relationships"
    - "JSON output via --raw returns structured lifecycle data (nodes, chains, cycles, stats)"
    - "Human-readable output shows lifecycle chains in readable format"
    - "Lifecycle data is cached in codebase-intel.json as intel.lifecycle"
    - "autoTriggerCodebaseIntel preserves lifecycle data during background re-analysis"
    - "Tests verify detector activation, chain building, and CLI output"
  artifacts:
    - path: "src/commands/codebase.js"
      provides: "cmdCodebaseLifecycle() command function"
      exports: ["cmdCodebaseLifecycle"]
    - path: "src/router.js"
      provides: "'lifecycle' case in codebase switch"
      contains: "lifecycle"
    - path: "bin/gsd-tools.cjs"
      provides: "Rebuilt bundle with lifecycle command"
    - path: "bin/gsd-tools.test.cjs"
      provides: "Test cases for lifecycle detection and CLI"
  key_links:
    - from: "src/commands/codebase.js"
      to: "src/lib/lifecycle.js"
      via: "require for buildLifecycleGraph"
      pattern: "require.*lifecycle.*buildLifecycleGraph"
    - from: "src/router.js"
      to: "src/commands/codebase.js"
      via: "lazyCodebase().cmdCodebaseLifecycle"
      pattern: "cmdCodebaseLifecycle"
    - from: "src/commands/codebase.js"
      to: "autoTriggerCodebaseIntel"
      via: "intel.lifecycle preservation during refresh"
      pattern: "intel\\.lifecycle"
---

<objective>
Wire the lifecycle analysis library into the CLI as `codebase lifecycle`, integrate with caching/auto-trigger infrastructure, rebuild the bundle, and add test coverage.

Purpose: Make lifecycle analysis accessible to users and agents via the standard `codebase lifecycle` command, with JSON and human-readable output. Ensure lifecycle data survives background re-analysis and is properly cached.

Output: Working `codebase lifecycle` command, updated bundle, test coverage, lifecycle data preserved in autoTrigger.
</objective>

<execution_context>
@__OPENCODE_CONFIG__/get-shit-done/workflows/execute-plan.md
@__OPENCODE_CONFIG__/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-lifecycle-analysis/28-CONTEXT.md
@.planning/phases/28-lifecycle-analysis/28-RESEARCH.md
@.planning/phases/28-lifecycle-analysis/28-01-SUMMARY.md

# Source files to modify
@src/commands/codebase.js
@src/router.js
@src/lib/lifecycle.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cmdCodebaseLifecycle command and wire into router</name>
  <files>src/commands/codebase.js, src/router.js</files>
  <action>
**In `src/commands/codebase.js`:**

Add `cmdCodebaseLifecycle(cwd, args, raw)` following the exact pattern of `cmdCodebaseDeps()` (lines ~461-513):

1. Read intel: `const intel = readIntel(cwd);` — if null, error and return ("No codebase intel. Run: codebase analyze")
2. Import lifecycle: `const { buildLifecycleGraph } = require('../lib/lifecycle');`
3. Build lifecycle graph: `const lifecycle = buildLifecycleGraph(intel, cwd);`
4. Cache in intel: `intel.lifecycle = lifecycle; writeIntel(cwd, intel);`
5. **JSON output** (raw mode): Output the lifecycle data structure:
   ```javascript
   output({
     success: true,
     nodes: lifecycle.nodes.length,
     edges: lifecycle.stats.edge_count,
     chains: lifecycle.chains,
     cycles: lifecycle.cycles,
     detectors_used: lifecycle.detectors_used,
     stats: lifecycle.stats,
     built_at: lifecycle.built_at
   }, raw);
   ```
6. **Human-readable output** (non-raw mode): Print to stderr before JSON output:
   - Header: `Lifecycle Analysis ({N} nodes, {M} chains)`
   - For each chain: `Chain {i}: {node1.file_or_step} → {node2.file_or_step} → ...` (show file paths, truncate if chain > 5 nodes showing first 3 + `... +N more` + last)
   - If cycles: `WARNING: {N} cycle(s) detected` with cycle node IDs
   - If no nodes: `No lifecycle patterns detected.`

**Lifecycle data preservation in `autoTriggerCodebaseIntel()`:**

In the synchronous branch (around line 284-290 where conventions and dependencies are preserved), add:
```javascript
if (intel.lifecycle && !newIntel.lifecycle) {
  newIntel.lifecycle = intel.lifecycle;
}
```
This goes right after the existing `intel.dependencies` preservation block.

**Also preserve in `cmdCodebaseAnalyze()`:**

In `cmdCodebaseAnalyze` (around line 63-69), after `performAnalysis()` returns and before `writeIntel()`, add preservation for background analysis mode (when `GSD_BG_ANALYSIS` env is set):
```javascript
// Preserve conventions, dependencies, lifecycle from previous intel (populated by separate commands)
if (previousIntel) {
  if (previousIntel.conventions && !intel.conventions) intel.conventions = previousIntel.conventions;
  if (previousIntel.dependencies && !intel.dependencies) intel.dependencies = previousIntel.dependencies;
  if (previousIntel.lifecycle && !intel.lifecycle) intel.lifecycle = previousIntel.lifecycle;
}
```
Note: Check if this preservation already exists in cmdCodebaseAnalyze. If it does, just add the lifecycle line. If not, add all three (conventions, dependencies, lifecycle) to fix the gap where background analysis overwrites these fields.

**Export:** Add `cmdCodebaseLifecycle` to the module.exports object.

**In `src/router.js`:**

Add `lifecycle` case to the codebase switch (around line 591, after the `context` case):
```javascript
} else if (sub === 'lifecycle') {
  lazyCodebase().cmdCodebaseLifecycle(cwd, args.slice(2), raw);
```

Update the error message to include 'lifecycle':
```
error('Usage: codebase <analyze|status|conventions|rules|deps|impact|context|lifecycle>');
```
  </action>
  <verify>
1. Build the bundle: `node scripts/build.js` (or whatever the build command is — check package.json or build script)
2. Run `node bin/gsd-tools.cjs codebase lifecycle --raw` from a project with intel — should return JSON with lifecycle data
3. Run `node bin/gsd-tools.cjs codebase lifecycle` (no --raw) — should show human-readable output
4. Verify `codebase lifecycle --help` or wrong args shows usage correctly
  </verify>
  <done>
`codebase lifecycle` command works in both raw and human-readable modes. Lifecycle data is cached in intel.lifecycle. autoTriggerCodebaseIntel and cmdCodebaseAnalyze both preserve lifecycle data during re-analysis. Router dispatches 'lifecycle' subcommand correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rebuild bundle and add test coverage</name>
  <files>bin/gsd-tools.cjs, bin/gsd-tools.test.cjs</files>
  <action>
**Rebuild bundle:**

Run the build script to produce updated `bin/gsd-tools.cjs` incorporating `src/lib/lifecycle.js` and the codebase.js changes. Check how prior phases built — likely `node scripts/build.js` or similar. Verify bundle size stays within 700KB budget.

**Add tests to `bin/gsd-tools.test.cjs`:**

Add a new `describe('codebase lifecycle', ...)` block (following the pattern of existing 'codebase conventions' and 'dependency graph' describe blocks). Tests:

1. **LIFECYCLE_DETECTORS registry exists and has expected detectors:**
   ```javascript
   it('has generic-migrations and elixir-phoenix detectors', () => {
     // Access LIFECYCLE_DETECTORS from the bundled module
     const detectorNames = LIFECYCLE_DETECTORS.map(d => d.name);
     assert(detectorNames.includes('generic-migrations'));
     assert(detectorNames.includes('elixir-phoenix'));
   });
   ```

2. **Generic detector activates on migration paths:**
   ```javascript
   it('generic detector detects migration directories', () => {
     const intel = { files: { 'priv/repo/migrations/20240101_create_users.exs': { lines: 10 } } };
     const detector = LIFECYCLE_DETECTORS.find(d => d.name === 'generic-migrations');
     assert(detector.detect(intel));
   });
   ```

3. **Generic detector returns ordered nodes:**
   ```javascript
   it('generic detector orders migrations sequentially', () => {
     const intel = { files: {
       'db/migrate/001_create_users.sql': { lines: 10 },
       'db/migrate/002_add_email.sql': { lines: 5 },
       'db/migrate/003_add_roles.sql': { lines: 8 },
     }};
     const detector = LIFECYCLE_DETECTORS.find(d => d.name === 'generic-migrations');
     const nodes = detector.extractLifecycle(intel, '.');
     assert.strictEqual(nodes.length, 3);
     assert.strictEqual(nodes[0].must_run_after.length, 0);
     assert(nodes[1].must_run_after.includes(nodes[0].id));
     assert(nodes[2].must_run_after.includes(nodes[1].id));
   });
   ```

4. **Phoenix detector only activates with framework detection:**
   ```javascript
   it('phoenix detector requires elixir-phoenix in conventions.frameworks', () => {
     const detector = LIFECYCLE_DETECTORS.find(d => d.name === 'elixir-phoenix');
     assert(!detector.detect({ files: {} }));
     assert(!detector.detect({ files: {}, conventions: {} }));
     assert(!detector.detect({ files: {}, conventions: { frameworks: [] } }));
     assert(detector.detect({ files: {}, conventions: { frameworks: [{ framework: 'elixir-phoenix' }] } }));
   });
   ```

5. **buildLifecycleGraph returns correct structure:**
   ```javascript
   it('buildLifecycleGraph returns valid structure for empty intel', () => {
     const result = buildLifecycleGraph({ files: {} }, '.');
     assert(Array.isArray(result.nodes));
     assert(Array.isArray(result.chains));
     assert(Array.isArray(result.cycles));
     assert(typeof result.stats === 'object');
     assert.strictEqual(result.nodes.length, 0);
   });
   ```

6. **Chain building produces correct ordering:**
   ```javascript
   it('chains are topologically sorted', () => {
     const intel = { files: {
       'db/migrate/001_first.sql': { lines: 5 },
       'db/migrate/002_second.sql': { lines: 5 },
       'db/migrate/003_third.sql': { lines: 5 },
     }};
     const result = buildLifecycleGraph(intel, '.');
     assert(result.chains.length >= 1);
     // First element in chain should be the earliest migration
     const chain = result.chains[0];
     assert(chain[0].includes('001'));
   });
   ```

7. **CLI integration — codebase lifecycle --raw returns JSON:**
   ```javascript
   it('codebase lifecycle --raw returns valid JSON', () => {
     // Run against the bgsd-oc project itself (which has intel)
     const result = execSync('node bin/gsd-tools.cjs codebase lifecycle --raw', { encoding: 'utf8', cwd: projectRoot });
     const parsed = JSON.parse(result);
     assert(parsed.success === true);
     assert(typeof parsed.nodes === 'number');
     assert(Array.isArray(parsed.chains));
   });
   ```

Adjust test patterns to match how the existing test file accesses internal functions (it may use the bundled file's exports or require the source directly). Look at existing 'dependency graph' and 'codebase conventions' test blocks for the pattern.
  </action>
  <verify>
1. Run test suite: `node bin/gsd-tools.test.cjs` — all tests pass including new lifecycle tests
2. Verify bundle size: `ls -la bin/gsd-tools.cjs` — should be under 700KB
3. Run `node bin/gsd-tools.cjs codebase lifecycle --raw` from bgsd-oc root — returns valid JSON (even if no lifecycle patterns found in this project, should return success with 0 nodes)
4. Run `codebase lifecycle` from current project with relevant codebase intel — should detect lifecycle patterns appropriate to the project
  </verify>
  <done>
Bundle rebuilt within 700KB budget. 7+ test cases pass covering detector activation, migration ordering, Phoenix framework gating, empty intel handling, chain building, and CLI integration. `codebase lifecycle` works end-to-end from CLI.
  </done>
</task>

</tasks>

<verification>
1. `node bin/gsd-tools.cjs codebase lifecycle --raw` returns valid JSON with `{ success, nodes, edges, chains, cycles, detectors_used, stats, built_at }`
2. `node bin/gsd-tools.cjs codebase lifecycle` (no --raw) shows human-readable chain output
3. `node bin/gsd-tools.test.cjs` passes all tests including new lifecycle tests
4. Bundle size under 700KB
5. `codebase lifecycle` called twice: second call uses cached intel.lifecycle (verify by checking writeIntel only updates lifecycle field)
6. autoTriggerCodebaseIntel preserves lifecycle data when re-analyzing
</verification>

<success_criteria>
- `codebase lifecycle` command accessible via CLI with both raw and human-readable output
- Lifecycle data cached in codebase-intel.json under intel.lifecycle
- autoTriggerCodebaseIntel and cmdCodebaseAnalyze preserve lifecycle data during re-analysis
- 7+ tests pass covering detectors, chains, CLI, and edge cases
- Bundle size within budget
</success_criteria>

<output>
After completion, create `.planning/phases/28-lifecycle-analysis/28-02-SUMMARY.md`
</output>
