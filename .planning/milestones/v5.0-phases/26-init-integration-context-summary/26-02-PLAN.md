---
phase: 26-init-integration-context-summary
plan: 02
type: execute
wave: 2
depends_on: [26-01]
files_modified:
  - src/commands/codebase.js
  - src/commands/init.js
  - bin/gsd-tools.test.cjs
  - bin/gsd-tools.cjs
autonomous: true
requirements: [CTXI-01, INFRA-04]

must_haves:
  truths:
    - "Auto-trigger serves cached data immediately and spawns detached background process for re-analysis when stale"
    - "Init commands complete in <200ms even when analysis is triggered"
    - "Lock file prevents concurrent background analysis processes"
    - "Lock file auto-expires after 5 minutes (stale lock cleanup)"
    - "--refresh flag on init commands forces synchronous full re-analysis"
    - "Background analysis failures are silent — lock file cleaned up, no crash"
    - "All existing tests pass plus new tests cover background trigger, lock file, refresh, three-field summary"
  artifacts:
    - path: "src/commands/codebase.js"
      provides: "Non-blocking background analysis trigger with lock file"
      contains: "spawnBackground|\.analyzing|detached"
    - path: "src/commands/init.js"
      provides: "--refresh flag handling"
      contains: "refresh|clearCache"
    - path: "bin/gsd-tools.test.cjs"
      provides: "Tests for Phase 26 features"
      contains: "context summary|background|lock file"
    - path: "bin/gsd-tools.cjs"
      provides: "Rebuilt bundle with all Phase 26 changes"
  key_links:
    - from: "src/commands/codebase.js"
      to: "child_process.spawn"
      via: "detached background process for async re-analysis"
      pattern: "spawn.*detached.*true"
    - from: "src/commands/codebase.js"
      to: ".planning/.cache/.analyzing"
      via: "lock file prevents concurrent triggers"
      pattern: "\\.analyzing"
    - from: "src/commands/init.js"
      to: "src/commands/codebase.js"
      via: "autoTriggerCodebaseIntel now returns cached immediately"
      pattern: "autoTriggerCodebaseIntel"
---

<objective>
Implement non-blocking background analysis with lock file mechanism and --refresh flag, then add comprehensive test coverage and rebuild bundle.

Purpose: Init commands must never block waiting for analysis (<200ms). When intel is stale, serve cached data immediately and spawn a detached child process that runs analysis in the background — directly serving INTENT constraint C-03 (all operations are advisory, never block workflow execution).

Output: Background analysis spawner, lock file management, --refresh flag, tests, rebuilt bundle.
</objective>

<execution_context>
@__OPENCODE_CONFIG__/get-shit-done/workflows/execute-plan.md
@__OPENCODE_CONFIG__/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/INTENT.md
@.planning/phases/26-init-integration-context-summary/26-CONTEXT.md
@.planning/phases/26-init-integration-context-summary/26-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Background analysis spawner + lock file + --refresh flag</name>
  <files>src/commands/codebase.js, src/commands/init.js</files>
  <action>
**1. Background analysis spawner in `src/commands/codebase.js`:**

Refactor `autoTriggerCodebaseIntel(cwd)` to be non-blocking. When intel is stale:
- Return cached (stale) intel immediately — do NOT block for re-analysis
- Spawn a detached child process that runs `node bin/gsd-tools.cjs codebase analyze` in the background
- The child process must outlive the parent init command (`detached: true`, `unref()`)

```js
const { spawn } = require('child_process');

function spawnBackgroundAnalysis(cwd) {
  const lockPath = path.join(cwd, '.planning', '.cache', '.analyzing');
  
  // Check lock file — skip if already running
  try {
    const lockStat = fs.statSync(lockPath);
    const lockAgeMs = Date.now() - lockStat.mtimeMs;
    const LOCK_TIMEOUT = 5 * 60 * 1000; // 5 minutes
    if (lockAgeMs < LOCK_TIMEOUT) {
      debugLog('codebase.bgAnalysis', 'lock file exists, skipping');
      return;
    }
    // Lock is stale — clean up and proceed
    debugLog('codebase.bgAnalysis', 'stale lock detected, cleaning up');
    fs.unlinkSync(lockPath);
  } catch (e) {
    if (e.code !== 'ENOENT') {
      debugLog('codebase.bgAnalysis', 'lock check error', e);
      return;
    }
  }
  
  // Ensure .cache directory exists
  const cacheDir = path.join(cwd, '.planning', '.cache');
  try { fs.mkdirSync(cacheDir, { recursive: true }); } catch {}
  
  // Create lock file
  try { fs.writeFileSync(lockPath, String(process.pid)); } catch { return; }
  
  // Spawn detached analysis
  try {
    const gsdBin = path.join(__dirname, '..', '..', 'bin', 'gsd-tools.cjs');
    const child = spawn(process.execPath, [gsdBin, 'codebase', 'analyze', '--raw'], {
      cwd,
      detached: true,
      stdio: 'ignore',
      env: { ...process.env, GSD_BG_ANALYSIS: '1' }
    });
    child.unref();
    debugLog('codebase.bgAnalysis', `spawned background analysis (pid: ${child.pid})`);
  } catch (e) {
    debugLog('codebase.bgAnalysis', 'spawn failed', e);
    // Clean up lock on spawn failure
    try { fs.unlinkSync(lockPath); } catch {}
  }
}
```

Update `autoTriggerCodebaseIntel`:
```js
function autoTriggerCodebaseIntel(cwd, options = {}) {
  const { synchronous = false } = options;
  // ... existing null checks ...
  
  const staleness = checkStaleness(cwd);
  if (!staleness.stale) return intel;
  
  if (synchronous) {
    // --refresh mode: block and run full analysis
    const newIntel = performAnalysis(cwd, { ... });
    writeIntel(cwd, newIntel);
    return newIntel;
  }
  
  // Non-blocking: return stale data, spawn background
  spawnBackgroundAnalysis(cwd);
  return intel; // Return existing (stale) data immediately
}
```

Also: In `cmdCodebaseAnalyze`, at the END after successful analysis, clean up the lock file:
```js
// Clean up lock file after analysis completes (background or foreground)
try { fs.unlinkSync(path.join(cwd, '.planning', '.cache', '.analyzing')); } catch {}
```

**2. --refresh flag in init commands (`src/commands/init.js`):**

Add `--refresh` support to detect and pass to `autoTriggerCodebaseIntel`:

In `cmdInitProgress`, `cmdInitExecutePhase`, `cmdInitPlanPhase`, `cmdInitPhaseOp` — check if `args` includes `--refresh`:
- The existing function signatures for progress/executePhase/planPhase don't take args. Look at how they're called from the router.
- For the simplest approach: check `process.argv.includes('--refresh')` inside the codebase intel try/catch block.
- When `--refresh` is detected: call `autoTriggerCodebaseIntel(cwd, { synchronous: true })` which forces synchronous full re-analysis and clears any stale cache.
- Also delete `.planning/.cache/.analyzing` lock file before running synchronous analysis (in case a stale lock would interfere).

**3. Ensure `.planning/.cache` is gitignored:**

Check if `.planning/.gitignore` or `.gitignore` already covers `.cache/`. If not, add `.cache/` to `.planning/.gitignore` (or create it if needed). This is ephemeral derived data per CONTEXT.md decision.

**Critical constraints:**
- `spawnBackgroundAnalysis` must NEVER throw — wrap everything in try/catch.
- Lock file path: `.planning/.cache/.analyzing` (per CONTEXT.md decision).
- Lock timeout: 5 minutes (per CONTEXT.md decision).
- Detached child uses `stdio: 'ignore'` — no output inheritance.
- Use `process.execPath` (not `'node'`) for the spawned process to use the same Node.js binary.
- The `path` to `gsd-tools.cjs` must be resolved relative to the module location, NOT cwd. Use `path.resolve(__dirname, '../../bin/gsd-tools.cjs')` since codebase.js is in `src/commands/`.
  </action>
  <verify>
Test non-blocking: `time node bin/gsd-tools.cjs init progress --raw 2>/dev/null | python3 -c "import json,sys; d=json.load(sys.stdin); print('has_stats:', d.get('codebase_stats') is not None)"` — should complete in <500ms.
Test --refresh: `node bin/gsd-tools.cjs init progress --refresh --raw 2>/dev/null | python3 -c "import json,sys; d=json.load(sys.stdin); print('stats:', d.get('codebase_stats',{}).get('confidence','MISSING'))"` — should show confidence score after forced re-analysis.
Test lock file: `ls .planning/.cache/.analyzing 2>/dev/null; echo "exit: $?"` — should show file exists briefly during analysis then cleaned up.
  </verify>
  <done>autoTriggerCodebaseIntel returns immediately with cached data. Background detached process runs analysis asynchronously. Lock file prevents concurrent triggers. --refresh forces synchronous analysis. Init commands never block >200ms.</done>
</task>

<task type="auto">
  <name>Task 2: Add test coverage and rebuild bundle</name>
  <files>bin/gsd-tools.test.cjs, bin/gsd-tools.cjs</files>
  <action>
**1. Add tests in `bin/gsd-tools.test.cjs`:**

Add a new `describe('phase 26: init context summary', ...)` block inside the existing `describe('codebase intelligence', ...)` section. Tests should use the existing `createCodebaseProject` helper (creates temp git-initialized dirs with source files).

Test cases:

a) **Three-field summary format**: Run `codebase analyze` on a test project, then run `init progress --raw`. Verify output contains `codebase_stats` (not `codebase_summary`), and that `codebase_stats.confidence` exists.

b) **Convention field present**: Run `codebase conventions` then `init progress --raw`. Verify `codebase_conventions` is not null when conventions data exists in intel.

c) **Dependencies field present**: Run `codebase deps` then `init progress --raw`. Verify `codebase_dependencies` is not null when dependency data exists in intel.

d) **Null handling for missing data**: Create a project with intel that has stats but NO conventions/deps data. Run `init progress --raw`. Verify `codebase_stats` exists but `codebase_conventions` and `codebase_dependencies` are absent (null fields stripped from output).

e) **Hybrid staleness — time-based**: Create intel with `generated_at` set to 2 hours ago but matching `git_commit_hash`. Run `codebase status --raw`. Verify `stale: true` with `reason: 'time_stale'`.

f) **Lock file prevents concurrent triggers**: Create the `.planning/.cache/.analyzing` lock file manually (fresh). Call `autoTriggerCodebaseIntel`. Verify no new background process is spawned (check that lock file PID hasn't changed).

g) **Stale lock file cleanup**: Create lock file with mtime >5 minutes old. Call auto-trigger. Verify the stale lock is cleaned up and new analysis proceeds.

h) **--refresh forces synchronous analysis**: Modify intel to be stale, run `init progress --refresh --raw`. Verify new `generated_at` timestamp is recent (not the old stale one).

Each test should be self-contained with its own temp directory and proper cleanup.

**2. Rebuild the bundle:**

Run the existing build command to produce `bin/gsd-tools.cjs`. Follow the established pattern from prior phases:
```bash
npm run build
```
Or if no build script, follow whatever bundling process is established (check package.json scripts).

Verify bundle size stays within 700KB budget.

**3. Run full test suite:**

Run all tests and ensure zero regressions:
```bash
node --test bin/gsd-tools.test.cjs
```

All 641+ existing tests must pass alongside the new tests.
  </action>
  <verify>
`node --test bin/gsd-tools.test.cjs` — all tests pass (0 failures).
`ls -la bin/gsd-tools.cjs | awk '{print $5}'` — bundle size under 700KB (717760 bytes).
`node bin/gsd-tools.cjs init progress --raw 2>/dev/null | python3 -c "import json,sys; d=json.load(sys.stdin); print('PASS' if 'codebase_stats' in d else 'FAIL')"` — prints PASS.
  </verify>
  <done>8+ new tests covering three-field format, convention/dependency injection, null handling, hybrid staleness, lock file mechanism, --refresh flag. All tests pass. Bundle rebuilt within size budget.</done>
</task>

</tasks>

<verification>
- `node --test bin/gsd-tools.test.cjs` — all tests pass
- `node bin/gsd-tools.cjs init progress --raw` includes codebase_stats, codebase_conventions (if conventions exist), codebase_dependencies (if deps exist)
- `node bin/gsd-tools.cjs init execute-phase 26 --raw` — same three-field structure
- `time node bin/gsd-tools.cjs init progress --raw` completes in <500ms (non-blocking)
- `node bin/gsd-tools.cjs init progress --refresh --raw` forces fresh analysis
- Lock file `.planning/.cache/.analyzing` created during background analysis, cleaned up after
- Bundle size under 700KB
</verification>

<success_criteria>
Non-blocking background analysis with lock file mechanism operational. --refresh flag forces synchronous re-analysis. Comprehensive tests validate all Phase 26 features. Bundle rebuilt and all tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/26-init-integration-context-summary/26-02-SUMMARY.md`
</output>
