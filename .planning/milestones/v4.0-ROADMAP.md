# Milestone v4.0: Environment & Execution Intelligence

**Status:** SHIPPED 2026-02-25
**Phases:** 18-22
**Total Plans:** 13

## Overview

Give GSD awareness of the development environment (tools, MCP servers), structured verification criteria, and parallel execution capability so AI agents make fewer mistakes, consume less context, and work faster.

## Phases

### Phase 18: Environment Awareness

**Goal**: Agents know what languages, tools, and runtimes are available in the project before they start working
**Depends on**: Nothing (first phase of v4.0)
**Requirements**: ENV-01, ENV-02, ENV-03, ENV-04, ENV-05, ENV-06
**Plans**: 3 plans

Plans:
- [x] 18-01: Core detection engine — 26 manifest patterns, package manager precedence, binary version checks with 3s timeout
- [x] 18-02: Manifest persistence — env-manifest.json with staleness detection, committed project-profile.json
- [x] 18-03: Init command integration — readEnvManifest/formatEnvSummary/autoTriggerEnvScan wired into 4 init commands

**Details:**
- Detection engine scans 26+ language manifest patterns (node, go, elixir, rust, python, ruby, php, java, kotlin, swift, cpp, make, just, docker, nix, deno, bun)
- Package manager detection with precedence: bun > pnpm > yarn > npm, with packageManager field override
- Binary availability checking with 3-second timeout per binary
- Comprehensive tooling detection: version managers, CI, test frameworks, linters, docker-compose services, MCP servers, monorepo configs
- Two-file output: gitignored env-manifest.json (machine-specific) + committed project-profile.json (team-visible)
- Staleness detection via watched file mtime comparison
- Compact "Tools: node@20.11 (pnpm), go@1.21" format injected into init commands

### Phase 19: MCP Server Profiling

**Goal**: Users can see exactly how many tokens their MCP servers consume and get actionable recommendations to reduce context waste
**Depends on**: Nothing (independent of Phase 18)
**Requirements**: MCP-01, MCP-02, MCP-03, MCP-04, MCP-05
**Plans**: 3 plans

Plans:
- [x] 19-01: Server discovery — .mcp.json + opencode.json discovery with 20-server token estimation database
- [x] 19-02: Relevance scoring — 16-type indicator matching against project files with keep/disable/review recommendations
- [x] 19-03: Auto-disable — backup/restore functionality for opencode.json with --apply/--restore/--dry-run flags

**Details:**
- MCP config discovery from 3 sources (.mcp.json, opencode.json, user-level config) with priority-based deduplication
- 20-server known database with regex pattern matching for token estimation
- Relevance scoring against project file indicators with env hint detection (.env, docker-compose)
- Low-cost threshold at 1000 tokens — servers below always marked relevant
- Auto-disable modifies opencode.json only (not .mcp.json — no standard disable field)
- Backup before mutation, restore capability

### Phase 20: Structured Requirements

**Goal**: Requirements carry testable acceptance criteria that flow through planning into verification, closing the loop between "what we said" and "what we proved"
**Depends on**: Nothing (independent of Phases 18-19)
**Requirements**: SREQ-01, SREQ-02, SREQ-03, SREQ-04, SREQ-05
**Plans**: 3 plans

Plans:
- [x] 20-01: Assertion schema — ASSERTIONS.md template, parseAssertionsMd() parser, assertions list/validate CLI commands
- [x] 20-02: Per-assertion verification — verify requirements with per-assertion pass/fail, test-command parsing, trace-requirement assertion chain
- [x] 20-03: Planner workflow integration — assertion-aware plan-phase workflow, auto-populated must_haves.truths, template updates

**Details:**
- ASSERTIONS.md template with structured acceptance criteria per requirement (2-5 assertions each)
- Parser with heading-based section splitting (## REQ-ID: format)
- Per-assertion status: pass | fail | needs_human (file/cli auto-checked, behavior/api need human)
- Test-command column in traceability table with validity checking
- Gap descriptions for failed must-have assertions feed into --gaps planning workflow
- Planner derives must_haves.truths from assertions, falls back to requirement text
- 12 net new lines in plan-phase workflow — minimal integration footprint

### Phase 21: Worktree Parallelism

**Goal**: Multiple plans within a wave execute in parallel via isolated git worktrees, with conflict detection and sequential merge
**Depends on**: Phase 18 (env manifest used for setup hooks — graceful degradation if missing)
**Requirements**: WKTR-01, WKTR-02, WKTR-03, WKTR-04, WKTR-05, WKTR-06
**Plans**: 3 plans

Plans:
- [x] 21-01: Worktree lifecycle — create/list/remove/cleanup commands with config-driven defaults and resource validation
- [x] 21-02: Merge with conflict pre-check — git merge-tree dry-run, lockfile auto-resolution, static file overlap detection
- [x] 21-03: Workflow integration — execute-phase Mode A (worktree-parallel) / Mode B (standard sequential), init command worktree context

**Details:**
- Full worktree lifecycle: create isolated worktrees with named branches, list with disk usage, remove, cleanup
- Config-driven: base_path, sync_files, setup_hooks, max_concurrent in config.json worktree section
- Resource validation: RAM check against max_concurrent * 4GB, disk space check
- Two-level conflict detection: static (PLAN.md frontmatter files_modified) + dynamic (git merge-tree)
- Lockfile auto-resolution via checkout --theirs during conflicted merge
- Execute-phase workflow with three-gate check: worktree_enabled AND parallelization AND multi-plan wave
- Merge ordering: plan number order (smallest first) for predictability
- Yolo/auto mode skips conflicting plans on merge failure

### Phase 22: Workflow Polish

**Goal**: Sessions end cleanly with a summary and context reset prompt, so the next session starts fresh
**Depends on**: Phase 18 (uses env context for session summary — graceful degradation)
**Requirements**: WFLW-01
**Plans**: 1 plan

Plans:
- [x] 22-01: Session summary CLI + complete-and-clear workflow for clean session endings with next-action suggestions

**Details:**
- session-summary CLI command reads STATE.md + ROADMAP.md, returns structured JSON handoff data
- Next action logic: incomplete plans → execute, no plans → plan, all done → complete milestone
- complete-and-clear workflow with formatted UI, STATE.md update, and /clear reminder
- Compact implementation (~60 lines) to stay within 550KB bundle budget

---

## Milestone Summary

**Key Decisions:**
- Bundle budget progressively raised: 450KB → 500KB → 525KB → 550KB across phases (env ~19KB, mcp ~20KB, assertions ~9KB, worktree ~16KB)
- Structured assertions over Gherkin — 80% benefit at 20% ceremony, research-backed
- Static MCP profiling over runtime connection — known-server database sufficient, no need to spawn servers
- Worktrees as execution mechanism on existing wave system — not architectural change
- Only opencode.json mutated by --apply (not .mcp.json — no standard disable field)
- Two-file env output: gitignored env-manifest.json + committed project-profile.json
- Per-assertion hybrid verification: file/cli auto-checked, behavior/api always need_human
- Worktree execution gated on three conditions: worktree_enabled AND parallelization AND multi-plan wave
- Compact implementations throughout to stay within bundle budget

**Issues Resolved:**
- Fixed traceability table regex cross-row matching ([^|]* → [^|\n]*)
- Fixed lockfile auto-resolution merge flow (checkout --theirs + git add + commit)
- Fixed --verbose flag consumption by global arg parser
- Fixed test isolation for user-level MCP config (HOME env var override)

**Issues Deferred:**
- None — all v4.0 requirements complete

**Technical Debt Incurred:**
- Bundle at 549KB / 550KB — minimal headroom for future additions to existing commands
- Intent help text trimmed to fit MCP code — functionality unchanged but help descriptions shorter

---

_For current project status, see .planning/ROADMAP.md_
