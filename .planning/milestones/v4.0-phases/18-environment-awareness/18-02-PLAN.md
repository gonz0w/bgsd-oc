---
phase: 18-environment-awareness
plan: 02
type: execute
wave: 2
depends_on:
  - 18-01
files_modified:
  - bin/gsd-tools.cjs
  - bin/gsd-tools.test.cjs
autonomous: true
requirements:
  - ENV-04
  - ENV-06

must_haves:
  truths:
    - "env scan writes env-manifest.json to .planning/ directory"
    - "env-manifest.json contains all detection results with sources"
    - "env-manifest.json is gitignored (machine-specific)"
    - "Changing package.json and running env scan detects staleness and re-scans"
    - "env scan --force always re-scans regardless of staleness"
    - "Staleness check compares manifest mtime against watched file mtimes"
    - "Stale manifest triggers automatic rescan with notification message"
  artifacts:
    - path: "bin/gsd-tools.cjs"
      provides: "Manifest write and staleness logic in cmdEnvScan"
      contains: "env-manifest.json"
    - path: "bin/gsd-tools.test.cjs"
      provides: "Tests for manifest persistence and staleness"
      contains: "staleness"
  key_links:
    - from: "bin/gsd-tools.cjs cmdEnvScan"
      to: ".planning/env-manifest.json"
      via: "fs.writeFileSync after detection"
      pattern: "env-manifest\\.json"
    - from: "bin/gsd-tools.cjs staleness check"
      to: "fs.statSync mtime comparison"
      via: "manifest mtime vs watched file mtimes"
      pattern: "mtime|mtimeMs|staleness"
---

<objective>
Add manifest persistence and staleness detection to the environment scanner.

Purpose: Detection results need to be persisted so init commands can read them without re-scanning every time. Staleness detection ensures the manifest stays current when project files change.
Output: `env-manifest.json` written to `.planning/` with auto-staleness detection and re-scan.
</objective>

<execution_context>
@__OPENCODE_CONFIG__/get-shit-done/workflows/execute-plan.md
@__OPENCODE_CONFIG__/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/18-environment-awareness/18-CONTEXT.md
@.planning/phases/18-environment-awareness/18-01-SUMMARY.md
@.planning/codebase/CONVENTIONS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add manifest persistence and committed project profile</name>
  <files>bin/gsd-tools.cjs</files>
  <action>
Extend `cmdEnvScan` (created in Plan 01) to write detection results to disk.

**1. Manifest output (ENV-04):**

After detection completes, write the full result to `.planning/env-manifest.json`:
```javascript
const manifestPath = path.join(cwd, '.planning', 'env-manifest.json');
```

The JSON schema must include:
```javascript
{
  "$schema_version": "1.0",
  "scanned_at": "2026-02-25T12:00:00.000Z",
  "detection_ms": 8,
  "languages": [...],           // from Plan 01 detection
  "package_manager": {...},     // from Plan 01 detection
  "version_managers": [...],    // from Plan 01 detection
  "tools": {...},               // from Plan 01 detection
  "scripts": {...},             // from Plan 01 detection
  "infrastructure": {...},      // from Plan 01 detection
  "monorepo": null | {...},     // from Plan 01 detection
  "watched_files": ["package.json", "go.mod", "mix.exs", ...],  // files used for staleness
  "watched_files_mtimes": { "package.json": 1708876800000, ... } // mtime of each watched file at scan time
}
```

The `watched_files` array should include: all detected manifest files at root level (depth 0), all detected lockfiles, version manager files, docker-compose files. These are the files whose changes should trigger a re-scan.

`watched_files_mtimes` records each watched file's `fs.statSync(f).mtimeMs` at scan time.

Only write manifest if `.planning/` directory exists. If it doesn't exist, still return JSON to stdout but skip file write (the project may not be initialized with GSD yet).

**2. Committed project profile (per CONTEXT.md decision):**

Also write `.planning/project-profile.json` — a committed (not gitignored) subset containing non-machine-specific structure info:
```javascript
{
  "$schema_version": "1.0",
  "generated_at": "2026-02-25T12:00:00.000Z",
  "languages": ["node", "go", "elixir"],  // just names, no versions
  "primary_language": "elixir",
  "package_manager": "mix",
  "monorepo": { "type": "umbrella", "members": ["apps/core", "apps/web"] } | null,
  "ci_platform": "github-actions" | null,
  "infrastructure_services": ["postgres", "redis"]  // from docker-compose
}
```

This file is safe to commit — it helps team members understand project structure without running a scan.

**3. Ensure gitignore entry:**

Check if `.planning/.gitignore` or root `.gitignore` contains `env-manifest.json`. If not present and `.planning/.gitignore` exists, append `env-manifest.json` to it. If neither gitignore exists but `.planning/` exists, create `.planning/.gitignore` with `env-manifest.json`.

**4. Silent vs verbose output:**

Per CONTEXT.md: `env scan` is silent by default (writes file, prints nothing to stdout unless `--raw` flag).
- No flags: write manifest, print nothing (silent)
- `--raw`: write manifest AND print full JSON to stdout
- `--verbose`: write manifest AND print human-readable summary to stderr

Add the `--verbose` flag parsing to `cmdEnvScan`.
  </action>
  <verify>
Run: `node bin/gsd-tools.cjs env scan` — should create `.planning/env-manifest.json` silently.
Run: `cat .planning/env-manifest.json | node -e "const d=JSON.parse(require('fs').readFileSync('/dev/stdin','utf8')); console.log('schema:', d['$schema_version'], 'watched:', d.watched_files?.length)"` — should show schema version and watched file count.
Run: `ls .planning/project-profile.json` — should exist.
  </verify>
  <done>
`env scan` writes `env-manifest.json` to `.planning/` with full detection results, watched files list, and mtimes. Also writes `project-profile.json` with committed-safe project structure info. `env-manifest.json` is added to gitignore. Silent by default, `--raw` outputs JSON, `--verbose` prints summary.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add staleness detection and auto-rescan</name>
  <files>bin/gsd-tools.cjs, bin/gsd-tools.test.cjs</files>
  <action>
**1. Staleness detection function:**

Create a helper function `checkEnvManifestStaleness(cwd)` that:
- Reads `.planning/env-manifest.json`
- If manifest doesn't exist: return `{ stale: true, reason: 'no_manifest' }`
- Compare `watched_files_mtimes` against current `fs.statSync` mtimes for each watched file
- If any watched file has a newer mtime than recorded: return `{ stale: true, reason: 'files_changed', changed_files: [...] }`
- Also check git: run `execGit(cwd, ['diff', '--name-only', 'HEAD'])` and check if any watched files appear in uncommitted changes
- If manifest is fresh: return `{ stale: false }`

**2. Auto-rescan on staleness (ENV-06):**

Modify `cmdEnvScan` to check staleness FIRST (before scanning):
- If `--force` flag: skip staleness check, always scan
- If manifest exists and NOT stale: print "Environment manifest is current" to stderr (if --verbose) and exit early (return existing manifest data)
- If manifest exists and IS stale: print "Environment changed (package.json modified), rescanning..." to stderr, then proceed with full scan
- If no manifest exists: proceed with full scan silently

This means `env scan` becomes idempotent — running it repeatedly only re-scans when needed.

**3. `env scan --force` override:**

Already stubbed in Plan 01. Now wire it: `--force` bypasses staleness check entirely.

**4. `env status` subcommand:**

Add `env status` subcommand that reports staleness without scanning:
```javascript
// In main() router, under 'env' case:
if (subcommand === 'status') { cmdEnvStatus(cwd, args, raw); }
```

`cmdEnvStatus(cwd, args, raw)`:
- Read manifest, check staleness
- Return: `{ exists: true/false, stale: true/false, reason, scanned_at, age_minutes, languages_count, changed_files }`

**5. Tests:**

Add to `bin/gsd-tools.test.cjs`:
- Test staleness detection with fresh manifest → not stale
- Test staleness detection after touching a watched file → stale
- Test staleness detection with missing manifest → stale with reason 'no_manifest'
- Test `--force` flag bypasses staleness
- Test `env status` returns correct staleness info
- Test that auto-rescan actually re-writes the manifest when stale
  </action>
  <verify>
Run: `node bin/gsd-tools.cjs env scan --force` — should always scan.
Run: `node bin/gsd-tools.cjs env status --raw` — should show staleness info.
Run: `touch package.json 2>/dev/null; node bin/gsd-tools.cjs env status --raw | node -e "const d=JSON.parse(require('fs').readFileSync('/dev/stdin','utf8')); console.log('stale:', d.stale)"` — if a watched file was touched, should show stale: true.
Run: `node --test bin/gsd-tools.test.cjs --test-name-pattern="staleness" 2>&1` — staleness tests pass.
  </verify>
  <done>
Staleness detection compares manifest watched_files_mtimes against current filesystem. Stale manifests trigger automatic rescan with stderr notification. `--force` bypasses staleness. `env status` reports staleness without scanning. All staleness tests pass.
  </done>
</task>

</tasks>

<verification>
1. `env scan` writes `.planning/env-manifest.json` with schema_version, watched_files, and watched_files_mtimes
2. `env scan` also writes `.planning/project-profile.json` with committed-safe subset
3. `env-manifest.json` is gitignored
4. Running `env scan` twice without file changes → second run exits early (idempotent)
5. Touching a watched file then running `env scan` → triggers rescan
6. `env scan --force` always rescans
7. `env status --raw` returns staleness info
8. All tests pass including new staleness tests
</verification>

<success_criteria>
`env-manifest.json` is written to `.planning/` with complete detection data and staleness metadata. Running `env scan` is idempotent — only re-scans when project files change. `--force` overrides staleness. `env status` reports freshness without triggering a scan. Project profile is committed for team visibility.
</success_criteria>

<output>
After completion, create `.planning/phases/18-environment-awareness/18-02-SUMMARY.md`
</output>
