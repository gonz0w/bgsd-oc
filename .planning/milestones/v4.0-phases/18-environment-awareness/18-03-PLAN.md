---
phase: 18-environment-awareness
plan: 03
type: execute
wave: 3
depends_on:
  - 18-02
files_modified:
  - bin/gsd-tools.cjs
  - bin/gsd-tools.test.cjs
autonomous: true
requirements:
  - ENV-05

must_haves:
  truths:
    - "init progress --raw output includes a Tools line when env-manifest.json exists"
    - "init execute-phase output includes environment info when manifest exists"
    - "Tools line is compact format like 'Tools: node@20.11 (pnpm), mix@1.16, go@1.21'"
    - "Missing manifest means no Tools line — graceful degradation, no error"
    - "First init command auto-triggers env scan if no manifest exists"
    - "Stale manifest triggers auto-rescan on init command"
  artifacts:
    - path: "bin/gsd-tools.cjs"
      provides: "Updated init commands with environment injection"
      contains: "env_summary"
    - path: "bin/gsd-tools.test.cjs"
      provides: "Tests for init command environment injection"
      contains: "Tools:"
  key_links:
    - from: "bin/gsd-tools.cjs cmdInitProgress"
      to: ".planning/env-manifest.json"
      via: "readEnvManifest helper"
      pattern: "env-manifest\\.json|env_summary"
    - from: "bin/gsd-tools.cjs cmdInitExecutePhase"
      to: ".planning/env-manifest.json"
      via: "readEnvManifest helper"
      pattern: "env-manifest\\.json|env_summary"
---

<objective>
Integrate environment detection into init commands so agents automatically receive project environment context.

Purpose: The detection engine and manifest are useless unless agents actually see the data. This plan wires the manifest into the init commands that agents consume at workflow start, plus adds auto-trigger for first-run experience.
Output: `init progress`, `init execute-phase`, and other relevant init commands include a compact "Tools:" environment summary. First-run auto-triggers scan.
</objective>

<execution_context>
@/home/cam/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/cam/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/18-environment-awareness/18-CONTEXT.md
@.planning/phases/18-environment-awareness/18-01-SUMMARY.md
@.planning/phases/18-environment-awareness/18-02-SUMMARY.md
@.planning/codebase/CONVENTIONS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create environment summary helper and wire into init commands</name>
  <files>bin/gsd-tools.cjs</files>
  <action>
**1. Create `readEnvManifest(cwd)` helper function:**

Place near other helper functions (after loadConfig or similar). This reads and parses the manifest:
```javascript
function readEnvManifest(cwd) {
  const manifestPath = path.join(cwd, '.planning', 'env-manifest.json');
  const content = safeReadFile(manifestPath);
  if (!content) return null;
  try { return JSON.parse(content); } catch { return null; }
}
```

**2. Create `formatEnvSummary(manifest)` helper function:**

Produces the compact "Tools:" line for agent context:
```javascript
function formatEnvSummary(manifest) {
  if (!manifest || !manifest.languages || manifest.languages.length === 0) return null;
  
  const parts = [];
  for (const lang of manifest.languages) {
    if (lang.binary && lang.binary.available && lang.binary.version) {
      parts.push(`${lang.name}@${lang.binary.version}`);
    } else if (lang.binary && lang.binary.available) {
      parts.push(lang.name);
    } else {
      parts.push(`${lang.name} (no binary)`);
    }
  }
  
  // Add package manager
  if (manifest.package_manager && manifest.package_manager.name) {
    const pm = manifest.package_manager;
    const pmStr = pm.version ? `${pm.name}@${pm.version}` : pm.name;
    // Only add if not already implied by a language entry
    if (!parts.some(p => p.startsWith(pm.name))) {
      parts.push(pmStr);
    }
  }
  
  // Add docker if detected
  if (manifest.infrastructure?.docker_services?.length > 0) {
    parts.push('docker');
  }
  
  return `Tools: ${parts.join(', ')}`;
}
```

The format should match the requirement: `"Tools: node@20 (npm), mix@1.16, go@1.21, docker@24"`

Include package manager in parentheses after the language if it's a language-specific PM:
- node@20.11 (pnpm) — PM in parens after the language
- mix@1.16 — mix IS the PM
- go@1.21 — go modules implied

Adjust `formatEnvSummary` to produce this format: group each language with its PM if applicable.

**3. Create `autoTriggerEnvScan(cwd)` function:**

Auto-triggers scan on first init command if no manifest exists, or if manifest is stale:
```javascript
function autoTriggerEnvScan(cwd) {
  const planningDir = path.join(cwd, '.planning');
  if (!fs.existsSync(planningDir)) return null;  // Not a GSD project
  
  const manifest = readEnvManifest(cwd);
  if (!manifest) {
    // First run — trigger silent scan
    // Call the detection logic directly (not via CLI spawn)
    // Return the result
  }
  
  // Check staleness
  const staleness = checkEnvManifestStaleness(cwd);
  if (staleness.stale) {
    // Re-scan silently, return new result
    process.stderr.write('Environment changed, rescanning...\n');
  }
  
  return readEnvManifest(cwd);
}
```

Alternatively, extract the core scan logic from `cmdEnvScan` into an internal `runEnvScan(cwd)` function that both `cmdEnvScan` and `autoTriggerEnvScan` can call. This avoids spawning a child process.

**4. Wire into `cmdInitProgress`:**

Find `cmdInitProgress` (in the compound init commands section). Add to the returned JSON:
```javascript
const envManifest = autoTriggerEnvScan(cwd);
const envSummary = formatEnvSummary(envManifest);

// Add to the result object:
result.env_summary = envSummary;           // "Tools: node@20.11 (pnpm), mix@1.16, go@1.21"
result.env_languages = envManifest?.languages?.length || 0;
result.env_stale = false;                  // After auto-scan, it's fresh
```

**5. Wire into `cmdInitExecutePhase`:**

Same pattern — add `env_summary` to the returned JSON object.

**6. Wire into `cmdInitPlanPhase`:**

Per CONTEXT.md: "init progress and init execute commands include environment info; init phase-op does not."

So wire into:
- `cmdInitProgress` ✓
- `cmdInitExecutePhase` ✓  
- `cmdInitResume` (if it exists — good for session continuity)
- `cmdInitQuick` (ad-hoc tasks benefit from env context)

Do NOT wire into:
- `cmdInitPhaseOp` (per CONTEXT.md decision)
- `cmdInitNewProject` (project is being created, no env yet)
- `cmdInitNewMilestone` (planning, not execution)

**7. Performance consideration:**

The auto-trigger scan must not slow down init commands noticeably. If manifest exists and is fresh, this should add <5ms (just a file read + parse). If scan is triggered, the file detection pass is <10ms, but binary checks may add 1-3 seconds per binary. 

For auto-triggered scans during init: skip binary version checks (use cached versions from existing manifest if available, or mark as "unchecked"). Only `env scan` explicit invocation should run full binary checks. This ensures init commands stay fast.

Implement a `runEnvScan(cwd, { skipBinaryVersions: true })` option for the fast path.
  </action>
  <verify>
Run: `node bin/gsd-tools.cjs init progress --raw 2>/dev/null | node -e "const d=JSON.parse(require('fs').readFileSync('/dev/stdin','utf8')); console.log('env_summary:', d.env_summary)"` — should show a Tools: line or null.
Run: `node bin/gsd-tools.cjs env scan --force` first, then run init progress — should definitely show env_summary.
  </verify>
  <done>
`init progress --raw` and `init execute-phase` JSON output includes `env_summary` field with compact "Tools: ..." format. Missing manifest causes graceful null (no error). First init auto-triggers scan if no manifest exists. Init commands add <5ms overhead when manifest is fresh.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for integration and update CLI help</name>
  <files>bin/gsd-tools.cjs, bin/gsd-tools.test.cjs</files>
  <action>
**1. Integration tests in bin/gsd-tools.test.cjs:**

Add test suite `describe('env integration', ...)`:

- Test `formatEnvSummary` with a mock manifest containing node, go, elixir → produces correct compact format
- Test `formatEnvSummary` with null manifest → returns null
- Test `formatEnvSummary` with empty languages → returns null
- Test `formatEnvSummary` with missing binary → includes "(no binary)" suffix
- Test `readEnvManifest` with valid JSON file → parses correctly
- Test `readEnvManifest` with missing file → returns null
- Test `readEnvManifest` with invalid JSON → returns null
- Test that `autoTriggerEnvScan` creates manifest on first run (using temp dir with .planning/)
- Test that `autoTriggerEnvScan` returns existing manifest when fresh
- Test `env status` command returns correct JSON structure
- Integration test: create temp project with package.json + go.mod, run `env scan`, verify manifest exists, then run `env status` and verify not stale

**2. Update CLI header documentation:**

Update the header comment in `bin/gsd-tools.cjs` (lines 3-123) to include the new commands:
```
env scan [--raw] [--force] [--verbose]    Detect project languages, tools, and runtimes
env status [--raw]                        Check environment manifest freshness
```

**3. Update main() router comments:**

Add `env` to the top-level command list comment if one exists.

**4. Run full test suite:**

Ensure ALL existing tests still pass — no regressions from the init command changes.
  </action>
  <verify>
Run: `node --test bin/gsd-tools.test.cjs 2>&1 | tail -10` — all tests pass.
Run: `node --test bin/gsd-tools.test.cjs --test-name-pattern="env" 2>&1` — all env-related tests pass.
Run: `node bin/gsd-tools.cjs env scan --raw 2>/dev/null | node -e "JSON.parse(require('fs').readFileSync('/dev/stdin','utf8')); console.log('valid JSON')"` — confirms valid output.
Run: `node bin/gsd-tools.cjs env status --raw 2>/dev/null | node -e "JSON.parse(require('fs').readFileSync('/dev/stdin','utf8')); console.log('valid JSON')"` — confirms valid output.
  </verify>
  <done>
Full test suite passes with new env integration tests. CLI help updated with `env scan` and `env status` commands. `formatEnvSummary` produces correct compact format. `autoTriggerEnvScan` creates manifest on first run. No regressions in existing tests.
  </done>
</task>

</tasks>

<verification>
1. `init progress --raw` includes `env_summary` field when manifest exists
2. `init execute-phase --raw` includes `env_summary` field when manifest exists
3. Missing manifest → `env_summary` is null (no error, no crash)
4. First `init progress` on a project with no manifest auto-triggers scan
5. Compact format matches spec: "Tools: node@20.11 (pnpm), mix@1.16, go@1.21"
6. `env scan --force` followed by `init progress` → Tools line present
7. `env status` reports freshness correctly
8. All tests pass (no regressions)
9. CLI help includes env commands
</verification>

<success_criteria>
Init commands seamlessly inject environment context for agents. The workflow is: first time an init command runs → auto-scan → manifest written → subsequent inits read manifest in <5ms. When project files change → staleness detected → auto-rescan → fresh data injected. Agents see "Tools: node@20.11 (pnpm), mix@1.16, go@1.21" in their context without any manual setup.
</success_criteria>

<output>
After completion, create `.planning/phases/18-environment-awareness/18-03-SUMMARY.md`
</output>
