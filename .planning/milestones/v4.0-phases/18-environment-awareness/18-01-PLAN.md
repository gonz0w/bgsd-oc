---
phase: 18-environment-awareness
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/gsd-tools.cjs
  - bin/gsd-tools.test.cjs
autonomous: true
requirements:
  - ENV-01
  - ENV-02
  - ENV-03

must_haves:
  truths:
    - "cmdEnvScan detects Node.js from package.json in a project root"
    - "cmdEnvScan detects Go from go.mod in a project root"
    - "cmdEnvScan detects Elixir from mix.exs in a project root"
    - "cmdEnvScan detects at least 15 manifest file patterns"
    - "cmdEnvScan identifies primary language from root manifest presence"
    - "cmdEnvScan detects package manager from lockfile with correct precedence"
    - "cmdEnvScan respects packageManager field in package.json over lockfile detection"
    - "cmdEnvScan checks binary availability with which and captures version output"
    - "cmdEnvScan reports detected language with binary marked missing when binary not on PATH"
    - "Binary version checks have 3-second timeout"
  artifacts:
    - path: "bin/gsd-tools.cjs"
      provides: "cmdEnvScan function with detection engine"
      contains: "function cmdEnvScan"
    - path: "bin/gsd-tools.test.cjs"
      provides: "Test cases for environment scanning"
      contains: "env scan"
  key_links:
    - from: "bin/gsd-tools.cjs cmdEnvScan"
      to: "fs.existsSync checks"
      via: "manifest file pattern array"
      pattern: "MANIFEST_PATTERNS|manifestPatterns"
    - from: "bin/gsd-tools.cjs cmdEnvScan"
      to: "child_process.execSync"
      via: "binary version checks"
      pattern: "execSync.*--version"
---

<objective>
Build the core environment detection engine that scans a project for languages, package managers, and binary availability.

Purpose: This is the foundation for all environment awareness — the detection logic that everything else depends on. Without accurate detection, the manifest and injection are useless.
Output: `cmdEnvScan()` function in `bin/gsd-tools.cjs` that detects languages, package managers, and binary versions, plus comprehensive tests.
</objective>

<execution_context>
@__OPENCODE_CONFIG__/get-shit-done/workflows/execute-plan.md
@__OPENCODE_CONFIG__/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/18-environment-awareness/18-CONTEXT.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/ARCHITECTURE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build manifest detection and language scanner</name>
  <files>bin/gsd-tools.cjs</files>
  <action>
Create `cmdEnvScan(cwd, args, raw)` function in the Extended Features section of gsd-tools.cjs (after the existing feature commands, before main()).

The function must:

**1. Manifest file detection (fast path — file existence only, must complete in <10ms):**

Define a `LANG_MANIFESTS` array of objects, each with:
- `file`: filename to look for (e.g., `'package.json'`, `'go.mod'`, `'mix.exs'`)
- `language`: language name (e.g., `'node'`, `'go'`, `'elixir'`)
- `binary`: binary to check (e.g., `'node'`, `'go'`, `'mix'`)
- `versionFlag`: how to get version (e.g., `'--version'`, `'version'`)

Cover at minimum these 15+ patterns:
- `package.json` → node (binary: `node`)
- `go.mod` → go (binary: `go`)
- `mix.exs` → elixir (binary: `mix` and `elixir`)
- `Cargo.toml` → rust (binary: `cargo`)
- `pyproject.toml` → python (binary: `python3` or `python`)
- `setup.py` → python
- `requirements.txt` → python
- `Gemfile` → ruby (binary: `ruby`)
- `composer.json` → php (binary: `php`)
- `build.gradle` / `build.gradle.kts` → java/kotlin (binary: `java`)
- `pom.xml` → java (binary: `java`)
- `Package.swift` → swift (binary: `swift`)
- `CMakeLists.txt` → c/cpp (binary: `gcc` or `cc`)
- `Makefile` → make (binary: `make`)
- `Justfile` → just (binary: `just`)
- `Dockerfile` / `docker-compose.yml` / `docker-compose.yaml` / `compose.yml` / `compose.yaml` → docker (binary: `docker`)
- `flake.nix` → nix (binary: `nix`)
- `deno.json` / `deno.jsonc` → deno (binary: `deno`)
- `bun.lockb` / `bunfig.toml` → bun (binary: `bun`)

Scan with depth limit of 3 levels using `fs.readdirSync` (not shell `find`). Skip directories named: `node_modules`, `vendor`, `deps`, `_build`, `.git`, `.next`, `target`, `dist`, `build`, `__pycache__`, `.elixir_ls`, `.cache`.

For each detected manifest, record `{ language, file, path (relative), depth }`.

**2. Primary language determination:**
- Root manifest (depth 0) gets highest priority
- If multiple root manifests, use this precedence: the language whose manifest is the "main" project manifest (mix.exs > go.mod > package.json > Cargo.toml > pyproject.toml) based on which appears to be the primary application (has most files at root level, or is the only one with a lockfile)
- Simple heuristic: count manifest files per language across all depths; primary = language with most manifests at depth 0, tiebreaker = most total manifests

**3. Package manager detection (ENV-02):**

Define `PM_LOCKFILES` with precedence order (first match wins):
- `bun.lock` or `bun.lockb` → bun
- `pnpm-lock.yaml` → pnpm
- `yarn.lock` → yarn
- `package-lock.json` → npm

Then check for `packageManager` field in root `package.json` — if present, it overrides lockfile detection. Parse the value (e.g., `"pnpm@8.15.1"`) to extract name and version.

For non-Node projects: `mix.lock` → mix, `go.sum` → go modules, `Cargo.lock` → cargo, `Gemfile.lock` → bundler, `poetry.lock` → poetry, `Pipfile.lock` → pipenv.

**4. Binary availability checking (ENV-03):**

For each unique binary from detected languages:
- Run `which <binary>` via `execSync` with 3-second timeout, stdio: 'pipe'
- If found: run `<binary> <versionFlag>` with 3-second timeout, capture stdout
- Parse version from output (extract first semver-like pattern: `/(\d+\.\d+[\.\d]*)/`)
- If binary not found: mark `{ available: false, version: null, path: null }`
- If binary found but version check fails: mark `{ available: true, version: null, path: whichOutput }`

Wrap each binary check in try-catch — timeouts and errors should never crash the scan.

**5. Additional detection (per CONTEXT.md decisions):**

Detect version managers: check for `.tool-versions`, `mise.toml`, `.mise.toml`, `.nvmrc`, `.node-version`, `.python-version`, `.ruby-version`, `.go-version`. Record configured versions from these files.

Detect CI: check for `.github/workflows/` dir, `.gitlab-ci.yml`, `.circleci/`, `Jenkinsfile`, `.travis.yml`. Record CI platform name.

Detect test frameworks: look for jest.config.*, vitest.config.*, .mocharc.*, pytest.ini, setup.cfg [tool:pytest], tox.ini, test/ or tests/ or spec/ directories.

Detect linters/formatters: `.eslintrc*`, `.prettierrc*`, `biome.json`, `.credo.exs`, `.golangci.yml`, `rustfmt.toml`, `.rubocop.yml`.

Detect well-known scripts from package.json (test, build, lint, start, deploy, format, check), mix aliases (if mix.exs exists, try `mix help --names` with timeout), Makefile/Justfile targets (parse target names from file).

Detect infrastructure services from docker-compose files: parse `services:` keys, record service names only (no connection details per CONTEXT.md decision).

Detect MCP servers: check for `.mcp.json`, parse server names from `mcpServers` key.

Detect monorepo/workspace: check package.json `workspaces` field, `pnpm-workspace.yaml`, go.work, mix.exs umbrella `apps_path`.

**6. Return structured result:**

The function should build and return a structured JSON object (don't write to disk yet — Plan 02 handles manifest output):

```javascript
output({
  languages: [{ name, primary, manifests: [{ file, path, depth }], binary: { available, version, path } }],
  package_manager: { name, version, source, detected_from },
  version_managers: [{ name, file, configured_versions: {} }],
  tools: { ci: { platform, config_file }, test_frameworks: [...], linters: [...], formatters: [...] },
  scripts: { test: '...', build: '...', ... },
  infrastructure: { docker_services: [...], mcp_servers: [...] },
  monorepo: { type, members: [...] } | null,
  detection_ms: elapsed,
  scanned_at: new Date().toISOString()
}, raw);
```

Add `--force` flag support (ignored for now, will be used by staleness in Plan 02).
Add `--json` flag as alias for `--raw`.

Follow existing conventions: `cwd` first param, `raw` last param, use `output()`/`error()` pattern, `const` for immutables, 2-space indent, single quotes.

Add routing in `main()` switch: `case 'env':` with subcommand `scan` → `cmdEnvScan(cwd, args, raw)`.
  </action>
  <verify>
Run: `node bin/gsd-tools.cjs env scan --raw` from the bgsd-oc project root.
Should produce valid JSON with at least `languages` containing `node` (from package.json — wait, bgsd-oc has no package.json, but it has the plugin's own structure).

Better test: Run against the bgsd-oc directory itself — should detect at minimum JavaScript from bin/gsd-tools.cjs presence, and possibly Makefile/Justfile if present. Or test against a known polyglot project directory.

Run: `node bin/gsd-tools.cjs env scan --raw 2>/dev/null | node -e "const d=JSON.parse(require('fs').readFileSync('/dev/stdin','utf8')); console.log('languages:', d.languages?.length, 'detection_ms:', d.detection_ms)"` — should show language count and fast detection time.
  </verify>
  <done>
`cmdEnvScan` exists and returns structured JSON with languages, package_manager, tools, scripts, infrastructure, and monorepo detection. Detection of file patterns completes in <10ms for file existence checks. Binary checks have 3-second timeouts. At least 15 manifest patterns are defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive tests for detection engine</name>
  <files>bin/gsd-tools.test.cjs</files>
  <action>
Add a new `describe('env scan', ...)` test suite to `bin/gsd-tools.test.cjs`.

Tests must cover:

**1. Manifest pattern completeness:**
- Test that LANG_MANIFESTS (or equivalent) contains at least 15 entries
- Test that each entry has required fields (file, language, binary)

**2. Language detection (using temp directories with mock files):**
- Create temp dir with `package.json` → detects node
- Create temp dir with `go.mod` → detects go  
- Create temp dir with `mix.exs` → detects elixir
- Create temp dir with `package.json` + `go.mod` + `mix.exs` → detects all three (polyglot)
- Create temp dir with nested `subdir/package.json` at depth 1 → detects node
- Create temp dir with deeply nested file at depth 4 → NOT detected (beyond depth 3 limit)
- Empty directory → returns empty languages array

**3. Primary language detection:**
- Single language → marked as primary
- Multiple languages at root → one marked primary based on heuristic

**4. Package manager detection:**
- Create temp dir with `pnpm-lock.yaml` → detects pnpm
- Create temp dir with `package-lock.json` → detects npm
- Create temp dir with `pnpm-lock.yaml` + `package-lock.json` → detects pnpm (precedence)
- Create temp dir with `package.json` containing `"packageManager": "pnpm@8.15.1"` + `package-lock.json` → detects pnpm (field overrides lockfile)

**5. Binary availability (mock-safe):**
- Test that binary check function handles missing binary gracefully (returns available: false)
- Test that binary check respects timeout (don't actually timeout, but verify the option is set)

**6. Skip directories:**
- Create temp dir with `node_modules/some-package/package.json` → NOT detected
- Create temp dir with `vendor/package/go.mod` → NOT detected

**7. Version manager detection:**
- Create temp dir with `.nvmrc` containing `20.11.0` → detected with version
- Create temp dir with `mise.toml` → detected

**8. Infrastructure detection:**
- Create temp dir with `docker-compose.yml` containing `services: postgres: ...` → detects postgres service
- Create temp dir with `.mcp.json` containing `{ "mcpServers": { "github": {} } }` → detects github MCP server

**9. Script detection:**
- Create temp dir with `package.json` containing `"scripts": { "test": "jest", "build": "tsc" }` → captures test and build scripts

**10. Edge cases:**
- Permission-denied directory → doesn't crash
- Symlink loops → doesn't infinite loop (depth limit handles this)

Use `beforeEach`/`afterEach` with `fs.mkdtempSync`/recursive cleanup pattern already established in the test file.

Each test should call `cmdEnvScan` directly (import/require the function) or use `execSync('node bin/gsd-tools.cjs env scan --raw', { cwd: tmpDir })` to test via CLI.

Follow existing test conventions: `describe`/`test` from `node:test`, `assert` from `node:assert`, descriptive test names.
  </action>
  <verify>
Run: `node --test bin/gsd-tools.test.cjs 2>&1 | tail -5` — all tests should pass including new env scan tests.
Run: `node --test bin/gsd-tools.test.cjs --test-name-pattern="env scan" 2>&1` — specifically verify env scan tests pass.
  </verify>
  <done>
Test suite includes at least 10 test cases covering language detection, package manager detection, binary checks, skip directories, version managers, infrastructure detection, and edge cases. All tests pass with `node --test bin/gsd-tools.test.cjs`.
  </done>
</task>

</tasks>

<verification>
1. `node bin/gsd-tools.cjs env scan --raw` produces valid JSON output
2. Detection covers 15+ manifest patterns (count entries in LANG_MANIFESTS array)
3. Package manager precedence correct: bun > pnpm > yarn > npm
4. packageManager field overrides lockfile detection
5. Binary checks have 3-second timeout and don't crash on missing binaries
6. All existing tests still pass (no regressions)
7. New env scan tests all pass
</verification>

<success_criteria>
Running `env scan` on a project directory produces a structured JSON object listing detected languages with binary availability, package manager with source attribution, and version manager/CI/test/linter/infrastructure/script detection. Binary checks timeout gracefully at 3 seconds. Detection of file patterns completes in <10ms.
</success_criteria>

<output>
After completion, create `.planning/phases/18-environment-awareness/18-01-SUMMARY.md`
</output>
