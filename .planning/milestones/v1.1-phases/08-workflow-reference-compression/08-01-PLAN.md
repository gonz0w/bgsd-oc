---
phase: 08-workflow-reference-compression
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/commands/features.js
  - src/router.js
  - src/lib/constants.js
  - bin/gsd-tools.test.cjs
  - references/checkpoints.md
  - references/verification-patterns.md
  - references/continuation-format.md
autonomous: true
requirements: [WKFL-01, WKFL-02]

must_haves:
  truths:
    - "CLI command extracts specific markdown sections by header name from any file"
    - "Large reference files are split into independently loadable sections"
    - "Agents can load only the checkpoint type they need instead of all 776 lines"
  artifacts:
    - path: "src/commands/features.js"
      provides: "extractSections command implementation"
      contains: "cmdExtractSections"
    - path: "src/router.js"
      provides: "extract-sections command routing"
      contains: "extract-sections"
    - path: "references/checkpoints.md"
      provides: "Section-marked checkpoint reference (unchanged content, added section markers)"
      contains: "<!-- section:"
  key_links:
    - from: "src/router.js"
      to: "src/commands/features.js"
      via: "command dispatch"
      pattern: "extract-sections.*cmdExtractSections"
    - from: "src/commands/features.js"
      to: "references/checkpoints.md"
      via: "file read + section extraction"
      pattern: "extractSectionsFromFile"
---

<objective>
Build the `extract-sections` CLI command and add section markers to large reference files, enabling selective section loading.

Purpose: Provides the infrastructure (WKFL-02) for agents to load only the markdown sections they need from large files, and restructures the three largest reference files (WKFL-01) so they're section-addressable. This is the foundation that Plan 02 and Plan 03 build on.

Output: Working `extract-sections` command, section-marked reference files, tests proving extraction works.
</objective>

<execution_context>
@__OPENCODE_CONFIG__/get-shit-done/workflows/execute-plan.md
@__OPENCODE_CONFIG__/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/07-init-command-compaction/07-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement extract-sections CLI command</name>
  <files>src/commands/features.js, src/router.js, src/lib/constants.js</files>
  <action>
Create `cmdExtractSections(cwd, args, raw)` in `src/commands/features.js` (the extended features file, after existing commands).

**Command signature:** `extract-sections <file-path> <section1> [section2] [section3] ...`

**Implementation:**
1. Read the file at `<file-path>` (resolve relative to cwd)
2. Parse markdown headers (## and ### levels) to identify sections. Each section starts at a header line and ends at the next header of equal or higher level (or EOF).
3. Also support `<!-- section: name -->` markers as section boundaries (for files that need sections within non-header content)
4. For each requested section name, find the matching section (case-insensitive header text match, with or without markdown `##` prefix)
5. Return JSON: `{ file, sections_found: [...], sections_missing: [...], content: "concatenated section text" }`
6. If no sections requested (just file path), return list of available sections: `{ file, available_sections: [...] }`

**Helper function:** Create `extractSectionsFromFile(filePath, sectionNames)` as an internal helper (exportable) since Plan 02 workflows will reference sections by name.

**Error handling:**
- File not found → `error("File not found: <path>")`
- No sections requested → return available sections list (discovery mode)
- Some sections missing → return what was found plus `sections_missing` array (don't error)

**Add to router:** In `src/router.js`, add `case 'extract-sections':` routing to `cmdExtractSections`.

**Add to help:** In `src/lib/constants.js`, add help entry for `extract-sections` in the COMMAND_HELP map.

**Important:** Follow the existing patterns in features.js — use `safeReadFile()` for file reading, `output()` for JSON output, `error()` for fatal errors. Match the code style of `cmdContextBudget` or `cmdSearchDecisions`.
  </action>
  <verify>
Run these commands and verify output:
```bash
# Discovery mode — list sections
node bin/gsd-tools.cjs extract-sections references/checkpoints.md --raw

# Extract specific section
node bin/gsd-tools.cjs extract-sections references/checkpoints.md "Checkpoint Types" --raw

# Extract multiple sections
node bin/gsd-tools.cjs extract-sections references/checkpoints.md "Checkpoint Types" "Writing Guidelines" --raw

# Missing section handling
node bin/gsd-tools.cjs extract-sections references/checkpoints.md "NonexistentSection" --raw

# Help text
node bin/gsd-tools.cjs extract-sections --help
```

Then run `npm test` to ensure no regressions.
  </verify>
  <done>
`extract-sections` command works in both discovery and extraction mode. Extracts correct section content from any markdown file by header name. Returns JSON with sections_found/sections_missing. Help text registered.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add section markers to large reference files + tests</name>
  <files>references/checkpoints.md, references/verification-patterns.md, references/continuation-format.md, bin/gsd-tools.test.cjs</files>
  <action>
**Part A: Add section markers to the three largest reference files**

These files are loaded by workflows via `@` references but agents rarely need ALL content. Add `<!-- section: name -->` / `<!-- /section -->` markers to create independently addressable sections.

**references/checkpoints.md** (776 lines — loaded by execute-phase.md, execute-plan.md):
Add section markers around these logical groups:
- `<!-- section: types -->` — The three checkpoint types (human-verify, decision, human-action) with their XML templates
- `<!-- section: guidelines -->` — Writing guidelines, anti-patterns, best practices
- `<!-- section: authentication -->` — Authentication gates section

Goal: An agent executing a plan with NO checkpoints should skip this file entirely. An agent with a `checkpoint:human-verify` should load only the `types` section (~200 lines instead of 776).

**references/verification-patterns.md** (612 lines — loaded by verify-phase.md):
Add section markers:
- `<!-- section: must-haves -->` — Must-haves verification methodology
- `<!-- section: artifact-verification -->` — Artifact existence/content checks
- `<!-- section: key-links -->` — Key link verification patterns
- `<!-- section: report-format -->` — Report writing format

**references/continuation-format.md** (249 lines — loaded by resume-project.md):
Add section markers:
- `<!-- section: format -->` — The continuation format spec
- `<!-- section: examples -->` — Usage examples

**CRITICAL: Do NOT change any existing content.** Only ADD section markers as HTML comments at the appropriate boundaries. Every line of existing content must be preserved exactly.

**Part B: Write tests**

Add tests in `bin/gsd-tools.test.cjs`:

1. `extract-sections lists available sections from markdown file` — Create a temp file with ## headers, verify discovery mode returns section names
2. `extract-sections extracts specific section by header name` — Verify content extraction matches expected text
3. `extract-sections handles section markers (HTML comments)` — Create temp file with `<!-- section: name -->` markers, verify extraction works
4. `extract-sections returns sections_missing for unknown sections` — Verify graceful handling
5. `extract-sections handles multiple section extraction` — Verify concatenation of multiple sections
6. `extract-sections works on real reference files` — Run against `references/checkpoints.md` and verify `types` section is extractable and shorter than full file

Follow the existing test patterns in the test file — use `describe`/`test` blocks, `beforeEach`/`afterEach` for temp file cleanup.
  </action>
  <verify>
```bash
# Verify section markers don't break existing content
wc -l references/checkpoints.md  # Should be slightly MORE than 776 (added markers)
wc -l references/verification-patterns.md  # Should be slightly MORE than 612

# Verify extraction works with markers
node bin/gsd-tools.cjs extract-sections references/checkpoints.md --raw | python3 -c "import json,sys; d=json.load(sys.stdin); print(f'Sections: {d[\"available_sections\"]}')"

# Extract just types section
node bin/gsd-tools.cjs extract-sections references/checkpoints.md "types" --raw | python3 -c "import json,sys; d=json.load(sys.stdin); lines=d['content'].count(chr(10)); print(f'types section: {lines} lines (vs 776 total)')"

# Run all tests
npm test
```
  </verify>
  <done>
Three largest reference files have section markers. `extract-sections` command can extract individual sections. Tests pass covering discovery, extraction, markers, missing sections, and real file validation. Existing content is byte-identical (only markers added).
  </done>
</task>

</tasks>

<verification>
- [ ] `extract-sections` command registered and routable
- [ ] Discovery mode lists sections from any markdown file
- [ ] Extraction mode returns correct section content
- [ ] Section markers added to checkpoints.md, verification-patterns.md, continuation-format.md
- [ ] Markers don't alter existing content
- [ ] `npm test` passes with new tests
- [ ] `npm run build` succeeds
</verification>

<success_criteria>
- `extract-sections references/checkpoints.md "types" --raw` returns only the checkpoint types section (~200 lines, not 776)
- `extract-sections` works with both `##` markdown headers and `<!-- section: name -->` HTML comment markers
- All 3 large reference files have section markers at logical boundaries
- 6+ new tests pass
- No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/08-workflow-reference-compression/08-01-SUMMARY.md`
</output>
