---
phase: 38-ast-intelligence-repo-map
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/ast.js
  - src/commands/codebase.js
  - src/router.js
  - src/lib/constants.js
  - bin/gsd-tools.test.cjs
  - package.json
autonomous: true
requirements: [AST-01, AST-02, AST-04]

must_haves:
  truths:
    - "codebase ast <file> returns function/class signatures for any JS/TS file"
    - "codebase exports <file> returns export surface (named exports, default export, re-exports)"
    - "Non-JS files (Python, Go, Rust, etc.) get regex-based signature extraction without errors"
    - "Malformed files produce graceful fallback, not crashes"
  artifacts:
    - path: "src/lib/ast.js"
      provides: "AST parsing engine with acorn + regex fallback registry"
      exports: ["extractSignatures", "extractExports", "DETECTOR_REGISTRY"]
    - path: "src/commands/codebase.js"
      provides: "CLI formatters for ast and exports subcommands"
    - path: "src/router.js"
      provides: "Routing for codebase ast and codebase exports"
  key_links:
    - from: "src/router.js"
      to: "src/commands/codebase.js"
      via: "lazyCodebase().cmdCodebaseAst / cmdCodebaseExports"
      pattern: "cmdCodebaseAst|cmdCodebaseExports"
    - from: "src/commands/codebase.js"
      to: "src/lib/ast.js"
      via: "require('../lib/ast')"
      pattern: "extractSignatures|extractExports"
    - from: "src/lib/ast.js"
      to: "acorn"
      via: "require('acorn')"
      pattern: "acorn\\.parse"
---

<objective>
Create the AST intelligence foundation: acorn-based JS/TS signature and export extraction, plus a regex-based detector registry for other languages, wired as `codebase ast` and `codebase exports` CLI commands.

Purpose: Agents need compact code intelligence (function signatures, export surfaces) instead of reading full file contents — this is the extraction engine.
Output: src/lib/ast.js module, two new codebase subcommands, tests
</objective>

<execution_context>
@/home/cam/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/cam/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/codebase-intel.js
@src/commands/codebase.js
@src/router.js
@src/lib/constants.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: AST parser module with acorn + regex fallback registry</name>
  <files>src/lib/ast.js, package.json</files>
  <action>
Install acorn as a production dependency: `npm install acorn` (it will be bundled into gsd-tools.cjs by esbuild).

Create `src/lib/ast.js` with these exports:

**`extractSignatures(filePath, options?)`** — Returns array of signature objects:
```js
{ name: string, type: 'function'|'class'|'method'|'arrow', params: string[], line: number, async: boolean, generator: boolean }
```

For JS/CJS/MJS files: Use `acorn.parse(code, { ecmaVersion: 'latest', sourceType: 'module', allowReturnOutsideFunction: true, allowImportExportEverywhere: true })` with try/catch fallback to `sourceType: 'script'`. Walk AST nodes:
- `FunctionDeclaration` → extract name, params, async, generator
- `ClassDeclaration` → extract name, then walk body for `MethodDefinition` nodes
- `VariableDeclaration` → check init for `ArrowFunctionExpression` or `FunctionExpression`
- `ExpressionStatement` with `AssignmentExpression` where right is function → `module.exports.foo = function()`

For TS/TSX/JSX files: Strip TypeScript type annotations with regex before parsing with acorn:
- Remove `<T>` generic params, `: Type` annotations, `interface/type` declarations, `as Type` casts
- Then parse stripped code with acorn (same logic as JS)
- If acorn still fails after stripping, fall back to regex extraction

**`extractExports(filePath)`** — Returns export surface object:
```js
{
  named: string[],         // Named exports: export function foo, export const bar
  default: string|null,    // Default export identifier or 'anonymous'
  reExports: string[],     // Re-exports: export { foo } from './bar'
  cjsExports: string[],   // CJS: module.exports.foo, exports.foo
  type: 'esm'|'cjs'|'mixed'
}
```

For ESM: Walk AST for `ExportNamedDeclaration`, `ExportDefaultDeclaration`, `ExportAllDeclaration`.
For CJS: Regex scan for `module.exports =`, `module.exports.X =`, `exports.X =` patterns.

**`DETECTOR_REGISTRY`** — Map of language → regex-based extractor for non-JS files:
```js
{
  python: { signatures: /^(async\s+)?def\s+(\w+)\s*\(([^)]*)\)/gm, exports: /^(\w+)\s*=|^class\s+(\w+)/gm },
  go: { signatures: /^func\s+(\([\w\s*]+\)\s+)?(\w+)\s*\(([^)]*)\)/gm },
  rust: { signatures: /^(pub\s+)?(async\s+)?fn\s+(\w+)\s*(<[^>]*>)?\s*\(([^)]*)\)/gm },
  ruby: { signatures: /^\s*def\s+(\w+[?!=]?)\s*(\([^)]*\))?/gm },
  elixir: { signatures: /^\s*def[p]?\s+(\w+)\s*(\([^)]*\))?/gm },
  java: { signatures: /^\s*(public|private|protected)?\s*(static)?\s*[\w<>\[\]]+\s+(\w+)\s*\(([^)]*)\)/gm },
  php: { signatures: /^\s*(public|private|protected)?\s*(static)?\s*function\s+(\w+)\s*\(([^)]*)\)/gm },
}
```

Each regex extractor returns the same `{ name, type, params, line }` shape. Use `LANGUAGE_MAP` from codebase-intel.js to map file extensions → language → detector.

**Error handling:** Wrap all parsing in try/catch. If acorn fails AND regex fallback fails, return `{ signatures: [], error: 'parse_failed' }`. Never throw.
  </action>
  <verify>
`npm run build` succeeds (acorn gets bundled). `npm test` passes with zero regressions on existing 599 tests.
  </verify>
  <done>
src/lib/ast.js exists with extractSignatures, extractExports, DETECTOR_REGISTRY exports. Acorn parses JS files into signature arrays. Regex fallback handles Python/Go/Rust/Ruby/Elixir/Java/PHP. Malformed files return empty results, not errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire codebase ast/exports CLI commands + tests</name>
  <files>src/commands/codebase.js, src/router.js, src/lib/constants.js, bin/gsd-tools.test.cjs</files>
  <action>
**In src/commands/codebase.js**, add two new command handlers:

`cmdCodebaseAst(cwd, args, raw)`:
- Parse args for file path (required, first positional arg)
- Call `extractSignatures(filePath)` from ast.js
- If `--raw`: output JSON `{ file, language, signatures: [...], count }`
- If formatted: Use `banner('AST Signatures')`, then table of signatures with columns: Name, Type, Params, Line

`cmdCodebaseExports(cwd, args, raw)`:
- Parse args for file path (required, first positional arg)
- Call `extractExports(filePath)` from ast.js
- If `--raw`: output JSON `{ file, type, named: [...], default, re_exports: [...], cjs_exports: [...] }`
- If formatted: Use `banner('Export Surface')`, show module type (ESM/CJS/mixed), list exports by category

Export both new functions from the module.

**In src/router.js**, add routing in the `case 'codebase'` block:
```js
} else if (sub === 'ast') {
  lazyCodebase().cmdCodebaseAst(cwd, args.slice(2), raw);
} else if (sub === 'exports') {
  lazyCodebase().cmdCodebaseExports(cwd, args.slice(2), raw);
}
```
Update the error usage string to include `ast|exports`.

**In src/lib/constants.js**, add COMMAND_HELP entries for the new subcommands.

**Tests in bin/gsd-tools.test.cjs** (8-10 new tests):
1. `codebase ast` on a JS file with functions → returns signatures
2. `codebase ast` on a JS file with classes → returns class + method signatures
3. `codebase ast` on a CJS file with module.exports → returns signatures
4. `codebase ast` on a non-existent file → returns error gracefully
5. `codebase exports` on an ESM file → returns named/default exports
6. `codebase exports` on a CJS file → returns cjs_exports
7. `codebase ast` on a Python file → regex fallback returns signatures
8. `codebase ast` on an unknown extension → returns empty signatures, no crash

Create test fixture files in the test using `fs.writeFileSync` in test setup (not permanent fixtures).

Run `npm run build && npm test` to verify all tests pass.
  </action>
  <verify>
`npm run build && npm test` — all tests pass (existing 599 + ~8-10 new). Manual check: `node bin/gsd-tools.cjs codebase ast src/lib/ast.js --raw` returns JSON with signatures.
  </verify>
  <done>
`codebase ast <file>` and `codebase exports <file>` work via CLI with both raw JSON and formatted output. Tests cover JS, CJS, class, ESM exports, CJS exports, Python regex fallback, and error cases. Build succeeds with acorn bundled.
  </done>
</task>

</tasks>

<verification>
- `node bin/gsd-tools.cjs codebase ast src/lib/ast.js --raw` → JSON with function signatures
- `node bin/gsd-tools.cjs codebase exports src/lib/ast.js --raw` → JSON with export surface
- `node bin/gsd-tools.cjs codebase ast some_python_file.py --raw` → regex-extracted signatures
- `npm test` passes with zero regressions
</verification>

<success_criteria>
- extractSignatures works on JS/TS via acorn and other languages via regex
- extractExports works for ESM and CJS modules
- Both CLI commands produce correct JSON and formatted output
- All tests pass including 8-10 new tests
</success_criteria>

<output>
After completion, create `.planning/phases/38-ast-intelligence-repo-map/38-01-SUMMARY.md`
</output>
