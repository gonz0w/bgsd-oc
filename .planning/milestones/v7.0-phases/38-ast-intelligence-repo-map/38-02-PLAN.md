---
phase: 38-ast-intelligence-repo-map
plan: 02
type: execute
wave: 2
depends_on: ["38-01"]
files_modified:
  - src/lib/ast.js
  - src/commands/codebase.js
  - src/router.js
  - src/lib/constants.js
  - bin/gsd-tools.test.cjs
autonomous: true
requirements: [AST-03, CTX-01]

must_haves:
  truths:
    - "codebase complexity <file> returns per-function complexity scores"
    - "codebase repo-map produces a compact ~1k token codebase summary"
    - "Repo map uses AST signatures, not full file contents"
    - "Complexity scores reflect branching density and nesting depth"
  artifacts:
    - path: "src/lib/ast.js"
      provides: "computeComplexity function added to existing AST module"
      exports: ["computeComplexity"]
    - path: "src/commands/codebase.js"
      provides: "CLI formatters for complexity and repo-map subcommands"
    - path: "src/router.js"
      provides: "Routing for codebase complexity and codebase repo-map"
  key_links:
    - from: "src/commands/codebase.js"
      to: "src/lib/ast.js"
      via: "computeComplexity, extractSignatures"
      pattern: "computeComplexity|extractSignatures"
    - from: "src/commands/codebase.js"
      to: "src/lib/codebase-intel.js"
      via: "walkSourceFiles for repo-map file discovery"
      pattern: "walkSourceFiles|getSourceDirs"
---

<objective>
Add per-function complexity scoring and a compact repository map generator that uses AST signatures to produce a ~1k token codebase summary for agent context injection.

Purpose: Agents need complexity scores for task classification and a compact repo map instead of reading every file. This completes the AST intelligence stack.
Output: Two new codebase subcommands (complexity, repo-map), tests
</objective>

<execution_context>
@/home/cam/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/cam/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/38-ast-intelligence-repo-map/38-01-SUMMARY.md
@src/lib/ast.js
@src/lib/codebase-intel.js
@src/commands/codebase.js
@src/router.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Complexity scoring + repo-map generator</name>
  <files>src/lib/ast.js, src/commands/codebase.js, src/router.js, src/lib/constants.js</files>
  <action>
**In src/lib/ast.js**, add:

`computeComplexity(filePath)` — Returns per-function complexity:
```js
{
  file: string,
  module_complexity: number,     // Sum of all function complexities
  functions: [
    { name: string, line: number, complexity: number, nesting_max: number }
  ]
}
```

Complexity calculation (simplified cyclomatic):
- Start at 1 for each function
- +1 for each: `IfStatement`, `ConditionalExpression` (ternary), `ForStatement`, `ForInStatement`, `ForOfStatement`, `WhileStatement`, `DoWhileStatement`, `SwitchCase` (non-default), `CatchClause`, `LogicalExpression` (&&, ||, ??)
- Track max nesting depth of control flow statements
- For non-JS files: regex count of branching keywords (`if`, `else if`, `for`, `while`, `switch`, `case`, `catch`, `&&`, `||`) as rough approximation

Use acorn to parse the full file, then walk each function body counting complexity nodes. Reuse the same parse result from extractSignatures if possible (parse once, walk twice).

`generateRepoMap(cwd, options?)` — Returns compact repo map string:
```js
{
  summary: string,          // The ~1k token compact text
  files_included: number,
  total_signatures: number,
  token_estimate: number    // Rough token count (chars/4)
}
```

Algorithm:
1. Use `getSourceDirs(cwd)` + `walkSourceFiles(cwd, ...)` from codebase-intel.js to find all source files
2. For each source file, call `extractSignatures(filePath)` and `extractExports(filePath)`
3. Build compact text format:
```
# Repo Map
## src/lib/ast.js (15 exports)
  fn extractSignatures(filePath, options) :12
  fn extractExports(filePath) :45
  fn computeComplexity(filePath) :89
  class Parser :102
    method parse(code) :105
    method walk(node) :120
  exports: extractSignatures, extractExports, computeComplexity, ...

## src/lib/config.js (3 exports)
  fn loadConfig(cwd) :8
  fn saveConfig(cwd, config) :25
  exports: loadConfig, saveConfig, DEFAULT_CONFIG
```
4. If total exceeds ~1200 tokens (4800 chars), prioritize: keep files with most exports/signatures, drop files with 0-1 signatures, truncate param lists
5. Sort files by signature count descending (most important files first)

**In src/commands/codebase.js**, add:

`cmdCodebaseComplexity(cwd, args, raw)`:
- Parse file path from args (required)
- Call `computeComplexity(filePath)`
- Raw: output JSON
- Formatted: banner + table with Name, Complexity, Max Nesting, Line columns. Color-code: green(1-5), yellow(6-10), red(11+)

`cmdCodebaseRepoMap(cwd, args, raw)`:
- No required args (operates on whole project)
- Optional `--budget <tokens>` to set token budget (default 1000)
- Call `generateRepoMap(cwd, { tokenBudget })`
- Raw: output JSON `{ summary, files_included, total_signatures, token_estimate }`
- Formatted: print the summary text directly (it IS the formatted output)

**In src/router.js**, add routing:
```js
} else if (sub === 'complexity') {
  lazyCodebase().cmdCodebaseComplexity(cwd, args.slice(2), raw);
} else if (sub === 'repo-map') {
  lazyCodebase().cmdCodebaseRepoMap(cwd, args.slice(2), raw);
}
```
Update error usage string to include `complexity|repo-map`.

**In src/lib/constants.js**, add COMMAND_HELP entries.
  </action>
  <verify>
`npm run build && npm test` — all tests pass. Manual: `node bin/gsd-tools.cjs codebase complexity src/lib/ast.js --raw` returns per-function scores. `node bin/gsd-tools.cjs codebase repo-map --raw` returns compact summary.
  </verify>
  <done>
computeComplexity returns per-function cyclomatic complexity with nesting depth. generateRepoMap produces compact ~1k token codebase summary from AST signatures. Both CLI commands work with raw and formatted output.
  </done>
</task>

<task type="auto">
  <name>Task 2: Tests for complexity and repo-map + build validation</name>
  <files>bin/gsd-tools.test.cjs</files>
  <action>
Add tests in bin/gsd-tools.test.cjs (8-10 new tests):

**Complexity tests:**
1. Simple function (no branching) → complexity 1
2. Function with if/else/for → complexity reflects branch count
3. Nested control flow → nesting_max reflects depth
4. Module complexity = sum of function complexities
5. Non-existent file → graceful error response

**Repo-map tests:**
6. Repo map on project root → returns summary string with file entries
7. Repo map token_estimate is roughly within budget
8. Repo map includes files with signatures, excludes binary/config files
9. Repo map --budget flag controls output size

**Integration:**
10. Run `codebase repo-map --raw` on the gsd-tools project itself → verify it produces valid JSON with files_included > 0

Create test fixture files with known complexity patterns using `fs.writeFileSync` in test setup.

Run `npm run build && npm test` to confirm all pass.
  </action>
  <verify>
`npm run build && npm test` — all tests pass (existing + ~18-20 new from both plans). `node bin/gsd-tools.cjs codebase repo-map` produces readable output.
  </verify>
  <done>
Full test coverage for complexity scoring (simple, branching, nested, error) and repo-map generation (output format, budget control, integration). All tests pass. Build succeeds.
  </done>
</task>

</tasks>

<verification>
- `node bin/gsd-tools.cjs codebase complexity src/router.js --raw` → per-function complexity JSON
- `node bin/gsd-tools.cjs codebase repo-map --raw` → compact summary with token estimate
- `node bin/gsd-tools.cjs codebase repo-map --budget 500 --raw` → shorter summary
- `npm test` passes all tests
</verification>

<success_criteria>
- Complexity scores correctly count branching and nesting for JS functions
- Repo map produces compact ~1k token summary from AST signatures
- Both CLI commands work in raw and formatted modes
- All tests pass including 8-10 new tests
</success_criteria>

<output>
After completion, create `.planning/phases/38-ast-intelligence-repo-map/38-02-SUMMARY.md`
</output>
