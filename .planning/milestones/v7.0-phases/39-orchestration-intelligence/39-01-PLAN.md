---
phase: 39-orchestration-intelligence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/orchestration.js
  - src/commands/init.js
  - src/router.js
  - src/lib/constants.js
  - bin/gsd-tools.test.cjs
autonomous: true
requirements: [ORCH-01, ORCH-02, ORCH-03]

must_haves:
  truths:
    - "Every plan task gets a 1-5 complexity score based on file count, cross-module reach, and test requirements"
    - "init execute-phase includes recommended agent type and model tier per task"
    - "Orchestrator auto-selects single vs parallel vs team mode from plan wave structure"
    - "Routing decisions are visible in CLI output for transparency"
  artifacts:
    - path: "src/lib/orchestration.js"
      provides: "Task complexity classifier, agent router, execution mode selector"
      exports: ["classifyTaskComplexity", "routeTask", "selectExecutionMode", "classifyPlan"]
    - path: "src/commands/init.js"
      provides: "Enhanced init execute-phase with task_routing field"
  key_links:
    - from: "src/commands/init.js"
      to: "src/lib/orchestration.js"
      via: "require for classifyPlan and selectExecutionMode"
      pattern: "classifyPlan|selectExecutionMode"
    - from: "src/lib/orchestration.js"
      to: "src/lib/frontmatter.js"
      via: "parseFrontmatter for plan metadata"
      pattern: "parseFrontmatter"
    - from: "src/lib/orchestration.js"
      to: "src/lib/deps.js"
      via: "dependency graph for cross-module reach"
      pattern: "buildDependencyGraph|readIntel"
---

<objective>
Create the orchestration intelligence engine: task complexity classification (1-5 score), agent/model routing recommendations, and execution mode auto-selection from plan structure. Wire into `init execute-phase` output so agents receive routing guidance.

Purpose: Agents currently get no guidance on task difficulty or optimal execution strategy. This adds automatic classification so the orchestrator routes work to the right agent/model without manual selection.
Output: src/lib/orchestration.js module, enhanced init execute-phase output, tests
</objective>

<execution_context>
@/home/cam/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/cam/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/commands/init.js (lines 140-340 — cmdInitExecutePhase)
@src/lib/helpers.js (findPhaseInternal, getPhaseTree)
@src/lib/frontmatter.js
@src/lib/deps.js
@src/lib/ast.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Orchestration intelligence module</name>
  <files>src/lib/orchestration.js</files>
  <action>
Create `src/lib/orchestration.js` with these exports:

**`classifyTaskComplexity(task, context)`** — Scores a single task 1-5:

Input `task` object (from parsed plan XML):
```js
{ name, type, files: string[], action: string, verify: string, done: string }
```

Input `context` object:
```js
{ cwd: string, depGraph?: object }  // depGraph from deps.js if available
```

Scoring algorithm (additive, clamped 1-5):
- **Base:** Start at 1
- **File count:** +1 if files.length >= 3, +2 if >= 6
- **Cross-module reach:** If depGraph available, count how many other modules import files in this task. +1 if >= 3 importers (high blast radius), +2 if >= 6
- **Test requirements:** +1 if action mentions "test" or verify contains test commands (npm test, pytest, etc.)
- **Checkpoint complexity:** +1 if type is checkpoint:decision or checkpoint:human-verify
- **Action length proxy:** +1 if action.length > 800 chars (indicates complex implementation)

Return:
```js
{
  score: number,          // 1-5
  label: string,          // "trivial" | "simple" | "moderate" | "complex" | "very_complex"
  factors: string[],      // ["3 files", "high blast radius (5 importers)", "has tests"]
  recommended_model: string,  // "haiku" | "sonnet" | "opus"
  recommended_agent: string   // "gsd-executor" | "gsd-executor" (always for now)
}
```

Model mapping: score 1-2 → "sonnet", score 3 → "sonnet", score 4-5 → "opus"
Label mapping: 1=trivial, 2=simple, 3=moderate, 4=complex, 5=very_complex

**`classifyPlan(planPath, cwd)`** — Classifies all tasks in a plan:

1. Read plan file, parse frontmatter with `parseFrontmatter`
2. Parse task XML blocks from plan body using regex (extract name, type, files, action, verify, done)
3. Try to load dependency graph from codebase-intel.json (non-blocking if missing)
4. Call classifyTaskComplexity for each task
5. Return:
```js
{
  plan: string,              // plan filename
  wave: number,
  autonomous: boolean,
  task_count: number,
  tasks: [{ name, complexity: { score, label, factors, recommended_model, recommended_agent } }],
  plan_complexity: number,   // max task score
  recommended_model: string  // highest recommended model across tasks
}
```

**`selectExecutionMode(planClassifications)`** — Determines execution strategy:

Input: array of classified plans (from classifyPlan)

Algorithm:
- Count total plans, waves, checkpoints
- If 1 plan with 1-2 tasks → mode: "single" (one agent, sequential)
- If multiple plans in same wave with no file overlaps → mode: "parallel" (concurrent agents)
- If any plan has checkpoint → mode: "sequential" (must pause for human)
- If plans span 3+ waves → mode: "pipeline" (wave-by-wave execution)

Return:
```js
{
  mode: string,            // "single" | "parallel" | "sequential" | "pipeline"
  reason: string,          // "2 independent plans in wave 1"
  waves: { [wave]: string[] },  // wave number → plan IDs
  total_plans: number,
  total_waves: number,
  has_checkpoints: boolean
}
```

**`routeTask(complexity, config)`** — Maps complexity to model using config profile:

Takes complexity object and config (with model_profile), returns the actual model name from the profile. Uses `resolveModelInternal` pattern. This is a thin wrapper that respects config overrides.

**Error handling:** All functions wrap in try/catch. If plan parsing fails, return null with debugLog. If dep graph unavailable, classify without cross-module reach (slightly lower scores). Never throw.

**Helper: `parseTasksFromPlan(content)`** — Regex parser for task XML blocks:
- Match task opening tags (with type attribute) through closing tags
- Extract name, files, action, verify, done elements from each block
- Return array of task objects
- Handle multi-line content in each element
  </action>
  <verify>
`npm run build` succeeds. Module exports are correct: `node -e "const o = require('./src/lib/orchestration'); console.log(Object.keys(o))"` shows all 5 exports.
  </verify>
  <done>
src/lib/orchestration.js exists with classifyTaskComplexity (1-5 scoring), classifyPlan (full plan classification), selectExecutionMode (single/parallel/sequential/pipeline), routeTask (model mapping), parseTasksFromPlan (XML parser). All handle errors gracefully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire into init execute-phase + CLI command + tests</name>
  <files>src/commands/init.js, src/router.js, src/lib/constants.js, bin/gsd-tools.test.cjs</files>
  <action>
**In src/commands/init.js — cmdInitExecutePhase:**

After the existing plan inventory section (~line 180), add orchestration intelligence:

```js
// Orchestration intelligence — classify tasks and recommend routing
try {
  const { classifyPlan, selectExecutionMode } = require('../lib/orchestration');
  const planClassifications = [];
  for (const planFile of (phaseInfo?.incomplete_plans || [])) {
    const planPath = path.join(cwd, phaseInfo.directory, planFile);
    const classification = classifyPlan(planPath, cwd);
    if (classification) planClassifications.push(classification);
  }
  
  if (planClassifications.length > 0) {
    result.task_routing = {
      plans: planClassifications,
      execution_mode: selectExecutionMode(planClassifications),
      classified_at: new Date().toISOString()
    };
  } else {
    result.task_routing = null;
  }
} catch (e) {
  debugLog('init.executePhase', 'orchestration classification failed (non-blocking)', e);
  result.task_routing = null;
}
```

This adds a `task_routing` field to the init execute-phase JSON output containing per-task complexity scores, recommended models, and execution mode.

**In src/router.js**, add a new top-level command `classify`:
```js
case 'classify': {
  const sub = args[1];
  if (sub === 'plan') {
    // classify plan <plan-path>
    lazyOrchestration().cmdClassifyPlan(cwd, args.slice(2), raw);
  } else if (sub === 'phase') {
    // classify phase <phase-number>
    lazyOrchestration().cmdClassifyPhase(cwd, args.slice(2), raw);
  } else {
    error('Usage: classify <plan|phase> <path-or-number>');
  }
  break;
}
```

Add `lazyOrchestration` loader: `function lazyOrchestration() { return _modules.orchestration || (_modules.orchestration = require('./lib/orchestration')); }`

**In src/lib/orchestration.js**, add CLI command handlers (in same file for simplicity):

`cmdClassifyPlan(cwd, args, raw)`:
- Parse plan path from args
- Call classifyPlan(planPath, cwd)
- Raw: output JSON
- Formatted: banner + table with Task Name, Score, Label, Model, Factors

`cmdClassifyPhase(cwd, args, raw)`:
- Parse phase number from args
- Find phase via findPhaseInternal
- Classify all incomplete plans
- Call selectExecutionMode
- Raw: output full JSON with execution_mode
- Formatted: banner + per-plan tables + execution mode summary

**In src/lib/constants.js**, add COMMAND_HELP for `classify plan` and `classify phase`.

**Tests (10-12 new):**
1. classifyTaskComplexity — minimal task (1 file, no tests) → score 1-2
2. classifyTaskComplexity — complex task (6 files, tests, long action) → score 4-5
3. classifyTaskComplexity — moderate task (3 files, tests) → score 3
4. classifyPlan — parse real plan XML, returns task classifications
5. parseTasksFromPlan — extracts tasks from plan XML correctly
6. parseTasksFromPlan — handles malformed XML gracefully
7. selectExecutionMode — single plan → mode "single"
8. selectExecutionMode — multiple same-wave plans → mode "parallel"
9. selectExecutionMode — plans with checkpoints → mode "sequential"
10. classify plan CLI — returns JSON with task scores
11. classify phase CLI on phase 38 → returns classifications for completed plans
12. init execute-phase on an incomplete phase → task_routing field present in output

Create test fixture plan content as strings in tests (not file fixtures).

Run `npm run build && npm test`.
  </action>
  <verify>
`npm run build && npm test` — all tests pass. `node bin/gsd-tools.cjs classify phase 38 --raw` returns JSON with task classifications. `node bin/gsd-tools.cjs init execute-phase 38 --raw` includes `task_routing` field (may be null if all plans complete).
  </verify>
  <done>
init execute-phase includes task_routing with per-task complexity scores, recommended models, and execution mode. `classify plan` and `classify phase` CLI commands work. All tests pass including 10-12 new orchestration tests.
  </done>
</task>

</tasks>

<verification>
- `node bin/gsd-tools.cjs classify phase 38 --raw` → JSON with plan classifications and execution mode
- `node bin/gsd-tools.cjs classify plan .planning/phases/38-ast-intelligence-repo-map/38-01-PLAN.md --raw` → per-task scores
- `node bin/gsd-tools.cjs init execute-phase 38 --raw | grep task_routing` → field exists
- `npm test` passes with zero regressions
</verification>

<success_criteria>
- Tasks get 1-5 complexity scores based on file count, cross-module reach, tests
- init execute-phase output includes task_routing with recommended agent/model per task
- Execution mode auto-selected from plan wave structure
- Routing decisions visible in formatted CLI output
</success_criteria>

<output>
After completion, create `.planning/phases/39-orchestration-intelligence/39-01-SUMMARY.md`
</output>
