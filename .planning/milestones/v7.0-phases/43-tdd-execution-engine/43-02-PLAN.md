---
phase: 43-tdd-execution-engine
plan: 02
type: execute
wave: 2
depends_on: ["43-01"]
files_modified:
  - workflows/tdd.md
  - workflows/execute-plan.md
  - references/tdd.md
  - references/tdd-antipatterns.md
autonomous: true
requirements: [TDD-01, TDD-02, TDD-03, TDD-04, TDD-05, EXEC-01, EXEC-02]

must_haves:
  truths:
    - "TDD workflow enforces RED→GREEN→REFACTOR sequence with validation gates between each phase"
    - "Executor cannot proceed from RED to GREEN without tdd validate-red confirming test failure"
    - "Executor cannot proceed from GREEN to REFACTOR without tdd validate-green confirming test pass"
    - "Each TDD phase produces a commit with both Agent-Type and GSD-Phase trailers"
    - "Execute-plan workflow auto-runs tests after each file edit during any plan type"
    - "Anti-pattern reference documents pre-test code, YAGNI, and over-mocking violations with explanations"
  artifacts:
    - path: "workflows/tdd.md"
      provides: "Complete TDD execution state machine with orchestrator-enforced gates"
      min_lines: 80
    - path: "references/tdd-antipatterns.md"
      provides: "Anti-pattern detection rules and explanations for TDD execution"
      min_lines: 40
    - path: "references/tdd.md"
      provides: "Updated TDD reference with gate commands and trailer instructions"
    - path: "workflows/execute-plan.md"
      provides: "Auto test-after-edit step for all plan types"
  key_links:
    - from: "workflows/tdd.md"
      to: "bin/gsd-tools.cjs tdd validate-*"
      via: "CLI calls in gate steps"
      pattern: "tdd validate-(red|green|refactor)"
    - from: "workflows/tdd.md"
      to: "bin/gsd-tools.cjs commit"
      via: "commit with --tdd-phase and --agent trailers"
      pattern: "commit.*--tdd-phase"
    - from: "workflows/execute-plan.md"
      to: "bin/gsd-tools.cjs tdd auto-test"
      via: "post-edit test execution"
      pattern: "tdd auto-test"
---

<objective>
TDD execution workflow, auto test-after-edit integration, and anti-pattern detection reference.

Purpose: Create the orchestrator-enforced TDD state machine that the executor follows for `type: tdd` plans. The workflow calls the CLI gate commands from Plan 01 to verify RED→GREEN→REFACTOR transitions. Also adds auto test-after-edit to the general execution workflow and documents anti-patterns with explanations.

Output: `workflows/tdd.md` state machine, updated `workflows/execute-plan.md` with auto-test, updated `references/tdd.md`, new `references/tdd-antipatterns.md`.
</objective>

<execution_context>
@__OPENCODE_CONFIG__/get-shit-done/workflows/execute-plan.md
@__OPENCODE_CONFIG__/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-tdd-execution-engine/43-01-SUMMARY.md
@workflows/execute-plan.md
@references/tdd.md
@references/reviewer-agent.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD execution workflow with orchestrator-enforced gates</name>
  <files>workflows/tdd.md, references/tdd.md</files>
  <action>
Create `workflows/tdd.md` — the complete TDD execution state machine. This is the workflow the executor follows when executing a `type: tdd` plan. Structure:

**State machine overview:**
```
INIT → RED → [validate-red gate] → GREEN → [validate-green gate] → REFACTOR → [validate-refactor gate] → DONE
```

**Step 1: Parse TDD plan.** Read the PLAN.md `<feature>` element. Extract: feature name, source file, test file, behavior cases, implementation hints. Read config.json `test_commands` for the project's test command (default: `npm test`).

**Step 2: RED phase.**
1. Create/modify test file with failing tests based on `<behavior>` cases
2. Run anti-pattern check: `node {config_path}/bin/gsd-tools.cjs tdd detect-antipattern --phase red --files <modified_files>`
   - If warnings about pre-test code (non-test files modified): STOP. Remove non-test changes before proceeding.
3. Run validation gate: `node {config_path}/bin/gsd-tools.cjs tdd validate-red --test-cmd "<test_command>"`
   - If `valid: false` (test passed when it should fail): Fix the test. The test must actually exercise missing behavior.
   - If `valid: true`: Proceed.
4. Commit: `node {config_path}/bin/gsd-tools.cjs commit "test({phase}-{plan}): add failing test for {feature}" --files <test_file> --agent gsd-executor --tdd-phase red`

**Step 3: GREEN phase.**
1. Write minimal implementation to make the test pass. No extra code, no optimization, no edge cases beyond what's tested.
2. Run anti-pattern check: `node {config_path}/bin/gsd-tools.cjs tdd detect-antipattern --phase green --files <modified_files>`
   - If warnings about test modification: investigate. Tests should be stable in GREEN.
3. Run validation gate: `node {config_path}/bin/gsd-tools.cjs tdd validate-green --test-cmd "<test_command>"`
   - If `valid: false` (test still fails): Debug implementation. Iterate until green.
   - If `valid: true`: Proceed.
4. Commit: `node {config_path}/bin/gsd-tools.cjs commit "feat({phase}-{plan}): implement {feature}" --files <source_file> --agent gsd-executor --tdd-phase green`

**Step 4: REFACTOR phase (conditional).**
1. Review implementation for obvious cleanup opportunities. If nothing to improve, skip to Step 5.
2. Make refactoring changes (rename, extract, simplify). No new behavior.
3. Run validation gate: `node {config_path}/bin/gsd-tools.cjs tdd validate-refactor --test-cmd "<test_command>"`
   - If `valid: false` (tests broke): Undo refactor. Either refactor in smaller steps or skip.
   - If `valid: true`: Proceed.
4. Commit: `node {config_path}/bin/gsd-tools.cjs commit "refactor({phase}-{plan}): clean up {feature}" --files <modified_files> --agent gsd-executor --tdd-phase refactor`

**Step 5: Done.** Return to execute-plan workflow for SUMMARY creation.

**Key enforcement rules:**
- NEVER write implementation code before the RED gate passes. This is the "Iron Law" of TDD.
- NEVER skip a validation gate. If a gate fails, fix the issue — don't proceed.
- NEVER modify tests during GREEN phase unless the test itself has a bug (document as deviation).
- Each phase produces exactly one commit with both `Agent-Type` and `GSD-Phase` trailers.

**Stuck/loop detection:** If the same gate fails 3 times consecutively:
1. Log the repeated failure pattern
2. Present the situation: "TDD gate failed 3 times: {gate}, {error pattern}. Options: (a) investigate root cause, (b) abandon TDD for this feature and switch to standard execution, (c) stop"
3. In yolo mode: option (a) with one more attempt, then (b) if still failing

Also update `references/tdd.md`:
- Add a new `<gate_commands>` section documenting the CLI validation commands
- Add a `<commit_trailers>` section documenting the `--tdd-phase` and `--agent` flags
- Update `<execution_flow>` to reference workflows/tdd.md instead of inline instructions
- Keep the existing content (when_to_use, plan_structure, test_quality, etc.) unchanged
  </action>
  <verify>
1. `workflows/tdd.md` exists with state machine steps and gate commands
2. `references/tdd.md` updated with gate_commands and commit_trailers sections
3. All gate commands use the correct `tdd validate-*` CLI syntax from Plan 01
4. Each TDD phase step includes both `--agent` and `--tdd-phase` trailer flags on commit
5. Stuck/loop detection documented with 3-failure threshold
  </verify>
  <done>TDD workflow enforces RED→GREEN→REFACTOR with orchestrator-controlled gates. No phase transition without validation. Each commit has dual trailers.</done>
</task>

<task type="auto">
  <name>Task 2: Auto test-after-edit and anti-pattern reference</name>
  <files>workflows/execute-plan.md, references/tdd-antipatterns.md</files>
  <action>
**Auto test-after-edit in execute-plan.md:**

Add a new `<auto_test_after_edit>` section in execute-plan.md after the `<execute>` step. This applies to ALL plan types (not just TDD):

```
<auto_test_after_edit>
After each file modification during task execution (not just at task end):

1. Check if project has a test command:
   - Config: read test_commands from config.json
   - Fallback: check package.json scripts.test, or look for pytest/go test/cargo test
   - If no test command found: skip auto-test

2. Run auto-test:
   ```bash
   AUTOTEST=$(node {config_path}/bin/gsd-tools.cjs tdd auto-test --test-cmd "<test_command>")
   ```

3. If test fails:
   - Log the failure: "Auto-test failed after editing {file}: {output_snippet}"
   - Fix the issue immediately before continuing to next file edit
   - Do NOT accumulate broken states across multiple edits

4. Frequency: Run after each logical file change (not after every save, but after completing an edit to a file). For rapid multi-file changes within a single conceptual step, run once after the batch.

Purpose: Catch compounding errors early. A test failure after editing file A is much easier to diagnose than a test failure after editing files A, B, C, D.
</auto_test_after_edit>
```

Also update the `<tdd_plan_execution>` section in execute-plan.md to reference the new `workflows/tdd.md`:

Replace the existing `<tdd_plan_execution>` content with:
```
<tdd_plan_execution>
For `type: tdd` plans, follow the dedicated TDD workflow:
@workflows/tdd.md

The TDD workflow enforces RED→GREEN→REFACTOR gates via CLI validation commands. Do NOT use the standard task execution flow for TDD plans.
</tdd_plan_execution>
```

**Anti-pattern reference document:**

Create `references/tdd-antipatterns.md` with structured detection rules:

**Pre-test code (RED phase violation):**
- Pattern: Source files (non-test, non-config) modified before RED gate passes
- Why bad: Defeats TDD — you're writing implementation before defining behavior
- Detection: `tdd detect-antipattern --phase red` checks file list
- Fix: Delete the implementation code, write the test first

**YAGNI violations (GREEN phase):**
- Pattern: Implementation code far exceeds what tests require (e.g., 200-line implementation for 3 test cases)
- Why bad: TDD GREEN means "minimal code to pass" — extra code is untested and likely wrong
- Detection: Heuristic — if implementation LOC > 5× test LOC, flag for review
- Fix: Remove code that isn't exercised by a test. If you need it, write a test for it first.

**Over-mocking:**
- Pattern: >5 mock/stub calls in a single test file
- Why bad: Tests become brittle, test the mocking framework instead of behavior, hide integration bugs
- Detection: `tdd detect-antipattern` counts mock patterns
- Fix: Test with real implementations. Mock only external services and I/O.

**Test modification in GREEN:**
- Pattern: Test file changed during GREEN phase
- Why bad: Moving the goalposts — the test should define the contract, implementation meets it
- Detection: `tdd detect-antipattern --phase green` checks file list
- Exception: Fixing a genuine test bug (typo, wrong assertion) — document as deviation

**Implementation before test (any phase):**
- Pattern: Implementation file has uncommitted changes when entering RED phase
- Why bad: Starting RED with existing implementation means you might write tests that pass immediately
- Detection: Check git status for source file changes at RED entry
- Fix: Stash or commit existing work before starting TDD cycle
  </action>
  <verify>
1. `workflows/execute-plan.md` has `<auto_test_after_edit>` section
2. `workflows/execute-plan.md` `<tdd_plan_execution>` references `workflows/tdd.md`
3. `references/tdd-antipatterns.md` exists with all 5 anti-patterns documented
4. Auto-test references `tdd auto-test` CLI command from Plan 01
  </verify>
  <done>Execute-plan workflow has auto test-after-edit for all plan types. TDD plan execution delegates to dedicated workflow. Anti-pattern reference documents 5 violation types with detection and fixes.</done>
</task>

</tasks>

<verification>
1. `workflows/tdd.md` contains complete state machine with 5 steps and 3 gates
2. Each gate step calls `tdd validate-*` CLI command
3. Each commit step includes `--agent gsd-executor --tdd-phase <phase>` flags
4. `workflows/execute-plan.md` has auto test-after-edit section
5. `references/tdd-antipatterns.md` covers all required anti-patterns
6. `references/tdd.md` updated with gate and trailer documentation
7. No bundle impact (all changes are markdown files)
</verification>

<success_criteria>
- TDD workflow documents complete RED→GREEN→REFACTOR state machine with CLI-enforced gates
- Execute-plan workflow includes auto test-after-edit for early error catching
- Anti-pattern reference covers pre-test code, YAGNI, over-mocking, test modification, and implementation-before-test
- All references cross-link correctly (tdd.md → tdd workflow, execute-plan → tdd workflow)
- Zero bundle impact (markdown-only changes)
</success_criteria>

<output>
After completion, create `.planning/phases/43-tdd-execution-engine/43-02-SUMMARY.md`
</output>
