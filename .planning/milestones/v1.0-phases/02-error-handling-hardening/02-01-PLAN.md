---
phase: 02-error-handling-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [bin/gsd-tools.cjs, bin/gsd-tools.test.cjs]
autonomous: true
requirements: [FOUND-01]

must_haves:
  truths:
    - "Setting GSD_DEBUG=1 produces diagnostic output on stderr for every catch block"
    - "With GSD_DEBUG unset, tool behavior is identical to before — no output changes"
    - "stdout JSON remains valid parseable JSON regardless of GSD_DEBUG setting"
  artifacts:
    - path: "bin/gsd-tools.cjs"
      provides: "debugLog() helper function and all catch blocks instrumented"
      contains: "function debugLog"
    - path: "bin/gsd-tools.test.cjs"
      provides: "Tests verifying debug logging behavior"
      contains: "GSD_DEBUG"
  key_links:
    - from: "catch blocks"
      to: "debugLog()"
      via: "function call in catch body"
      pattern: "debugLog\\("
---

<objective>
Add debug logging infrastructure and instrument all ~95 silent catch blocks with gated stderr diagnostic output.

Purpose: Make the plugin observable when debugging — the 95 silent catch blocks currently mask errors, making diagnosis of corrupted STATE.md, malformed ROADMAP.md, or failed git operations extremely difficult. This is the single highest-impact observability improvement.

Output: `debugLog()` helper function, all catch blocks instrumented, tests verifying logging behavior and stdout JSON integrity.
</objective>

<execution_context>
@/home/cam/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/cam/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/CONCERNS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add debugLog() helper and instrument all catch blocks</name>
  <files>bin/gsd-tools.cjs</files>
  <action>
1. Add a `debugLog(context, message, err)` helper function near the top of the helpers section (after the `error()` function, around line 495). The function should:
   - Check `process.env.GSD_DEBUG` — if not set (falsy), return immediately (no-op)
   - Write to `process.stderr.write()` — NEVER stdout (which is the JSON data channel)
   - Format: `[GSD_DEBUG] {context}: {message}` with optional error details
   - If `err` is provided, append ` | ${err.message || err}` to the output
   - Always end with `\n`

2. Find every `catch {}` and `catch (e) {}` / `catch (err) {}` block in the file (there are ~95 total). For each one:
   - Add a `debugLog()` call with a meaningful context string describing what operation was attempted
   - Context should be the function name or a brief description (e.g., `'loadConfig'`, `'execGit'`, `'state.load'`, `'frontmatter.extract'`)
   - For catches that already have an error variable (e.g., `catch (err)`), pass it as the third argument
   - For empty catches (`catch {}`), change to `catch (e)` and pass `e` to debugLog
   - Do NOT change the return value or control flow of any catch block — the existing behavior (return null, return defaults, continue) must be preserved exactly

3. Categorize catch blocks by criticality for the context message:
   - State reads/writes: context = `'state.{operation}'`
   - Config reads: context = `'config.load'` or `'config.ensure'`
   - Git operations: context = `'git.{operation}'`
   - File reads: context = `'file.read'` or the specific function name
   - Roadmap parsing: context = `'roadmap.{operation}'`
   - Phase operations: context = `'phase.{operation}'`
   - Feature commands: context = `'feature.{commandName}'`

4. Important: The `output()` function writes to stdout and calls `process.exit(0)`. The `error()` function writes to stderr and calls `process.exit(1)`. Debug logging must ONLY use `process.stderr.write()` — never `console.log()` or `console.error()` (which write to stderr but with formatting that could interfere).
  </action>
  <verify>
Run: `GSD_DEBUG=1 node bin/gsd-tools.cjs state load --raw 2>debug.log && cat debug.log | head -5` — should show debug lines on stderr.
Run: `node bin/gsd-tools.cjs current-timestamp --raw 2>/dev/null` — should produce clean output with no debug noise.
Run: `GSD_DEBUG=1 node bin/gsd-tools.cjs state load --raw 2>/dev/null | python3 -c "import json,sys; json.load(sys.stdin); print('valid JSON')"` — stdout must be valid JSON even with debug enabled.
Run: `grep -c 'debugLog(' bin/gsd-tools.cjs` — should be ~95 or more (one per catch block).
  </verify>
  <done>Every catch block in gsd-tools.cjs has a debugLog() call. GSD_DEBUG=1 produces stderr diagnostics. GSD_DEBUG unset produces zero additional output. stdout JSON is never contaminated.</done>
</task>

<task type="auto">
  <name>Task 2: Add tests for debug logging behavior</name>
  <files>bin/gsd-tools.test.cjs</files>
  <action>
Add a new `describe('debug logging')` block to the test file with tests:

1. **Debug output on stderr when GSD_DEBUG=1**: Run a command that triggers catch blocks (e.g., `state load` on a non-existent project dir) with `GSD_DEBUG=1` env var. Capture stderr. Assert stderr contains `[GSD_DEBUG]` prefix.

2. **No debug output when GSD_DEBUG unset**: Run the same command without `GSD_DEBUG`. Capture stderr. Assert stderr does NOT contain `[GSD_DEBUG]`.

3. **stdout JSON remains valid with GSD_DEBUG=1**: Run `state load --raw` (or similar command producing JSON) with `GSD_DEBUG=1`. Parse stdout as JSON. Assert it parses successfully — no debug text leaked into stdout.

4. **Debug output includes context**: Run a command with `GSD_DEBUG=1` that reads a non-existent file. Assert stderr debug output includes a recognizable context string (like `file.read` or `config.load`).

Use the existing test patterns: `execSync()` with `{ encoding: 'utf-8', env: { ...process.env, GSD_DEBUG: '1' } }` for env var control, and `stdio: ['pipe', 'pipe', 'pipe']` to capture both stdout and stderr separately.
  </action>
  <verify>
Run: `npm test 2>&1 | grep -A2 'debug logging'` — all debug logging tests should pass.
  </verify>
  <done>Tests verify: debug output appears on stderr with GSD_DEBUG=1, no debug output without it, stdout JSON never contaminated, and context strings are present in debug output.</done>
</task>

</tasks>

<verification>
1. `npm test` passes (all existing tests + new debug logging tests)
2. `GSD_DEBUG=1 node bin/gsd-tools.cjs state load --raw 2>debug.log` produces debug output in debug.log
3. `node bin/gsd-tools.cjs current-timestamp --raw` produces clean output (no debug noise)
4. `grep -c 'debugLog(' bin/gsd-tools.cjs` returns ~95+ (all catch blocks instrumented)
5. `GSD_DEBUG=1 node bin/gsd-tools.cjs state load --raw 2>/dev/null | python3 -c "import json,sys; json.load(sys.stdin)"` succeeds (valid JSON on stdout)
</verification>

<success_criteria>
- debugLog() helper exists and is gated behind GSD_DEBUG env var
- All ~95 catch blocks have debugLog() calls with meaningful context strings
- stderr receives diagnostics when GSD_DEBUG=1, nothing when unset
- stdout JSON is never contaminated regardless of GSD_DEBUG setting
- Tests verify all three behaviors (debug on, debug off, JSON integrity)
</success_criteria>

<output>
After completion, create `.planning/phases/02-error-handling-hardening/02-01-SUMMARY.md`
</output>
