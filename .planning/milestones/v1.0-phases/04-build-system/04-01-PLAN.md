---
phase: 04-build-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [package.json, build.js]
autonomous: true
requirements: [BUILD-01]

must_haves:
  truths:
    - "npm run build produces bin/gsd-tools.cjs from the current source"
    - "The built output is functionally identical to the current monolith"
    - "Build completes in under 500ms"
    - "Built file has working shebang and no runtime dependencies"
  artifacts:
    - path: "build.js"
      provides: "esbuild build script"
      contains: "esbuild"
    - path: "package.json"
      provides: "esbuild devDependency and build script"
      contains: "esbuild"
  key_links:
    - from: "build.js"
      to: "bin/gsd-tools.cjs"
      via: "esbuild bundle output"
      pattern: "outfile.*bin/gsd-tools\\.cjs"
---

<objective>
Set up esbuild bundler pipeline that can bundle the current monolith (as a no-op proof-of-concept) before the module split.

Purpose: Establish the build infrastructure BEFORE splitting source code. This lets us verify esbuild works correctly with the current single-file source, ensuring no behavior changes. The module split (Plan 02) then becomes a pure refactoring step with known-good build tooling.

Output: build.js script using esbuild API, esbuild devDependency in package.json, working `npm run build`.
</objective>

<execution_context>
@/home/cam/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/cam/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/SUMMARY.md
@.planning/codebase/STACK.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install esbuild and create build.js</name>
  <files>package.json, build.js</files>
  <action>
1. Install esbuild as a devDependency:
   ```
   npm install --save-dev esbuild
   ```
   This adds esbuild to package.json devDependencies and creates node_modules/.

2. Create `build.js` at the project root. This is a Node.js script (not a config file) that uses esbuild's JS API:

```javascript
#!/usr/bin/env node
const esbuild = require('esbuild');
const { execSync } = require('child_process');

async function build() {
  const start = Date.now();
  
  await esbuild.build({
    entryPoints: ['bin/gsd-tools.cjs'],
    outfile: 'bin/gsd-tools.bundle.cjs',
    bundle: true,
    platform: 'node',
    format: 'cjs',
    target: 'node18',
    packages: 'external',  // Don't bundle node built-ins
    banner: {
      js: '#!/usr/bin/env node',
    },
    minify: false,  // Keep readable for debugging
    sourcemap: false,
  });
  
  const elapsed = Date.now() - start;
  console.log(`Built bin/gsd-tools.bundle.cjs in ${elapsed}ms`);
  
  // Smoke test
  try {
    const result = execSync('node bin/gsd-tools.bundle.cjs current-timestamp --raw', {
      encoding: 'utf-8',
      timeout: 5000,
    });
    console.log(`Smoke test passed: ${result.trim()}`);
  } catch (err) {
    console.error('Smoke test FAILED:', err.message);
    process.exit(1);
  }
}

build().catch(err => {
  console.error('Build failed:', err);
  process.exit(1);
});
```

Note: For now, the entry point is `bin/gsd-tools.cjs` itself (the monolith). Since it has no imports, esbuild just passes it through with the shebang banner. The output goes to `bin/gsd-tools.bundle.cjs` temporarily to avoid overwriting the working file during proof-of-concept.

3. Update package.json:
   - Change `"build"` script from the placeholder echo to `"node build.js"`
   - Ensure esbuild is in devDependencies

4. Add `node_modules/` to .gitignore if it doesn't already exist.

5. The `packages: 'external'` setting means Node.js built-in modules (fs, path, child_process, os) won't be bundled — they'll remain as require() calls. This is correct for a Node CLI tool.

IMPORTANT: The current file has NO imports/exports — it's a self-contained monolith. esbuild should produce essentially the same file with just the shebang added. This is the expected "no-op" behavior that proves the pipeline works.
  </action>
  <verify>
Run: `npm run build` — should produce bin/gsd-tools.bundle.cjs and pass smoke test.
Run: `node bin/gsd-tools.bundle.cjs current-timestamp --raw` — should output a timestamp.
Run: `node bin/gsd-tools.bundle.cjs state load --raw` — should work identically to the original.
Run: `npm test` — all existing tests should still pass (they reference the original file).
  </verify>
  <done>esbuild pipeline works, produces functional output from monolith source, smoke test passes, all existing tests still pass against original file.</done>
</task>

<task type="auto">
  <name>Task 2: Verify bundled output matches original behavior</name>
  <files>bin/gsd-tools.test.cjs</files>
  <action>
1. Add a `describe('build system')` test block that:
   a. Runs `npm run build` and verifies exit code 0
   b. Verifies `bin/gsd-tools.bundle.cjs` exists
   c. Runs `current-timestamp --raw` against the bundled file and verifies it produces valid output
   d. Runs `state load --raw` in a temp dir with STATE.md against both original and bundled, compares output (should be identical)

2. Clean up: after tests, remove the .bundle.cjs file to keep the workspace clean.

Note: These tests validate the BUILD pipeline, not the source split (that comes in Plan 02).
  </action>
  <verify>
Run: `npm test` — all tests pass including new build system tests.
  </verify>
  <done>Build pipeline has automated tests. Bundled output verified to match original behavior.</done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds and produces bin/gsd-tools.bundle.cjs
2. Smoke test passes (timestamp output)
3. `npm test` passes with new build system tests
4. Build completes in under 500ms
</verification>

<success_criteria>
- esbuild is a devDependency
- build.js produces working output with shebang
- npm run build works end-to-end
- Bundled output is functionally identical to original
- Tests verify build pipeline
</success_criteria>

<output>
After completion, create `.planning/phases/04-build-system/04-01-SUMMARY.md`
</output>
