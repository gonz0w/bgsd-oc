---
phase: 05-performance-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/helpers.js
  - src/commands/features.js
  - bin/gsd-tools.test.cjs
autonomous: true
requirements:
  - PERF-01
  - PERF-02

must_haves:
  truths:
    - "safeReadFile returns cached content on second call for same path within single CLI invocation"
    - "Cache is invalidated when a file is written via fs.writeFileSync"
    - "cmdCodebaseImpact spawns one grep process for multiple patterns instead of N processes"
  artifacts:
    - path: "src/lib/helpers.js"
      provides: "fileCache Map + cachedReadFile wrapper + invalidateFileCache helper"
      contains: "new Map"
    - path: "src/commands/features.js"
      provides: "Batch grep in cmdCodebaseImpact"
      contains: "grep -rl"
    - path: "bin/gsd-tools.test.cjs"
      provides: "Tests for file cache and batch grep"
  key_links:
    - from: "src/lib/helpers.js"
      to: "safeReadFile"
      via: "cachedReadFile wrapping safeReadFile with Map cache"
      pattern: "fileCache\\.get|fileCache\\.set"
    - from: "src/commands/features.js"
      to: "grep"
      via: "single grep -rl -e pat1 -e pat2 call"
      pattern: "grep -rl.*-e"
---

<objective>
Add an in-memory file cache to eliminate repeated filesystem reads within a single CLI invocation, and batch grep patterns in cmdCodebaseImpact to reduce process spawning.

Purpose: Reduce I/O overhead for commands that read the same files multiple times (e.g., init commands reading ROADMAP.md, STATE.md repeatedly) and reduce process spawning in codebase-impact analysis.
Output: Updated src/lib/helpers.js with cache, updated src/commands/features.js with batch grep, new tests.
</objective>

<execution_context>
@/home/cam/.config/Claude/get-shit-done/workflows/execute-plan.md
@/home/cam/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/helpers.js
@src/commands/features.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: In-memory file cache wrapping safeReadFile</name>
  <files>src/lib/helpers.js</files>
  <action>
Create a module-level `const fileCache = new Map()` in src/lib/helpers.js.

Create `cachedReadFile(filePath)` that:
1. Checks `fileCache.has(filePath)` — if yes, return cached value
2. Calls `safeReadFile(filePath)` to get content
3. If content is not null, stores `fileCache.set(filePath, content)`
4. Returns content

Create `invalidateFileCache(filePath)` that calls `fileCache.delete(filePath)`. If no filePath given, calls `fileCache.clear()`.

Export both `cachedReadFile` and `invalidateFileCache`.

Do NOT modify `safeReadFile` itself — it stays as the raw uncached reader. The cache is opt-in: callers that want caching use `cachedReadFile`, callers that need fresh reads use `safeReadFile`.

The cache lives for the duration of the process (single CLI invocation) — no TTL, no eviction, no LRU needed. CLI processes are short-lived (typically <5 seconds).

Note: Research suggested lru-cache v10 but a plain Map is sufficient for a short-lived CLI process. No external dependency needed.
  </action>
  <verify>
`npm run build` succeeds. `npm test` passes (142 pass, 1 pre-existing failure). Manual check: `node bin/gsd-tools.cjs init progress --raw 2>/dev/null | python3 -c "import json,sys; print(json.load(sys.stdin)['phase_count'])"` returns 5.
  </verify>
  <done>
`cachedReadFile` and `invalidateFileCache` are exported from helpers.js. fileCache Map exists at module scope. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Batch grep in cmdCodebaseImpact</name>
  <files>src/commands/features.js</files>
  <action>
In `cmdCodebaseImpact()` (line ~613), replace the per-pattern grep loop with a single batched grep call.

Current code iterates `searchPatterns` and spawns one `grep -rl --fixed-strings PATTERN` per pattern. Replace with:

1. After building `searchPatterns` array, skip the per-pattern loop
2. Build a single grep command: `grep -rl --fixed-strings -e pat1 -e pat2 -e pat3 --include="*.ex" --include="*.exs" --include="*.go" --include="*.py" --include="*.ts" --include="*.tsx" --include="*.js" . 2>/dev/null | grep -v node_modules | grep -v _build | grep -v deps | head -30`
3. Each pattern gets its own `-e` flag with `sanitizeShellArg()` applied
4. Parse results the same way (split lines, filter self, deduplicate)
5. If `searchPatterns` is empty, skip grep entirely

This reduces N grep processes to 1. The `--fixed-strings` flag is already used in the existing code.

Edge case: If searchPatterns has regex patterns (from Python `from.*basename` patterns), those patterns should NOT use `--fixed-strings`. Split into two calls if mixed: one `--fixed-strings` for literal patterns and one without for regex patterns. In practice, check if any pattern contains regex metacharacters (`.*+?[]{}()|^$\`). If all are literal, use single `--fixed-strings` call. If mixed, use two calls.
  </action>
  <verify>
`npm run build` succeeds. `npm test` passes. Manual test: `node bin/gsd-tools.cjs codebase-impact src/lib/helpers.js --raw 2>/dev/null | python3 -c "import json,sys; d=json.load(sys.stdin); print(f'dependents: {d[\"total_dependents\"]}')"` returns a number > 0.
  </verify>
  <done>
`cmdCodebaseImpact` spawns at most 2 grep processes (1 for fixed-string patterns, 1 for regex patterns) instead of N processes per pattern. Build and tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Tests for file cache and batch grep</name>
  <files>bin/gsd-tools.test.cjs</files>
  <action>
Add a new test suite to `bin/gsd-tools.test.cjs` for Phase 5 features.

**File cache tests** (test via the built CLI since cache is internal):
1. "cachedReadFile returns same content as safeReadFile" — Create a temp file, read with both functions via a small inline test that imports from the build. Since the test file tests the bundled CLI, test indirectly: call `init progress` twice in quick succession and verify both return valid JSON (proves cache doesn't break anything).
2. Test that `codebase-impact` still works correctly after cache addition (functional regression).

**Batch grep tests:**
1. "codebase-impact returns dependents for a known file" — Run `codebase-impact src/lib/helpers.js` and verify `total_dependents > 0` (helpers.js is imported by many files).
2. "codebase-impact handles non-existent file" — Run `codebase-impact nonexistent.js` and verify result has `exists: false`.
3. "codebase-impact handles file with no dependents" — Run `codebase-impact package.json` and verify it returns without error (package.json is not imported by JS files).

**Context budget tests** (prep for Plan 02):
Skip — will be added in Plan 02.

Use the same test patterns as existing tests: `execSync` calling `node bin/gsd-tools.cjs <command> --raw`, parsing JSON output, asserting with `assert.strictEqual` / `assert.ok`.
  </action>
  <verify>
`npm test` passes with new tests (expect ~147+ pass, 1 pre-existing failure unchanged).
  </verify>
  <done>
At least 5 new tests covering file cache regression and batch grep functionality. All pass.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes in under 500ms
2. `npm test` shows 147+ passing tests with only the 1 pre-existing failure
3. `node bin/gsd-tools.cjs codebase-impact src/lib/helpers.js --raw` returns valid JSON with dependents
4. `node bin/gsd-tools.cjs init progress --raw` returns valid JSON (cache doesn't break compound commands)
</verification>

<success_criteria>
- fileCache Map exists in helpers.js with cachedReadFile/invalidateFileCache exports
- cmdCodebaseImpact uses batched grep (1-2 processes max instead of N)
- 5+ new passing tests covering cache and batch grep
- Build time still under 500ms
- All 142+ existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-performance-polish/05-01-SUMMARY.md`
</output>
