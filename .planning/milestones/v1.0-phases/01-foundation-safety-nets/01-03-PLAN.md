---
phase: 01-foundation-safety-nets
plan: 03
type: execute
wave: 2
depends_on:
  - 01-02
files_modified:
  - bin/gsd-tools.test.cjs
autonomous: true
requirements:
  - FOUND-03

must_haves:
  truths:
    - "All 8 state mutation commands have round-trip tests that write, mutate, and re-read STATE.md"
    - "Each test verifies both the JSON command output AND the actual file content after mutation"
    - "`state update` correctly replaces a single `**Field:** value` line"
    - "`state patch` correctly replaces multiple fields in a single invocation"
    - "`state add-decision` appends a decision bullet to the Decisions section"
    - "`state add-blocker` appends a blocker bullet to the Blockers section"
    - "`state resolve-blocker` removes a specific blocker by text match"
    - "`state record-session` updates all three session continuity fields"
    - "`state advance-plan` increments the plan number and updates status"
    - "`state record-metric` appends a row to the Performance Metrics table"
  artifacts:
    - path: "bin/gsd-tools.test.cjs"
      provides: "8 state mutation test suites with round-trip verification"
      contains: "state update"
  key_links:
    - from: "bin/gsd-tools.test.cjs"
      to: "bin/gsd-tools.cjs"
      via: "CLI subprocess invocation (runGsdTools)"
      pattern: "runGsdTools.*state"
---

<objective>
Add round-trip tests for all 8 state mutation commands — the highest data-corruption risk area with zero existing test coverage.

Purpose: The 8 state mutation commands modify STATE.md in place using regex replacement. Any regression silently corrupts project state. These tests create the safety net that must exist before any refactoring in later phases.
Output: 8 new test suites in `bin/gsd-tools.test.cjs`
</objective>

<execution_context>
@/home/cam/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/cam/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-safety-nets/01-RESEARCH.md
@.planning/codebase/TESTING.md
@bin/gsd-tools.test.cjs
@bin/gsd-tools.cjs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add state mutation tests for update, patch, add-decision, and add-blocker</name>
  <files>bin/gsd-tools.test.cjs</files>
  <action>
Add 4 new `describe` blocks to `bin/gsd-tools.test.cjs` following the established test pattern (ASCII divider, beforeEach/afterEach with createTempProject/cleanup, inline fixtures).

**Shared fixture for all 8 state mutation tests** — use this minimal STATE.md content that covers all 8 section patterns:

```markdown
# Project State

## Current Position

**Phase:** 1 of 3 (Foundation)
**Current Plan:** 1
**Total Plans in Phase:** 3
**Plan:** 01-01 — Setup
**Status:** In progress
**Last Activity:** 2026-01-01

**Progress:** [░░░░░░░░░░] 0%

## Performance Metrics

**Velocity:**
- Total plans completed: 0
- Average duration: -
- Total execution time: 0 hours

**By Phase:**

| Phase | Plans | Total | Avg/Plan |
|-------|-------|-------|----------|
| - | - | - | - |

## Accumulated Context

### Decisions

None yet.

### Blockers/Concerns

None yet.

## Session Continuity

**Last session:** 2026-01-01
**Stopped at:** Phase 1 setup
**Resume file:** None
```

**Suite 1: `state update` command**
Test cases:
1. Updates a single field: `state update --field Status --value "Complete"` → verify `**Status:** Complete` in file
2. Updates Phase field: `state update --field Phase --value "2 of 3 (API)"` → verify in file
3. Returns JSON with `updated: true` on success

**Suite 2: `state patch` command**
Test cases:
1. Updates multiple fields at once: `state patch --Status "Review" --"Last Activity" "2026-02-01"` → verify both fields in file
2. Returns JSON with `updated: true` and `fields_updated` count

**Suite 3: `state add-decision` command**
Test cases:
1. Appends decision to Decisions section: `state add-decision --phase 1 --summary "Use esbuild" --rationale "Fastest bundler"` → verify decision text in file AND `None yet.` placeholder removed
2. Adds second decision without removing first: run twice → verify both decisions present
3. Returns JSON with `added: true`

**Suite 4: `state add-blocker` command**
Test cases:
1. Appends blocker to Blockers section: `state add-blocker --description "Config drift"` → verify blocker text in file AND `None yet.` placeholder removed
2. Returns JSON with `added: true`

CRITICAL RULES:
- Every test MUST do the round-trip: (1) write STATE.md, (2) run command, (3) check JSON output, (4) re-read STATE.md and verify content
- Use `assert.ok(result.success, ...)` with descriptive messages per convention
- Use `fs.readFileSync` to re-read file for content verification
- Each test gets a fresh temp directory via beforeEach/afterEach
- Place new suites AFTER the existing test suites, before the closing of the file
- Add ASCII divider comments between suites matching existing style
  </action>
  <verify>
Run `node --test bin/gsd-tools.test.cjs` — all existing 81 tests + new tests pass.
Run `node --test --test-name-pattern="state update" bin/gsd-tools.test.cjs` — state update tests pass.
Run `node --test --test-name-pattern="state add-decision" bin/gsd-tools.test.cjs` — add-decision tests pass.
  </verify>
  <done>
4 new describe blocks exist for `state update`, `state patch`, `state add-decision`, `state add-blocker`. Each test verifies both JSON output and file content round-trip. All existing + new tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add state mutation tests for resolve-blocker, record-session, advance-plan, and record-metric</name>
  <files>bin/gsd-tools.test.cjs</files>
  <action>
Add 4 more `describe` blocks to `bin/gsd-tools.test.cjs` continuing after the suites from Task 1.

**Suite 5: `state resolve-blocker` command**
Test cases:
1. Setup: First add a blocker via `state add-blocker --description "Config drift"`, then resolve it: `state resolve-blocker --description "Config drift"` → verify blocker removed from file
2. Returns JSON with `resolved: true`
3. Handles non-existent blocker gracefully (returns error or resolved: false)

**Suite 6: `state record-session` command**
Test cases:
1. Updates all three session fields: `state record-session --date "2026-02-15" --stopped-at "Phase 2 API work" --resume "None"` → verify all three fields in file: `**Last session:** 2026-02-15`, `**Stopped at:** Phase 2 API work`, `**Resume file:** None`
2. Returns JSON with `recorded: true`

**Suite 7: `state advance-plan` command**
Test cases:
1. Advances plan number from 1 to 2: `state advance-plan` → verify `**Current Plan:** 2` and `**Status:** In progress` and updated `**Last Activity:**` in file
2. Verify `**Plan:**` field is updated with new plan identifier
3. Returns JSON with `advanced: true` and new plan number

Note: Look at `cmdStateAdvancePlan()` (line ~1208) to understand exact behavior — it may need `--plan` or `--phase` arguments. Check the function signature and argument parsing before writing tests. Adapt test invocation to match the actual CLI interface.

**Suite 8: `state record-metric` command**
Test cases:
1. Appends a row to the Performance Metrics table: `state record-metric --plan "01-01" --duration "45m" --tasks 3 --files 5` → verify new row appears in the `| Phase | Plans | Total | Avg/Plan |` table in the file
2. Returns JSON with `recorded: true`

Note: Check `cmdStateRecordMetric()` (line ~1237) for exact argument names — they may be `--plan`, `--duration`, `--tasks`, `--files` or different. Read the function implementation to determine the correct CLI arguments before writing tests.

CRITICAL: Before writing each test suite, read the corresponding `cmd*` function in `bin/gsd-tools.cjs` to determine:
1. Exact CLI argument names and format
2. Expected JSON output keys
3. How the function modifies STATE.md (regex patterns used)
This ensures tests match the actual implementation rather than guessing at interfaces.
  </action>
  <verify>
Run `node --test bin/gsd-tools.test.cjs` — ALL tests pass (existing 81 + all 8 new state mutation suites).
Run `node --test --test-name-pattern="state resolve-blocker" bin/gsd-tools.test.cjs` — resolve-blocker tests pass.
Run `node --test --test-name-pattern="state record-metric" bin/gsd-tools.test.cjs` — record-metric tests pass.
  </verify>
  <done>
All 8 state mutation commands have round-trip tests. Each test verifies JSON output AND re-reads STATE.md to confirm the mutation. Total test count increased by ~20+ new test cases. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `node --test bin/gsd-tools.test.cjs` — all tests pass (0 failures)
2. `node --test bin/gsd-tools.test.cjs 2>&1 | grep -c "# pass"` — count of passing tests is 81 + new tests
3. Each of the 8 state mutation commands has at least 2 test cases
4. Every test re-reads STATE.md after mutation (verified by code inspection — look for `readFileSync` after `runGsdTools`)
</verification>

<success_criteria>
- 8 new describe blocks covering all state mutation commands
- Every test verifies both JSON output and file round-trip
- All existing tests still pass (no regressions)
- Tests use established patterns (createTempProject, cleanup, inline fixtures, descriptive assertion messages)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-safety-nets/01-03-SUMMARY.md`
</output>
