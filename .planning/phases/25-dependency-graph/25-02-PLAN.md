---
phase: 25-dependency-graph
plan: 02
type: execute
wave: 2
depends_on: [25-01]
files_modified:
  - src/lib/deps.js
  - src/commands/codebase.js
  - src/router.js
  - bin/gsd-tools.cjs
  - bin/gsd-tools.test.cjs
autonomous: true
requirements: [DEPS-04, DEPS-05]
outcome_ids: [DO-07, DO-09]

must_haves:
  truths:
    - "User can run `codebase impact <file>` to see transitive dependents with fan-in count"
    - "Cycle detection identifies circular dependencies using Tarjan's SCC algorithm"
    - "Impact analysis shows what breaks if a file changes (transitive, not just direct)"
    - "Tests cover import parsing accuracy, graph construction, impact analysis, and cycle detection"
  artifacts:
    - path: "src/lib/deps.js"
      provides: "Tarjan's SCC cycle detection + transitive impact analysis"
      exports: ["findCycles", "getTransitiveDependents"]
    - path: "src/commands/codebase.js"
      provides: "cmdCodebaseImpact (upgraded) + cmdCodebaseDeps --cycles flag"
      exports: ["cmdCodebaseImpact"]
    - path: "bin/gsd-tools.test.cjs"
      provides: "Test cases for dependency graph features"
      contains: "describe.*dependency"
  key_links:
    - from: "src/commands/codebase.js cmdCodebaseImpact"
      to: "src/lib/deps.js getTransitiveDependents"
      via: "function call with cached graph from intel"
      pattern: "getTransitiveDependents"
    - from: "src/commands/codebase.js cmdCodebaseDeps"
      to: "src/lib/deps.js findCycles"
      via: "called when --cycles flag present"
      pattern: "findCycles"
    - from: "src/router.js"
      to: "src/commands/codebase.js cmdCodebaseImpact"
      via: "codebase impact <file> route"
      pattern: "impact.*lazyCodebase"
---

<objective>
Add impact analysis with transitive dependents, Tarjan's SCC cycle detection, and comprehensive test coverage for the dependency graph.

Purpose: Enable developers to understand change impact ("what breaks if I modify this file?") and detect circular dependencies that indicate architectural issues. Completes all DEPS requirements.
Output: Enhanced deps.js with cycle detection + impact analysis, upgraded codebase impact command, test suite.
</objective>

<execution_context>
@/home/cam/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/cam/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/STATE.md
@.planning/phases/25-dependency-graph/25-01-SUMMARY.md
@src/lib/deps.js
@src/commands/codebase.js
@src/commands/features.js
@src/router.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Tarjan's SCC cycle detection and transitive impact analysis</name>
  <files>src/lib/deps.js, src/commands/codebase.js, src/router.js, bin/gsd-tools.cjs</files>
  <action>
**In `src/lib/deps.js`, add two functions:**

**`findCycles(graph)`** — Implements Tarjan's strongly connected components algorithm:
- Input: `graph.forward` adjacency list `{ [file]: [importedFiles] }`
- Algorithm: Standard Tarjan's SCC using index counter, stack, and lowlink values
- Returns array of cycles, where each cycle is an array of file paths with length >= 2 (self-imports are noted but filtered by default)
- Sort cycles by length descending (largest first)
- Return `{ cycles: [...], cycle_count: N, files_in_cycles: N }` where `files_in_cycles` is the count of unique files participating in any cycle

**`getTransitiveDependents(graph, filePath, maxDepth = 10)`** — BFS traversal of reverse edges:
- Input: `graph.reverse` adjacency list, starting file path, optional max depth (prevent infinite loops on cycles)
- BFS from filePath through reverse edges, collecting all files that transitively depend on the input
- Track depth for each discovered dependent
- Returns `{ file: filePath, direct_dependents: [...], transitive_dependents: [...], fan_in: N, max_depth_reached: N }`
- `direct_dependents`: files that directly import the target (depth 1)
- `transitive_dependents`: all unique files at depth > 1, sorted by depth ascending
- `fan_in`: total count of all unique dependents (direct + transitive)

Export both functions.

**In `src/commands/codebase.js`:**

**Enhance `cmdCodebaseDeps`** — Add `--cycles` flag handling:
1. After building graph, if `--cycles` flag present, call `findCycles(graph)`
2. Add `cycles` field to output JSON: `{ cycles: [...], cycle_count: N, files_in_cycles: N }`
3. Without `--cycles`, omit cycle info (it's optional analysis)

**Add `cmdCodebaseImpact(cwd, args, raw)`** — New command replacing the old grep-based `cmdCodebaseImpact` in features.js:
1. Read args: file paths from args (filter out flags)
2. Read intel via `readIntel(cwd)` — error if no intel
3. If `intel.dependencies` doesn't exist, auto-build graph first (call `buildDependencyGraph` then persist)
4. For each file path:
   - Call `getTransitiveDependents(intel.dependencies, filePath)`
   - Collect result
5. Output structured JSON:
   ```json
   {
     "success": true,
     "files": [
       {
         "file": "src/lib/deps.js",
         "fan_in": 5,
         "direct_dependents": ["src/commands/codebase.js"],
         "transitive_dependents": [{"file": "src/router.js", "depth": 2}],
         "max_depth_reached": 2
       }
     ]
   }
   ```

Export `cmdCodebaseImpact` from codebase.js module.exports.

**In `src/router.js`:**

The `codebase impact` route was added in Plan 01. Ensure it calls `lazyCodebase().cmdCodebaseImpact(cwd, args.slice(2), raw)`.

**Also update the old `codebase-impact` route** (existing command in features.js): Keep it working for backward compatibility, but add a note that `codebase impact` is the preferred command. Do NOT remove the old route — Phase 29 (WKFL-03) handles the transition.

Rebuild bundle via `node build.js`.
  </action>
  <verify>
```bash
# Build
node build.js 2>&1 | tail -5

# Test impact analysis on a core file
node bin/gsd-tools.cjs codebase impact src/lib/codebase-intel.js --raw 2>/dev/null | node -e "const d=JSON.parse(require('fs').readFileSync('/dev/stdin','utf8')); console.log('Fan-in:', d.files[0].fan_in, 'Direct:', d.files[0].direct_dependents.length)"

# Test cycle detection
node bin/gsd-tools.cjs codebase deps --cycles --raw 2>/dev/null | node -e "const d=JSON.parse(require('fs').readFileSync('/dev/stdin','utf8')); console.log('Cycles:', d.cycles ? d.cycles.cycle_count : 'N/A')"
```
  </verify>
  <done>
`codebase impact <file>` shows transitive dependents with fan-in count. `codebase deps --cycles` detects circular dependencies via Tarjan's SCC. Old `codebase-impact` route preserved for backward compatibility.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive test coverage for dependency graph features</name>
  <files>bin/gsd-tools.test.cjs</files>
  <action>
Add a new `describe('dependency graph', ...)` test block in `bin/gsd-tools.test.cjs` with the following test cases. Follow the existing test patterns (use `createCodebaseProject` helper from Phase 23 tests for git-initialized temp dirs):

**Import parser tests (6 tests):**
1. JS parser: `require('./foo')` and `import x from './bar'` → extracts `./foo` and `./bar`
2. TS parser: `import { Thing } from './types'` and `export { x } from './utils'` → extracts both
3. Python parser: `import os`, `from foo.bar import baz` → extracts `os` and `foo.bar`
4. Go parser: `import "fmt"` and multiline `import (` block → extracts paths
5. Elixir parser: `alias MyApp.Accounts`, `use GenServer`, `import Ecto.Query` → extracts module names
6. Rust parser: `use crate::lib::foo`, `mod bar`, `extern crate serde` → extracts paths

**Graph construction tests (3 tests):**
7. Build graph from simple project with 3 JS files that import each other → forward and reverse edges correct
8. Files with no imports → appear in graph with empty edge lists
9. Incremental: graph built from intel object (not filesystem) — verify adjacency list structure

**Cycle detection tests (3 tests):**
10. No cycles in linear chain (A→B→C) → `cycle_count: 0`
11. Simple cycle (A→B→A) → detected as cycle with both files
12. Complex cycle (A→B→C→A with D→B spur) → cycle detected, D not in cycle

**Impact analysis tests (2 tests):**
13. `getTransitiveDependents` on leaf file → `fan_in: 0`
14. `getTransitiveDependents` on core file (imported by multiple) → correct direct + transitive counts

For parser tests, test the parser functions directly (import from `src/lib/deps.js`). For graph/cycle/impact tests, construct mock intel objects with `files` entries and call `buildDependencyGraph`/`findCycles`/`getTransitiveDependents` directly.

Run full test suite to verify zero regressions.
  </action>
  <verify>
```bash
# Run full test suite
node bin/gsd-tools.test.cjs 2>&1 | tail -20

# Verify dependency graph tests specifically
node bin/gsd-tools.test.cjs 2>&1 | grep -A2 "dependency graph"
```
All tests pass, including new dependency graph tests. Zero regressions on existing tests.
  </verify>
  <done>
14 test cases covering import parsers (6 languages), graph construction, cycle detection, and impact analysis. Full test suite passes with zero regressions.
  </done>
</task>

</tasks>

<verification>
1. `codebase impact src/lib/codebase-intel.js --raw` returns JSON with fan_in > 0 and correct dependents
2. `codebase deps --cycles --raw` returns cycle analysis with `cycle_count` field
3. All tests pass (existing + 14 new dependency graph tests)
4. `getTransitiveDependents` correctly follows reverse edges through multiple levels
5. Tarjan's SCC correctly identifies cycles in the project (or reports 0 if none)
6. Bundle size within 700KB budget
7. Old `codebase-impact` CLI route still works (backward compatibility)
</verification>

<success_criteria>
- `codebase impact <file>` shows transitive dependents with fan-in count (DEPS-04)
- Cycle detection via Tarjan's SCC identifies circular dependencies (DEPS-05)
- >85% accuracy for JS/TS/Elixir import patterns verified by tests
- 14 test cases pass covering all dependency graph features
- Zero regressions on existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/25-dependency-graph/25-02-SUMMARY.md`
</output>
