---
phase: 24-convention-extraction
plan: 02
type: execute
wave: 2
depends_on: [24-01]
files_modified:
  - src/lib/conventions.js
  - src/commands/codebase.js
  - src/router.js
  - bin/gsd-tools.cjs
  - bin/gsd-tools.test.cjs
autonomous: true
requirements: [CONV-03, CONV-05]

must_haves:
  truths:
    - "Framework-specific patterns are detected for Elixir projects (Phoenix routes, Ecto schemas, plugs)"
    - "Pattern registry is extensible — new frameworks can be added by adding a detector object"
    - "User can run `codebase rules` and get an agent-consumable rules document capped at 15 rules"
    - "Rules document is formatted for direct injection into agent prompts"
  artifacts:
    - path: "src/lib/conventions.js"
      provides: "Framework pattern registry with Elixir detector, generateRules function"
      contains: "frameworkDetectors"
    - path: "src/commands/codebase.js"
      provides: "cmdCodebaseRules command handler"
      exports: ["cmdCodebaseRules"]
    - path: "bin/gsd-tools.test.cjs"
      provides: "Convention extraction tests"
      contains: "convention"
  key_links:
    - from: "src/lib/conventions.js"
      to: "src/lib/codebase-intel.js"
      via: "readIntel for file data + content analysis"
      pattern: "readIntel|walkSourceFiles"
    - from: "src/commands/codebase.js"
      to: "src/lib/conventions.js"
      via: "generateRules import"
      pattern: "generateRules|require.*conventions"
    - from: "src/router.js"
      to: "src/commands/codebase.js"
      via: "lazyCodebase() rules route"
      pattern: "rules"
---

<objective>
Add framework-specific pattern detection with an extensible registry (starting with Elixir/Phoenix) and the `codebase rules` command that generates a compact, agent-consumable conventions document capped at 15 rules.

Purpose: Give agents framework-aware conventions and a ready-to-inject rules document that prevents common pattern violations.
Output: Extended `src/lib/conventions.js` with framework detection + working `codebase rules` command + tests
</objective>

<execution_context>
@/home/cam/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/cam/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-convention-extraction/24-01-PLAN.md
@src/lib/conventions.js
@src/commands/codebase.js
@src/router.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Framework pattern registry + Elixir detector</name>
  <files>src/lib/conventions.js</files>
  <action>
Extend `src/lib/conventions.js` with framework-specific pattern detection.

**Framework detector registry (`FRAMEWORK_DETECTORS`):**
Create an array of detector objects, each with:
```js
{
  name: 'elixir-phoenix',
  detect: (intel) => boolean,  // Does this project use this framework?
  extractPatterns: (intel, cwd) => ConventionPattern[]  // Extract framework-specific patterns
}
```

**Elixir/Phoenix detector:**
- `detect`: Check if intel.languages has 'elixir' and file paths include `lib/*/router.ex` or `mix.exs`
- `extractPatterns` — detect these patterns by reading file content via `fs.readFileSync`:
  1. **Phoenix routes**: Find `router.ex` files, detect `pipe_through`, `get/post/put/delete/patch` macros. Convention: "Routes defined in router.ex using pipe_through pipelines"
  2. **Ecto schemas**: Find `*_schema.ex` or files containing `use Ecto.Schema`. Convention: "Ecto schemas use `schema` macro with `field` declarations"
  3. **Plugs**: Find files with `use Plug` or `import Plug.Conn`. Convention: "Plugs follow init/call pattern"
  4. **Context modules**: Detect `lib/*/` subdirectories that act as Phoenix contexts. Convention: "Business logic organized into context modules"
  5. **Migration naming**: Detect `priv/repo/migrations/` timestamps. Convention: "Migrations use timestamp prefixes"

Each pattern: `{ category: 'framework', framework: 'elixir-phoenix', pattern: string, confidence: number, evidence: string[] }`

Confidence for framework patterns: count files matching / total relevant files * 100.

**Integration:** Add `detectFrameworkConventions(intel, cwd)` that iterates FRAMEWORK_DETECTORS, runs detect(), then extractPatterns() for matches. Wire into `extractConventions()` so conventions output includes a `frameworks` section.

**Extensibility:** The registry is a simple array — adding a new framework means pushing a new detector object. Add a comment explaining this pattern for future contributors.
  </action>
  <verify>
Run on this project (JavaScript, no Elixir): `node -e "const c = require('./src/lib/conventions'); const intel = require('./src/lib/codebase-intel').readIntel(process.cwd()); const r = c.extractConventions(intel, { cwd: process.cwd() }); console.log('frameworks:', JSON.stringify(r.frameworks || 'none', null, 2))"` — should return no framework patterns (this project is JS, not Elixir).
Verify registry is exported: `node -e "const c = require('./src/lib/conventions'); console.log('has registry:', typeof c.FRAMEWORK_DETECTORS !== 'undefined')"` — should print true.
  </verify>
  <done>Framework detector registry exists with Elixir/Phoenix detector; extractConventions includes frameworks section; registry is extensible by pushing new detector objects</done>
</task>

<task type="auto">
  <name>Task 2: `codebase rules` command + tests</name>
  <files>src/commands/codebase.js, src/router.js, bin/gsd-tools.cjs, bin/gsd-tools.test.cjs</files>
  <action>
**In `src/lib/conventions.js` — add `generateRules(conventions, options)`:**

Takes the conventions output from `extractConventions()` and produces an agent-consumable rules document:
1. Rank all conventions by confidence (highest first)
2. Filter: only conventions with confidence >= threshold (default 60%)
3. Cap at 15 rules maximum
4. Format each rule as a concise, actionable statement:
   - "File names in `src/commands/` use kebab-case (98% of 12 files)"
   - "Test files are co-located with source using `.test.` suffix (85%)"
   - "Phoenix routes use `pipe_through` pipelines in router.ex (100%)"
5. Return: `{ rules: string[], rule_count: number, total_conventions: number, filtered_count: number }`
6. Also return a `rules_text` field: all rules joined with newlines, ready for direct prompt injection

Export `generateRules`.

**In `src/commands/codebase.js` — add `cmdCodebaseRules(cwd, args, raw)`:**

1. Read intel via `readIntel(cwd)` — if null, error
2. If intel has no `conventions` key, run `extractConventions` first (auto-detect on demand)
3. Import `generateRules` from conventions module
4. Parse flags: `--threshold N`, `--max N` (override 15 cap)
5. Call `generateRules(intel.conventions, { threshold, maxRules })`
6. Output JSON with `rules`, `rules_text`, `rule_count`
7. If `--raw`: output just `rules_text` (for direct pipe into prompts)

Export `cmdCodebaseRules`.

**In `src/router.js`:**

Add `rules` subcommand to codebase case:
```js
} else if (sub === 'rules') {
  lazyCodebase().cmdCodebaseRules(cwd, args.slice(2), raw);
}
```
Update error message to include `rules`.

**Tests in `bin/gsd-tools.test.cjs`:**

Add test block `describe('codebase conventions', ...)` with:
1. **Naming detection test**: Create temp dir with files named camelCase.js, snake_case.js, kebab-case.js — verify naming patterns detected correctly
2. **File org test**: Create nested temp dir structure — verify structure_type and test_placement detection
3. **Confidence scoring test**: Create dir with 9 snake_case files + 1 camelCase — verify snake_case confidence ≈ 90%
4. **Rules generation test**: Create conventions object, call generateRules — verify output has ≤15 rules, sorted by confidence
5. **Rules cap test**: Create conventions with 20+ patterns — verify output capped at 15
6. **CLI integration test**: Run `codebase conventions --raw` on temp project — verify JSON output structure

Use `createCodebaseProject` helper from existing test infrastructure (Phase 23) to set up temp dirs with git init.

**Bundle:** Rebuild bin/gsd-tools.cjs.
  </action>
  <verify>
Run: `node bin/gsd-tools.cjs codebase rules --raw 2>/dev/null` — should output rules text for this project.
Run: `node bin/gsd-tools.cjs codebase rules 2>/dev/null | python3 -c "import json,sys; d=json.load(sys.stdin); print(f'rules: {d[\"rule_count\"]}, capped: {d[\"rule_count\"] <= 15}')"` — should show rule count ≤ 15.
Run tests: `node bin/gsd-tools.test.cjs 2>&1 | tail -5` — all tests pass including new convention tests.
  </verify>
  <done>`codebase rules` command generates agent-consumable rules document capped at 15 rules; 6+ tests pass for convention extraction; CONV-03 and CONV-05 requirements met</done>
</task>

</tasks>

<verification>
1. `codebase conventions` shows framework patterns when run on an Elixir project (or returns empty frameworks for non-Elixir)
2. `codebase rules` outputs ≤15 rules sorted by confidence
3. `codebase rules --raw` outputs plain text suitable for prompt injection
4. Framework detector registry is extensible (array of detector objects)
5. All existing tests pass + new convention tests pass
6. Bundle size within 700KB budget
</verification>

<success_criteria>
- Framework-specific Elixir/Phoenix pattern detection works via extensible registry
- `codebase rules` produces compact, agent-consumable rules document
- Rules output capped at 15 rules maximum
- 6+ new tests covering naming, file-org, confidence, rules generation, cap, CLI
- CONV-03 and CONV-05 requirements addressed
</success_criteria>

<output>
After completion, create `.planning/phases/24-convention-extraction/24-02-SUMMARY.md`
</output>
