---
phase: 46-checkpoint-snapshot-metrics-collection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/commands/trajectory.js
  - src/router.js
  - src/lib/constants.js
  - bin/gsd-tools.test.cjs
autonomous: true
requirements: [CHKPT-01, CHKPT-03, CHKPT-04]

must_haves:
  truths:
    - "User can run `trajectory checkpoint <name>` and a git branch is created at trajectory/<scope>/<name>/attempt-N"
    - "Checkpoint creation auto-collects test count, cyclomatic complexity, and LOC delta without user intervention"
    - "A journal entry is written to the trajectories memory store recording the snapshot with metrics"
    - "Checkpoint branches follow trajectory/<scope>/<name>/attempt-N naming convention consistently"
  artifacts:
    - path: "src/commands/trajectory.js"
      provides: "Trajectory checkpoint command implementation"
      exports: ["cmdTrajectoryCheckpoint"]
    - path: "src/router.js"
      provides: "trajectory checkpoint routing"
      contains: "case 'trajectory'"
    - path: "src/lib/constants.js"
      provides: "trajectory command help text"
      contains: "trajectory checkpoint"
  key_links:
    - from: "src/commands/trajectory.js"
      to: "src/lib/git.js"
      via: "execGit for branch creation and diff-summary for LOC delta"
      pattern: "execGit.*checkout.*-b|diffSummary"
    - from: "src/commands/trajectory.js"
      to: "src/commands/memory.js"
      via: "trajectory store write for journal entry"
      pattern: "memory.*trajectories|trajectory\\.json"
    - from: "src/router.js"
      to: "src/commands/trajectory.js"
      via: "lazy-loaded command dispatch"
      pattern: "lazyTrajectory"
---

<objective>
Create the `trajectory checkpoint <name>` command that snapshots current git state as a named branch with auto-collected metrics (test count, complexity, LOC delta) stored as a trajectory journal entry.

Purpose: This is the primary capture mechanism for trajectory engineering — users create named save points during exploration so they can later pivot, compare, and choose between approaches.

Output: Working `trajectory checkpoint` CLI command with branch creation, metrics collection, and journal persistence.
</objective>

<execution_context>
@/home/cam/.config/oc/get-shit-done/workflows/execute-plan.md
@/home/cam/.config/oc/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/45-foundation-decision-journal-state-coherence/45-01-SUMMARY.md
@.planning/phases/45-foundation-decision-journal-state-coherence/45-02-SUMMARY.md
@src/lib/git.js
@src/commands/memory.js
@src/router.js
@src/lib/constants.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create trajectory checkpoint command with auto-metrics and branch creation</name>
  <files>src/commands/trajectory.js, src/router.js, src/lib/constants.js</files>
  <action>
Create a new command module `src/commands/trajectory.js` implementing `cmdTrajectoryCheckpoint(cwd, args, raw)`.

**Command signature:** `trajectory checkpoint <name> [--scope <scope>] [--description <text>]`

**Checkpoint flow:**
1. Parse args: `name` (required, positional after `checkpoint`), `--scope` (default: `"phase"`), `--description` (optional context text)
2. Validate: name must be non-empty alphanumeric with hyphens/underscores (no spaces/special chars). Error if dirty working tree has uncommitted changes (use `execGit(cwd, ['status', '--porcelain'])` — if stdout non-empty, error with "Uncommitted changes detected. Commit or stash before checkpointing.")
3. **Determine attempt number:** Read existing trajectory journal entries (read `.planning/memory/trajectory.json` directly via fs, filter by category `"checkpoint"` and matching scope+name), count existing attempts, next is `attempt-${count + 1}`
4. **Create branch:** `git branch trajectory/<scope>/<name>/attempt-<N>` at current HEAD (use `execGit(cwd, ['branch', branchName])` — do NOT checkout the branch, just create a ref). Verify branch was created.
5. **Collect metrics automatically:**
   - **Test count:** Run `node bin/gsd-tools.cjs test-run --cmd "npm test" --json` or simpler: run `npm test` via `execFileSync`, parse the output for pass/fail counts. Use a lightweight approach: run `execFileSync('node', ['--test', 'bin/gsd-tools.test.cjs'], { cwd, encoding: 'utf-8', stdio: 'pipe' })` in a try/catch, count lines matching `/^# tests (\d+)/`, `/^# pass (\d+)/`, `/^# fail (\d+)/`. If test run fails, still capture what we can (fail count matters too). Set a 120s timeout.
   - **LOC delta:** Use `diffSummary(cwd, { from: 'HEAD~5', to: 'HEAD' })` from git.js to get recent insertions/deletions. If `HEAD~5` doesn't exist (shallow), fall back to `HEAD~1`. Record `{ insertions, deletions, files_changed }`.
   - **Cyclomatic complexity:** Use a lightweight approach — count total JS source files and sum module complexities. Call `execFileSync('node', [path.join(cwd, 'bin/gsd-tools.cjs'), 'codebase', 'ast', filePath])` for key files (src/commands/*.js, src/lib/*.js). To keep it fast, only compute for files changed in the last 5 commits (from the LOC delta file list). Record `{ total_complexity, files_analyzed }`. If analysis fails for any file, skip it gracefully.
6. **Write journal entry:** Write to trajectory store via `fs` directly (same pattern as memory.js — read trajectory.json, append entry, write back). Entry structure:
   ```json
   {
     "id": "tj-XXXXXX",
     "timestamp": "ISO-8601",
     "category": "checkpoint",
     "text": "Checkpoint: <name> (attempt <N>)",
     "scope": "<scope>",
     "checkpoint_name": "<name>",
     "attempt": <N>,
     "branch": "trajectory/<scope>/<name>/attempt-<N>",
     "git_ref": "<HEAD SHA>",
     "description": "<user description or null>",
     "metrics": {
       "tests": { "total": N, "pass": N, "fail": N },
       "loc_delta": { "insertions": N, "deletions": N, "files_changed": N },
       "complexity": { "total": N, "files_analyzed": N }
     },
     "tags": ["checkpoint"]
   }
   ```
   Use `crypto.randomBytes(3).toString('hex')` for ID with collision detection (same pattern as memory.js).
7. **Output:** JSON result with `{ created: true, checkpoint: name, branch: branchName, attempt: N, git_ref: sha, metrics: {...} }`. With `--pretty`, render a formatted summary.

**Router integration (src/router.js):**
- Add lazy loader: `function lazyTrajectory() { return _modules.trajectory || (_modules.trajectory = require('./commands/trajectory')); }`
- Add case `'trajectory'` in the main switch, with subcommand routing:
  ```
  case 'trajectory': {
    const trajSub = args[1];
    switch (trajSub) {
      case 'checkpoint': lazyTrajectory().cmdTrajectoryCheckpoint(cwd, args.slice(1), raw); break;
      default: error('Unknown trajectory subcommand: ' + trajSub + '. Available: checkpoint');
    }
    break;
  }
  ```

**Constants (src/lib/constants.js):**
- Add trajectory command help text to COMMAND_HELP:
  ```
  'trajectory': 'Trajectory engineering commands\n  checkpoint <name>  Create named checkpoint with auto-metrics\n    --scope <scope>   Scope level (default: phase)\n    --description <text>  Optional context description'
  ```

**Important constraints:**
- Do NOT import from memory.js — read/write trajectory.json directly via fs (avoids circular dependencies and keeps the command self-contained)
- Reuse `crypto.randomBytes` pattern from memory.js for ID generation
- Use `execGit` from git.js for all git operations
- Metrics collection must be fault-tolerant — if any metric fails, still create the checkpoint with partial metrics
- Keep code compact to minimize bundle size impact (target <200 lines for trajectory.js)
  </action>
  <verify>
  ```bash
  npm run build && npm test
  # Manual verification:
  node bin/gsd-tools.cjs trajectory checkpoint test-checkpoint --scope phase
  # Should output JSON with created: true, branch name, metrics
  git branch | grep "trajectory/phase/test-checkpoint/attempt-1"
  # Clean up: git branch -D trajectory/phase/test-checkpoint/attempt-1
  ```
  </verify>
  <done>
  - `trajectory checkpoint <name>` creates a branch at `trajectory/<scope>/<name>/attempt-N`
  - Journal entry written to trajectory.json with metrics (tests, LOC delta, complexity)
  - Consecutive checkpoints with same name increment attempt number
  - Build passes within bundle budget, all existing tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Add trajectory checkpoint tests</name>
  <files>bin/gsd-tools.test.cjs</files>
  <action>
Add comprehensive tests for the trajectory checkpoint command in `bin/gsd-tools.test.cjs`.

**Test cases (target: 10-12 tests):**

1. **Basic checkpoint creation:** `trajectory checkpoint my-test` creates branch `trajectory/phase/my-test/attempt-1` and writes journal entry
2. **Custom scope:** `trajectory checkpoint my-test --scope task` creates branch `trajectory/task/my-test/attempt-1`
3. **Attempt numbering:** Create two checkpoints with same name/scope → second gets `attempt-2`
4. **Name validation:** `trajectory checkpoint ""` or `trajectory checkpoint "bad name!"` → error
5. **Missing name:** `trajectory checkpoint` with no name → error
6. **Journal entry structure:** Checkpoint creates entry with required fields (id, timestamp, category=checkpoint, scope, checkpoint_name, attempt, branch, git_ref, metrics)
7. **Metrics present:** Journal entry metrics object has `tests`, `loc_delta`, and `complexity` keys
8. **Branch naming convention:** Branch name matches `trajectory/<scope>/<name>/attempt-<N>` pattern exactly
9. **Description flag:** `trajectory checkpoint my-test --description "testing approach A"` → description field in journal entry
10. **Help text:** `trajectory --help` or unknown subcommand shows help

**Test approach:**
- Use the test helpers already in the test file (tmpDir pattern, execFileSync against bin/gsd-tools.cjs)
- For git operations, create a temporary git repo in test setup
- For metrics tests, the test count/complexity values don't need to be exact — just verify the structure exists and values are numbers
- Clean up branches and trajectory.json after each test

**Follow existing test patterns in the file** — look at memory store tests and git rewind tests for the setup/teardown pattern.
  </action>
  <verify>
  ```bash
  npm test 2>&1 | grep -E "checkpoint|trajectory"
  # All new tests should pass
  npm test 2>&1 | tail -5
  # Total test count should increase, 0 failures
  ```
  </verify>
  <done>
  - 10+ trajectory checkpoint tests pass
  - Tests cover: creation, scope, attempt numbering, validation, journal structure, metrics, branch naming
  - Total test suite passes with 0 failures
  - No existing tests broken
  </done>
</task>

</tasks>

<verification>
```bash
# Full verification sequence:
npm run build                    # Bundle within budget
npm test                         # All tests pass (existing + new)
node bin/gsd-tools.cjs trajectory checkpoint verify-test --scope phase
# Verify output has: created, branch, attempt, git_ref, metrics
cat .planning/memory/trajectory.json | node -e "const d=JSON.parse(require('fs').readFileSync('/dev/stdin','utf8')); const cp=d.filter(e=>e.category==='checkpoint'); console.log('Checkpoints:', cp.length); console.log('Has metrics:', !!cp[0]?.metrics)"
git branch | grep trajectory/phase/verify-test
# Cleanup
git branch -D trajectory/phase/verify-test/attempt-1 2>/dev/null
```
</verification>

<success_criteria>
- `trajectory checkpoint <name>` creates branch + journal entry with metrics
- Branch follows `trajectory/<scope>/<name>/attempt-N` convention
- Auto-metrics include test count, LOC delta, and complexity
- Attempt number increments correctly for repeated checkpoints
- 10+ tests pass covering all CHKPT-01, CHKPT-03, CHKPT-04 requirements
- Build passes, all existing tests unbroken
</success_criteria>

<output>
After completion, create `.planning/phases/46-checkpoint-snapshot-metrics-collection/46-01-SUMMARY.md`
</output>
