---
phase: 40-context-efficiency
plan: 02
type: execute
wave: 2
depends_on: ["40-01"]
files_modified:
  - src/lib/context.js
  - src/commands/codebase.js
  - src/router.js
  - src/lib/constants.js
  - bin/gsd-tools.test.cjs
autonomous: true
requirements: [CTX-04]

must_haves:
  truths:
    - "Task-scoped file injection loads only files relevant to the current task"
    - "Relevance scoring uses dependency graph, AST signatures, and plan scope"
    - "Context reduction is measurable — token savings reported in output"
    - "Quality baselines confirm scoped context doesn't lose critical information"
  artifacts:
    - path: "src/lib/context.js"
      provides: "buildTaskContext function for task-scoped file injection"
      exports: ["buildTaskContext"]
    - path: "src/commands/codebase.js"
      provides: "Enhanced codebase context command with --task flag"
  key_links:
    - from: "src/lib/context.js"
      to: "src/lib/deps.js"
      via: "dependency graph for relevance scoring"
      pattern: "buildDependencyGraph|readIntel"
    - from: "src/lib/context.js"
      to: "src/lib/ast.js"
      via: "AST signatures for compact file representation"
      pattern: "extractSignatures"
    - from: "src/commands/codebase.js"
      to: "src/lib/context.js"
      via: "buildTaskContext for --task flag"
      pattern: "buildTaskContext"
---

<objective>
Add task-scoped file injection that loads only task-relevant files using dependency graph + AST signatures + relevance scoring. Integrate with `codebase context` command via --task flag. Validate against quality baselines.

Purpose: During plan execution, agents currently load full codebase context. Task-scoped injection provides only files relevant to the specific task being worked on, reducing context consumption by 40-60% while maintaining decision quality.
Output: buildTaskContext in context.js, enhanced codebase context command, validation tests
</objective>

<execution_context>
@/home/cam/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/cam/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/40-context-efficiency/40-01-SUMMARY.md
@src/lib/context.js
@src/lib/ast.js
@src/lib/deps.js
@src/commands/codebase.js (lines 740-860 — scoreRelevance, enforceTokenBudget)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Task-scoped context builder + codebase context --task integration</name>
  <files>src/lib/context.js, src/commands/codebase.js, src/router.js, src/lib/constants.js</files>
  <action>
**In src/lib/context.js**, add:

**`buildTaskContext(cwd, taskFiles, options?)`** — Builds scoped context for a specific task:

Input:
- `cwd`: project root
- `taskFiles`: string[] — files listed in the task's files element
- `options.planFiles`: string[] — files from plan's files_modified (broader scope)
- `options.tokenBudget`: number — max tokens for output (default 3000)
- `options.includeSignatures`: boolean — include AST signatures (default true)

Algorithm:
1. Load dependency graph from codebase-intel.json via `readIntel(cwd)`. If unavailable, fall back to taskFiles only.
2. Build forward/reverse adjacency from dep graph edges
3. For each taskFile, find 1-hop dependencies (files that import it + files it imports)
4. Score all candidate files using existing `scoreRelevance` pattern:
   - Direct task file: 1.0
   - 1-hop dependency: 0.5-0.7 (imports get 0.7, importers get 0.5)
   - In plan's files_modified: +0.3
   - Recently modified (last 10 commits): +0.2
5. Filter to files scoring >= 0.3
6. For each included file, if includeSignatures is true:
   - Call `extractSignatures(filePath)` from ast.js to get compact representation
   - Include signature list instead of full file content
7. Enforce token budget — if over budget, drop lowest-scored files first
8. Return:
```js
{
  task_files: string[],           // The original task files
  context_files: [                // Scored relevant files
    { path: string, score: number, reason: string, signatures?: object[] }
  ],
  stats: {
    candidates_found: number,     // Total files considered
    files_included: number,       // Files in output
    files_excluded: number,       // Files dropped (below threshold or budget)
    token_estimate: number,       // Estimated tokens of output
    reduction_pct: number         // % reduction vs loading all candidates
  }
}
```

Keep this implementation lean — reuse `scoreRelevance` from codebase.js by importing it, or duplicate the small scoring function to avoid circular deps. Prefer duplication of the ~20-line scorer over adding complex imports.

**In src/commands/codebase.js — cmdCodebaseContext:**

Add `--task` flag support. When `--task <files...>` is provided (comma-separated file list):
- Call `buildTaskContext(cwd, taskFiles, { planFiles, tokenBudget })` 
- Output the task-scoped context instead of the full codebase context
- planFiles come from existing `--plan` flag
- tokenBudget comes from existing `--budget` flag

Example: `codebase context --task src/lib/ast.js,src/router.js --plan .planning/phases/38-*/38-01-PLAN.md --budget 2000`

**In src/lib/constants.js**, update codebase context COMMAND_HELP to document --task flag.

**BUNDLE SIZE:** Current is ~1009KB. Keep buildTaskContext under 80 lines. Reuse existing dep graph and AST functions — don't duplicate large logic. If bundle exceeds 1030KB, trim by removing debug logging strings or consolidating error messages.
  </action>
  <verify>
`npm run build` — bundle under 1030KB. `node bin/gsd-tools.cjs codebase context --task src/lib/ast.js --raw` returns task-scoped context with scores and stats.
  </verify>
  <done>
buildTaskContext returns scored file list with dependency-aware relevance. codebase context --task flag works. Token budget is respected. Stats show reduction percentage.
  </done>
</task>

<task type="auto">
  <name>Task 2: Tests + quality baseline validation</name>
  <files>bin/gsd-tools.test.cjs</files>
  <action>
Add tests (8-10 new):

**buildTaskContext tests:**
1. Single task file with known deps → returns task file + 1-hop deps scored
2. Multiple task files → union of dependencies, no duplicates
3. Token budget enforced → drops lowest-scored files when over budget
4. No codebase intel → graceful fallback returning just task files
5. includeSignatures=true → context_files have signatures array
6. Empty task files → returns empty context with zero stats

**Integration tests:**
7. `codebase context --task src/lib/output.js --raw` → returns JSON with context_files and stats
8. `codebase context --task src/lib/output.js --budget 500 --raw` → respects budget, fewer files
9. stats.reduction_pct > 0 (proves context was reduced vs all candidates)

**Quality baseline validation:**
10. For a known task (e.g., modifying src/lib/ast.js): verify that output includes its direct dependencies (src/lib/codebase-intel.js for LANGUAGE_MAP) and importers (src/commands/codebase.js). This proves the dep-graph traversal works correctly and critical context isn't lost.

Run `npm run build && npm test`.
  </action>
  <verify>
`npm run build && npm test` — all tests pass. Integration test shows measurable reduction (reduction_pct > 0).
  </verify>
  <done>
buildTaskContext tested with dep graph traversal, budget enforcement, fallback mode. Integration tests confirm CLI works end-to-end. Quality baseline validates critical dependencies are included. All tests pass.
  </done>
</task>

</tasks>

<verification>
- `node bin/gsd-tools.cjs codebase context --task src/lib/ast.js --raw` → task-scoped output
- `node bin/gsd-tools.cjs codebase context --task src/lib/ast.js --budget 1000 --raw` → budget-limited
- stats.reduction_pct > 30% for typical task files
- `npm test` passes all tests
</verification>

<success_criteria>
- Task-scoped file injection loads 1-hop dependencies via dep graph
- AST signatures provide compact file representation
- Token budget controls output size
- Quality validated — critical deps always included
</success_criteria>

<output>
After completion, create `.planning/phases/40-context-efficiency/40-02-SUMMARY.md`
</output>
