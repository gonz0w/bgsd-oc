---
phase: 04-build-system
plan: 02
type: execute
wave: 2
depends_on: [04-01]
files_modified: [build.js, bin/gsd-tools.cjs, bin/gsd-tools.test.cjs]
autonomous: true
requirements: [BUILD-02]

must_haves:
  truths:
    - "Source code in src/ follows strict router -> commands -> lib dependency direction"
    - "npm run build produces bin/gsd-tools.cjs from src/ modules"
    - "All existing tests pass against the bundled output"
    - "No circular imports between modules"
  artifacts:
    - path: "src/index.js"
      provides: "Entry point that imports router and runs main()"
      contains: "require"
    - path: "src/lib/helpers.js"
      provides: "Shared helpers (safeReadFile, debugLog, output, error, etc.)"
      contains: "module.exports"
    - path: "build.js"
      provides: "Updated build script pointing to src/index.js"
      contains: "src/index.js"
  key_links:
    - from: "src/index.js"
      to: "src/router.js"
      via: "require('./router')"
      pattern: "require\\('./router'\\)"
    - from: "src/router.js"
      to: "src/commands/"
      via: "require('./commands/')"
      pattern: "require\\('./commands/"
    - from: "src/commands/"
      to: "src/lib/"
      via: "require('../lib/')"
      pattern: "require\\('../lib/"
---

<objective>
Split the 7169-line monolith into organized src/ modules while keeping the build output identical.

Purpose: The single-file monolith is increasingly difficult to navigate and maintain. Splitting into modules with clear dependency directions makes the codebase manageable while the build system ensures the deployed artifact remains a single file.

Output: src/ directory structure with 15-20 modules, updated build.js entry point, all tests passing against bundled output.
</objective>

<execution_context>
@/home/cam/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/cam/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-build-system/04-01-SUMMARY.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/STRUCTURE.md
@.planning/research/SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create src/ module structure from monolith</name>
  <files>src/index.js, src/router.js, src/lib/helpers.js, src/lib/config.js, src/lib/frontmatter.js, src/lib/git.js, src/lib/output.js, src/lib/constants.js, src/commands/state.js, src/commands/roadmap.js, src/commands/phase.js, src/commands/verify.js, src/commands/init.js, src/commands/features.js, src/commands/misc.js</files>
  <action>
Split `bin/gsd-tools.cjs` into organized modules under `src/`. The existing file has clear section markers that map to modules:

**src/lib/ (shared internals — NO command logic):**

1. **src/lib/constants.js** — Extract `MODEL_PROFILES`, `CONFIG_SCHEMA`, `COMMAND_HELP` constants. Export all three.

2. **src/lib/output.js** — Extract `output()`, `error()`, `debugLog()` functions and the `_tmpFiles` tracking + cleanup handler. Export all three functions.

3. **src/lib/helpers.js** — Extract utility functions: `safeReadFile()`, `normalizePhaseName()`, `parseMustHavesBlock()`, `sanitizeShellArg()`, `isValidDateString()`, and any other pure utility helpers. Import from output.js for debugLog.

4. **src/lib/config.js** — Extract `loadConfig()` and the config-related helpers. Import CONFIG_SCHEMA from constants.js.

5. **src/lib/frontmatter.js** — Extract `extractFrontmatter()`, `reconstructFrontmatter()`, `spliceFrontmatter()`. These are self-contained parsers.

6. **src/lib/git.js** — Extract `execGit()` and git-related helpers. Import sanitizeShellArg from helpers.js.

**src/commands/ (command handlers — import from lib/):**

7. **src/commands/state.js** — Extract all `cmdState*` functions (lines ~1066-1424): cmdStateLoad, cmdStateGet, cmdStateUpdate, cmdStatePatch, cmdStateAdvancePlan, cmdStateRecordMetric, cmdStateUpdateProgress, cmdStateAddDecision, cmdStateAddBlocker, cmdStateResolveBlocker, cmdStateRecordSession. Import from lib/*.

8. **src/commands/roadmap.js** — Extract `cmdRoadmapGetPhase`, `cmdRoadmapAnalyze`, and related helpers (getMilestoneInfo, etc.).

9. **src/commands/phase.js** — Extract `cmdPhaseAdd`, `cmdPhaseInsert`, `cmdPhaseRemove`, `cmdPhaseComplete`, `cmdMilestoneComplete`, and related.

10. **src/commands/verify.js** — Extract all `cmdVerify*` functions.

11. **src/commands/init.js** — Extract all `cmdInit*` compound commands.

12. **src/commands/features.js** — Extract all feature commands (session-diff, context-budget, test-run, etc.).

13. **src/commands/misc.js** — Extract remaining commands: cmdCommit, cmdTemplateFill, cmdFrontmatter*, cmdConfigEnsureSection, cmdConfigSet, cmdConfigGet, cmdConfigMigrate, cmdGenerateSlug, cmdCurrentTimestamp, cmdListTodos, cmdVerifyPathExists, etc.

**src/router.js** — Extract the `main()` function's switch/case router. Import command functions from src/commands/*.

**src/index.js** — Entry point:
```javascript
const { main } = require('./router');
main();
```

**Key rules:**
- Every module uses `module.exports = { ... }` for exports
- Every import uses `require()`
- Dependency direction: `index → router → commands → lib` (never reverse)
- Commands never import from other command modules — only from lib/
- lib modules can import from other lib modules but no circular deps
- Keep the original `bin/gsd-tools.cjs` UNTOUCHED during this step — the split creates NEW files

**Process:**
1. Read the monolith carefully section by section
2. Create each module file, copying the relevant functions
3. Add proper require() imports at the top of each module
4. Add module.exports at the bottom
5. Ensure shared state (like `_tmpFiles` array) lives in one module and is imported by others that need it
  </action>
  <verify>
Run: `ls -R src/` — should show the module structure.
Run: `node -c src/index.js` — syntax check passes.
Run: `node -e "require('./src/lib/helpers')"` — module loads without error.
Run: `node -e "require('./src/lib/config')"` — module loads without error.
  </verify>
  <done>All source code is organized in src/ with proper module boundaries and require/export patterns. Original bin/gsd-tools.cjs is unchanged.</done>
</task>

<task type="auto">
  <name>Task 2: Update build.js and verify tests pass against bundled output</name>
  <files>build.js, bin/gsd-tools.cjs, bin/gsd-tools.test.cjs</files>
  <action>
1. Update `build.js` to point to the new entry point:
   - Change `entryPoints` from `['bin/gsd-tools.cjs']` to `['src/index.js']`
   - Change `outfile` from `'bin/gsd-tools.bundle.cjs'` to `'bin/gsd-tools.cjs'` (now the build OUTPUT, not the source)
   - Set `packages: 'external'` to keep Node builtins as require() calls
   - Keep `bundle: true` so all src/ modules are inlined

2. Run `npm run build` to produce the new `bin/gsd-tools.cjs` from src/ modules.

3. Run `npm test` — ALL existing tests must pass against the bundled output. The tests reference `bin/gsd-tools.cjs` which is now the build output. If any test fails, the module split introduced a bug that needs fixing.

4. Update the build system test from Plan 01 if needed — it may reference .bundle.cjs which no longer exists.

5. Verify:
   - `node bin/gsd-tools.cjs current-timestamp --raw` works
   - `node bin/gsd-tools.cjs state load --raw` works in this project directory
   - `node bin/gsd-tools.cjs state --help` works
   - `GSD_DEBUG=1 node bin/gsd-tools.cjs current-timestamp 2>&1 >/dev/null` shows no debug (no catch hit)

CRITICAL: If tests fail after the build, the module split has a bug. Fix the src/ modules until all tests pass. Do NOT modify test expectations — the tests define correct behavior.
  </action>
  <verify>
Run: `npm run build` — succeeds.
Run: `npm test` — 136+ pass, 1 fail (pre-existing only).
Run: `node bin/gsd-tools.cjs current-timestamp --raw` — outputs timestamp.
Run: `node bin/gsd-tools.cjs state --help 2>&1 | head -1` — shows help text.
  </verify>
  <done>Build output from src/ modules passes all existing tests. bin/gsd-tools.cjs is now a build artifact produced from src/ source modules.</done>
</task>

</tasks>

<verification>
1. `ls src/lib/*.js | wc -l` shows 6+ lib modules
2. `ls src/commands/*.js | wc -l` shows 7+ command modules
3. `npm run build` produces bin/gsd-tools.cjs from src/ entry point
4. `npm test` passes (136+ pass, 1 pre-existing fail)
5. No circular imports (verify by checking require patterns)
</verification>

<success_criteria>
- Source organized in src/ with lib/ and commands/ subdirectories
- Strict router → commands → lib dependency direction
- Build produces single-file output identical in behavior to monolith
- All existing tests pass against bundled output
</success_criteria>

<output>
After completion, create `.planning/phases/04-build-system/04-02-SUMMARY.md`
</output>
