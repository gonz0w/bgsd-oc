---
phase: 21-worktree-parallelism
plan: 03
type: execute
wave: 3
depends_on: [21-01, 21-02]
files_modified:
  - workflows/execute-phase.md
  - src/commands/init.js
  - src/router.js
  - bin/gsd-tools.test.cjs
  - bin/gsd-tools.cjs
autonomous: true
requirements: [WKTR-05]

must_haves:
  truths:
    - "Execute-phase workflow creates worktrees for each plan in a parallel wave"
    - "Agents spawn in worktree directories with isolated working copies"
    - "After all wave agents complete, merges happen sequentially with conflict pre-check"
    - "Failed merges reported with options: resolve manually, skip plan, abort wave"
    - "Worktrees cleaned up after successful wave completion before advancing"
    - "Live status updates show which agents are running and their progress"
  artifacts:
    - path: "workflows/execute-phase.md"
      provides: "Worktree-aware parallel execution with merge-back"
      contains: "worktree create"
    - path: "src/commands/init.js"
      provides: "init execute-phase includes worktree config and status"
      contains: "worktree"
  key_links:
    - from: "workflows/execute-phase.md"
      to: "src/commands/worktree.js"
      via: "CLI calls to worktree create, merge, cleanup"
      pattern: "worktree (create|merge|cleanup|check-overlap)"
    - from: "src/commands/init.js"
      to: "src/commands/worktree.js"
      via: "init execute-phase reads worktree config and active worktrees"
      pattern: "worktree|cmdWorktreeList"
---

<objective>
Integrate worktree parallelism into the execute-phase workflow and init command. When parallelization is enabled and worktree config is active, wave execution creates isolated worktrees, spawns agents in them, and merges back sequentially.

Purpose: This is the capstone — connects the worktree lifecycle and merge infrastructure into the actual execution flow that users interact with.
Output: Updated execute-phase.md workflow with worktree paths, init command with worktree context, tests.
</objective>

<execution_context>
@/home/cam/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/cam/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/21-worktree-parallelism/21-CONTEXT.md
@.planning/phases/21-worktree-parallelism/21-01-SUMMARY.md
@.planning/phases/21-worktree-parallelism/21-02-SUMMARY.md
@workflows/execute-phase.md (current workflow to modify)
@src/commands/init.js (cmdInitExecutePhase to extend)
@src/commands/worktree.js (worktree commands from Plans 01-02)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Init command worktree context + execute-phase workflow integration</name>
  <files>
    src/commands/init.js
    src/router.js
    workflows/execute-phase.md
  </files>
  <action>
**Part A — Extend `cmdInitExecutePhase` in `src/commands/init.js`:**

Add worktree-related fields to the init execute-phase JSON output:

```javascript
// After existing init fields, add:
worktree_enabled: config.worktree?.enabled || false,
worktree_config: {
  base_path: config.worktree?.base_path || '/tmp/gsd-worktrees',
  sync_files: config.worktree?.sync_files || ['.env', '.env.local', '.planning/config.json'],
  setup_hooks: config.worktree?.setup_hooks || [],
  max_concurrent: config.worktree?.max_concurrent || 3,
},
worktree_active: [],  // populated from worktree list if enabled
```

When `worktree_enabled` is true:
- Call internal worktree list logic to get active worktrees
- Include them in `worktree_active` array
- Include pre-computed overlap analysis: run check-overlap logic for the phase and include `file_overlaps` in output

**Part B — Update `workflows/execute-phase.md`:**

Modify the `execute_waves` step to support worktree-based parallel execution. The key change: when `worktree_enabled` AND `parallelization` are both true, the workflow uses worktrees instead of running agents in the same working directory.

**New step: `preflight_worktree_check`** (after `preflight_state_validation`, before `discover_and_group_plans`):

```
<step name="preflight_worktree_check">
If `worktree_enabled` false: skip.

Check file_overlaps from init JSON. If overlaps exist within a wave:
- Display overlap table: | Plan A | Plan B | Shared Files | Wave |
- In yolo/auto mode: log warning, proceed (git merge-tree will catch real conflicts)
- In interactive mode: ask "Proceed with overlap risk?" or "Adjust wave grouping?"

Check disk space: estimate project_size * max_concurrent, warn if tight.

Display:
```
◆ Worktree parallelism: enabled
  Base: {base_path}
  Max concurrent: {max_concurrent}
  File overlaps: {count} (advisory)
```
</step>
```

**Modify `execute_waves` step — add worktree branch:**

When `worktree_enabled` and wave has >1 plan:

1. **Create worktrees** for each plan in wave:
   ```bash
   node gsd-tools.cjs worktree create {plan_id}
   ```

2. **Spawn executor agents** — change the `cwd` context to point to worktree path:
   - In the Task() spawn, add `workdir: {worktree_path}` so the agent operates in the isolated worktree
   - Pass the worktree path in the prompt so the agent knows it's running in a worktree
   - The agent reads PLAN.md from the worktree's `.planning/` directory (synced during create)

3. **Monitor progress** — per CONTEXT.md "live status updates while agents run":
   - After spawning all agents in a wave, periodically (every 30s or between Task returns) display:
     ```
     ◆ Wave {N} progress:
       ┌─ {plan_id}: ◆ running ({elapsed}m)
       ├─ {plan_id}: ✓ complete (SUMMARY.md found)
       └─ {plan_id}: ◆ running ({elapsed}m)
     ```
   - Detection: check if `{worktree_path}/.planning/phases/{phase_dir}/{plan_id}-SUMMARY.md` exists

4. **Wait for all agents** (per CONTEXT.md: "let all agents finish even if one fails"):
   - Collect results from all Task() returns
   - Separate: successes (SUMMARY.md exists) and failures

5. **Sequential merge** (per CONTEXT.md decisions):
   - For each completed plan (in plan-number order — the agent's discretion area):
     ```bash
     node gsd-tools.cjs worktree merge {plan_id}
     ```
   - After EACH merge: optionally run test command if configured in config.json
   - If merge fails (conflicts): display conflict report, offer options per CONTEXT.md:
     a. "Resolve manually" → present files, wait for user to fix and type "done"
     b. "Skip this plan" → mark plan as merge-failed, continue to next
     c. "Abort wave" → stop merging, report what succeeded

6. **Cleanup** — after all merges (or after failure handling):
   ```bash
   node gsd-tools.cjs worktree cleanup
   ```

7. **Continue** to next wave as normal.

When `worktree_enabled` is false OR wave has only 1 plan → existing behavior unchanged (spawn agent in main working directory).

Per CONTEXT.md "Agent's Discretion" areas:
- Branch naming: `worktree-{phase}-{plan}-{wave}` (handled by worktree create)
- Merge ordering: plan number order (smallest first, predictable)
- Completion signaling: SUMMARY.md existence check (simplest, already the pattern)
- Test after merge: run test command from config if set, otherwise skip
- Test failure handling: warn and continue (don't revert — reversing merges is risky)
  </action>
  <verify>
- `node bin/gsd-tools.cjs init execute-phase 21 --compact 2>/dev/null` includes `worktree_enabled`, `worktree_config`, `worktree_active` fields
- `workflows/execute-phase.md` contains `preflight_worktree_check` step
- `workflows/execute-phase.md` contains worktree create/merge/cleanup flow in execute_waves
- Existing single-plan wave behavior unchanged (grep for "worktree_enabled" guard)
  </verify>
  <done>Execute-phase workflow has complete worktree-based parallel execution: create → spawn in worktree → monitor → merge sequentially → cleanup. Init command provides worktree config and status. Graceful degradation when worktrees disabled.</done>
</task>

<task type="auto">
  <name>Task 2: Integration tests for workflow + init changes</name>
  <files>
    bin/gsd-tools.test.cjs
  </files>
  <action>
Add integration tests for the init command worktree extensions.

**Tests for `init execute-phase` worktree fields:**

1. **Worktree fields present when enabled:**
   - Create test project with `config.json` containing `worktree: { enabled: true, ... }`
   - Run init execute-phase → output includes `worktree_enabled: true`, `worktree_config` object
   
2. **Worktree fields present when disabled (defaults):**
   - Create test project without worktree config
   - Run init execute-phase → output includes `worktree_enabled: false`, `worktree_config` with defaults

3. **File overlap detection in init output:**
   - Create two PLAN.md files in same wave with overlapping files_modified
   - Run init execute-phase → `file_overlaps` array is non-empty

4. **No overlap when plans are in different waves:**
   - Create PLAN.md files in different waves with same files_modified
   - Run init execute-phase → `file_overlaps` empty

5. **Active worktrees included when they exist:**
   - Create a worktree, then run init execute-phase
   - `worktree_active` includes the created worktree

**Tests for worktree-specific edge cases:**

6. **Init graceful when base_path doesn't exist yet:**
   - Point base_path to non-existent dir → init still succeeds (dir created on worktree create, not init)

7. **Config validation surfaces max_concurrent:**
   - Set max_concurrent to value → appears in init output correctly

Run: `node --test bin/gsd-tools.test.cjs` — all tests pass.
  </action>
  <verify>
- `node --test bin/gsd-tools.test.cjs 2>&1 | tail -5` shows 0 failures
- At least 7 new test cases for init worktree integration
  </verify>
  <done>Init execute-phase returns worktree config, active worktrees, and file overlap analysis. All tests pass, zero regressions.</done>
</task>

</tasks>

<verification>
- `node build.js` succeeds within budget
- `node --test bin/gsd-tools.test.cjs` — all tests pass
- init execute-phase output has all worktree fields
- execute-phase.md workflow has complete worktree lifecycle in execute_waves step
- Single-plan waves and worktree-disabled mode still work as before
</verification>

<success_criteria>
- Execute-phase creates worktrees per wave when enabled
- Agents spawn in worktree directories with isolated working copies
- Sequential merge with conflict pre-check after wave completion
- Failed merges offer resolve/skip/abort options
- Cleanup after wave before advancing to next
- Init command provides worktree config and active worktree status
- Graceful degradation: everything works exactly as before when worktrees disabled
</success_criteria>

<output>
After completion, create `.planning/phases/21-worktree-parallelism/21-03-SUMMARY.md`
</output>
