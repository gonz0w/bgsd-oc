#!/usr/bin/env node
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/lib/constants.js
var require_constants = __commonJS({
  "src/lib/constants.js"(exports2, module2) {
    var MODEL_PROFILES = {
      "gsd-planner": { quality: "opus", balanced: "opus", budget: "sonnet" },
      "gsd-roadmapper": { quality: "opus", balanced: "sonnet", budget: "sonnet" },
      "gsd-executor": { quality: "opus", balanced: "sonnet", budget: "sonnet" },
      "gsd-phase-researcher": { quality: "opus", balanced: "sonnet", budget: "haiku" },
      "gsd-project-researcher": { quality: "opus", balanced: "sonnet", budget: "haiku" },
      "gsd-research-synthesizer": { quality: "sonnet", balanced: "sonnet", budget: "haiku" },
      "gsd-debugger": { quality: "opus", balanced: "sonnet", budget: "sonnet" },
      "gsd-codebase-mapper": { quality: "sonnet", balanced: "haiku", budget: "haiku" },
      "gsd-verifier": { quality: "sonnet", balanced: "sonnet", budget: "haiku" },
      "gsd-plan-checker": { quality: "sonnet", balanced: "sonnet", budget: "haiku" },
      "gsd-integration-checker": { quality: "sonnet", balanced: "sonnet", budget: "haiku" }
    };
    var CONFIG_SCHEMA = {
      model_profile: { type: "string", default: "balanced", description: "Active model profile (quality/balanced/budget)", aliases: [], nested: null },
      commit_docs: { type: "boolean", default: true, description: "Auto-commit planning docs", aliases: [], nested: { section: "planning", field: "commit_docs" } },
      search_gitignored: { type: "boolean", default: false, description: "Include gitignored files in searches", aliases: [], nested: { section: "planning", field: "search_gitignored" } },
      branching_strategy: { type: "string", default: "none", description: "Git branching strategy", aliases: [], nested: { section: "git", field: "branching_strategy" } },
      phase_branch_template: { type: "string", default: "gsd/phase-{phase}-{slug}", description: "Phase branch name template", aliases: [], nested: { section: "git", field: "phase_branch_template" } },
      milestone_branch_template: { type: "string", default: "gsd/{milestone}-{slug}", description: "Milestone branch name template", aliases: [], nested: { section: "git", field: "milestone_branch_template" } },
      research: { type: "boolean", default: true, description: "Enable research phase", aliases: ["research_enabled"], nested: { section: "workflow", field: "research" } },
      plan_checker: { type: "boolean", default: true, description: "Enable plan checking", aliases: [], nested: { section: "workflow", field: "plan_check" } },
      verifier: { type: "boolean", default: true, description: "Enable verification phase", aliases: [], nested: { section: "workflow", field: "verifier" } },
      parallelization: { type: "boolean", default: true, description: "Enable parallel plan execution", aliases: [], nested: null, coerce: "parallelization" },
      brave_search: { type: "boolean", default: false, description: "Enable Brave Search API", aliases: [], nested: null },
      mode: { type: "string", default: "interactive", description: "Execution mode (interactive or yolo)", aliases: [], nested: null },
      model_profiles: { type: "object", default: {}, description: "Model assignments per agent", aliases: [], nested: null },
      depth: { type: "string", default: "standard", description: "Planning depth", aliases: [], nested: null },
      test_commands: { type: "object", default: {}, description: "Test commands by framework", aliases: [], nested: null },
      test_gate: { type: "boolean", default: true, description: "Block plan completion on test failure", aliases: [], nested: null },
      context_window: { type: "number", default: 2e5, description: "Context window size in tokens", aliases: [], nested: null },
      context_target_percent: { type: "number", default: 50, description: "Target context utilization percent (1-100)", aliases: [], nested: null }
    };
    var COMMAND_HELP = {
      "state": `Usage: gsd-tools state <subcommand> [options]

Manage project state in STATE.md.

Subcommands:
  load | get <field> | update <field> <value> | patch --key value ...
  advance-plan | update-progress
  record-metric --phase P --plan N --duration D [--tasks T] [--files F]
  add-decision --phase P --summary S [--rationale R]
  add-blocker --text "..." | resolve-blocker --text "..."
  record-session --stopped-at "..." [--resume-file path]
  validate [--fix]`,
      "state validate": `Usage: gsd-tools state validate [--fix]

Validate state vs disk reality: plan counts, position, activity staleness.
--fix auto-corrects plan count mismatches. Pre-flight in execute-phase.`,
      "frontmatter": `Usage: gsd-tools frontmatter <subcommand> <file> [options]

CRUD operations on YAML frontmatter in markdown files.

Subcommands:
  get <file> [--field key]        Extract frontmatter as JSON
  set <file> --field k --value v  Update single frontmatter field
  merge <file> --data '{json}'    Merge JSON into frontmatter
  validate <file> --schema type   Validate required fields
    Schema types: plan, summary, verification

Examples:
  gsd-tools frontmatter get plan.md
  gsd-tools frontmatter set plan.md --field wave --value 2`,
      "verify": `Usage: gsd-tools verify <subcommand> [args]

Verification suite for planning documents.

Subcommands:
  plan-structure <file>        Check PLAN.md structure + tasks
  phase-completeness <phase>   Check all plans have summaries
  references <file>            Check @-refs and paths resolve
  commits <h1> [h2] ...       Batch verify commit hashes exist
  artifacts <plan-file>        Check must_haves.artifacts from plan
  key-links <plan-file>        Check must_haves.key_links from plan
  analyze-plan <plan-file>     Analyze plan complexity, SR score, split suggestions
  deliverables [--plan file]   Run tests + verify plan deliverables
  requirements                 Check REQUIREMENTS.md coverage
  regression [--before f] [--after f]  Detect test regressions
  plan-wave <phase-dir>        Check for file conflicts within waves
  plan-deps <phase-dir>        Check dependency graph for cycles/issues
  quality [--plan f] [--phase N]  Composite quality score with trend

Examples:
  gsd-tools verify plan-structure .planning/phases/01-foundation/01-01-PLAN.md
  gsd-tools verify phase-completeness 01
  gsd-tools verify analyze-plan .planning/phases/12-quality/12-03-PLAN.md
  gsd-tools verify deliverables --plan .planning/phases/01/01-01-PLAN.md
  gsd-tools verify requirements
  gsd-tools verify regression --before before.json --after after.json
  gsd-tools verify plan-wave .planning/phases/12-quality
  gsd-tools verify plan-deps .planning/phases/12-quality`,
      "verify deliverables": `Usage: gsd-tools verify deliverables [--plan <file>]

Run project tests and optionally verify plan deliverables (artifacts + key_links).

Auto-detects test framework: package.json \u2192 npm test, mix.exs \u2192 mix test, go.mod \u2192 go test ./...
Override via config.json test_commands.

Options:
  --plan <file>   Plan file to check must_haves.artifacts and key_links

Output: { test_result, tests_passed, tests_failed, tests_total, framework, verdict }

Examples:
  gsd-tools verify deliverables
  gsd-tools verify deliverables --plan .planning/phases/01-foundation/01-01-PLAN.md`,
      "verify requirements": `Usage: gsd-tools verify requirements

Check REQUIREMENTS.md coverage. Parses requirement checkboxes and traceability table.
A requirement is "addressed" if marked [x] or its mapped phase has SUMMARY.md files.

Output: { total, addressed, unaddressed, unaddressed_list }

Examples:
  gsd-tools verify requirements`,
      "verify regression": `Usage: gsd-tools verify regression [--before <file>] [--after <file>]

Detect test regressions by comparing before/after test result files.
Each file: { tests: [{name, status: "pass"|"fail"}] }

Without --before/--after, checks .planning/memory/test-baseline.json.

Output: { regressions, regression_count, verdict }

Examples:
  gsd-tools verify regression --before baseline.json --after current.json`,
      "verify quality": `Usage: gsd-tools verify quality [--plan <file>] [--phase <N>]

Composite quality score (tests 30%, must_haves 30%, requirements 20%, regression 20%).
Grade: A(90+) B(80+) C(70+) D(60+) F(<60). Trend tracking via quality-scores.json.`,
      "roadmap": `Usage: gsd-tools roadmap <subcommand> [args]

Roadmap operations.

Subcommands:
  get-phase <phase>            Extract phase section from ROADMAP.md
  analyze                      Full roadmap parse with disk status
  update-plan-progress <N>     Update progress table row from disk

Examples:
  gsd-tools roadmap analyze
  gsd-tools roadmap update-plan-progress 03`,
      "phase": `Usage: gsd-tools phase <subcommand> [args]

Phase lifecycle operations.

Subcommands:
  next-decimal <phase>         Calculate next decimal phase number
  add <description>            Append new phase to roadmap + create dir
  insert <after> <description> Insert decimal phase after existing
  remove <phase> [--force]     Remove phase, renumber subsequent
  complete <phase>             Mark phase done, update state + roadmap

Examples:
  gsd-tools phase add "Performance Optimization"
  gsd-tools phase complete 02`,
      "milestone": `Usage: gsd-tools milestone <subcommand> [args]

Milestone lifecycle operations.

Subcommands:
  complete <version>           Archive milestone, create MILESTONES.md
    [--name <name>]
    [--archive-phases]         Move phase dirs to milestones/vX.Y-phases/

Examples:
  gsd-tools milestone complete v1.0 --name "Initial Release" --archive-phases`,
      "init": `Usage: gsd-tools init <workflow> [args] [--compact]

Compound initialization commands for workflows.

Workflows:
  execute-phase <phase>   All context for execute-phase workflow
  plan-phase <phase>      All context for plan-phase workflow
  new-project             All context for new-project workflow
  new-milestone           All context for new-milestone workflow
  quick <description>     All context for quick workflow
  resume                  All context for resume-project workflow
  verify-work <phase>     All context for verify-work workflow
  phase-op <phase>        Generic phase operation context
  todos [area]            All context for todo workflows
  milestone-op            Milestone operation context
  map-codebase            Codebase mapping context
  progress                Progress overview
  memory [options]        Session memory digest with codebase knowledge

Flags:
  --compact   Return essential-only fields (38-50% smaller)
  --manifest  Include context manifest with --compact (adds file loading guidance)
  --agent=<type>  Scope output to agent's declared context (e.g. --agent=gsd-executor)

Examples:
  gsd-tools init execute-phase 03
  gsd-tools init progress --compact
  gsd-tools init progress --compact --manifest`,
      "init memory": `Usage: gsd-tools init memory [--workflow <name>] [--phase <N>] [--compact]
Session memory digest: position, bookmarks, decisions, lessons, codebase knowledge.
Workflows: execute-phase, plan-phase, execute-plan, quick, resume, verify-work, progress.`,
      "commit": `Usage: gsd-tools commit <message> [--files f1 f2 ...] [--amend] [--agent <type>] [--tdd-phase red|green|refactor]

Commit planning documents to git.

Arguments:
  message              Commit message (required)
  --files f1 f2        Specific files to stage (default: all .planning/ changes)
  --amend              Amend the previous commit instead of creating new
  --agent <type>       Add Agent-Type git trailer for attribution
  --tdd-phase <phase>  Add GSD-Phase trailer (red, green, or refactor)

Examples:
  gsd-tools commit "docs(03-01): add help system" --files .planning/STATE.md
  gsd-tools commit "test(43-01): failing test" --tdd-phase red --files src/`,
      "template": `Usage: gsd-tools template <subcommand> [options]

Template operations for planning documents.

Subcommands:
  select <type>              Select a template for the given type
  fill <type> [options]      Create pre-filled template document
    Types: summary, plan, verification
    --phase N   Phase number
    --plan M    Plan number
    --name "..."  Document name
    --type execute|tdd  Plan type (for plan templates)
    --wave N    Wave number
    --fields '{json}'   Additional fields

Examples:
  gsd-tools template fill summary --phase 03 --plan 01 --name "Help System"`,
      "config-ensure-section": `Usage: gsd-tools config-ensure-section

Initialize .planning/config.json with default values from CONFIG_SCHEMA.
Detects Brave Search API key availability and applies user-level defaults
from ~/.gsd/defaults.json if present. No-op if config already exists.`,
      "config-set": `Usage: gsd-tools config-set <key.path> <value>

Set a configuration value in .planning/config.json.
Supports dot-notation for nested keys.

Arguments:
  key.path   Key path using dot notation (e.g., workflow.research)
  value      Value to set (booleans and numbers auto-parsed)

Examples:
  gsd-tools config-set model_profile quality
  gsd-tools config-set workflow.research false`,
      "config-get": `Usage: gsd-tools config-get <key.path>

Get a configuration value from .planning/config.json.
Supports dot-notation for nested keys.

Arguments:
  key.path   Key path using dot notation (e.g., workflow.research)

Examples:
  gsd-tools config-get model_profile
  gsd-tools config-get workflow.research`,
      "config-migrate": `Usage: gsd-tools config-migrate

Migrate .planning/config.json to include any new CONFIG_SCHEMA keys.
Adds missing keys with default values. Creates backup before writing.

Examples:
  gsd-tools config-migrate`,
      "generate-slug": `Usage: gsd-tools generate-slug <text>

Convert text to a URL-safe slug (lowercase, hyphens, no special chars).

Arguments:
  text   Text to convert

Examples:
  gsd-tools generate-slug "Developer Experience"
  # Output: developer-experience`,
      "current-timestamp": `Usage: gsd-tools current-timestamp [format]

Returns the current UTC timestamp.

Formats:
  full       ISO 8601 (default): 2026-02-22T14:30:00Z
  date       Date only: 2026-02-22
  filename   Filename-safe: 2026-02-22_143000

Examples:
  gsd-tools current-timestamp
  gsd-tools current-timestamp date`,
      "list-todos": `Usage: gsd-tools list-todos [area]

Count and enumerate pending todos from planning documents.

Arguments:
  area   Optional area filter (e.g., phase name)

Examples:
  gsd-tools list-todos`,
      "verify-path-exists": `Usage: gsd-tools verify-path-exists <path>

Check if a file or directory exists relative to project root.

Arguments:
  path   Relative path to check

Examples:
  gsd-tools verify-path-exists .planning/config.json`,
      "session-diff": `Usage: gsd-tools session-diff

Show git commits since last recorded session activity.
Uses the last activity date from STATE.md to find recent commits.

Output: { commits, since_date, count }`,
      "session-summary": `Usage: gsd-tools session-summary

Session handoff summary: position, activity, next action, continuity.
Output: { current_position, session_activity, next_action, session_continuity }`,
      "context-budget": `Usage: gsd-tools context-budget <subcommand|path> [options]

Measure and compare token consumption across GSD workflows.

Subcommands:
  <path>                    Estimate tokens for a single file (existing behavior)
  baseline                  Measure all workflows, save baseline to .planning/baselines/
  compare [baseline-path]   Compare current vs saved baseline (default: most recent)

Options:
  --fields <fields>         Return only specified JSON fields (comma-separated)
  --pretty                  Force human-readable output when piped

Examples:
  gsd-tools context-budget .planning/ROADMAP.md
  gsd-tools context-budget baseline
  gsd-tools context-budget compare
  gsd-tools context-budget compare .planning/baselines/baseline-2026-02-22.json`,
      "test-run": `Usage: gsd-tools test-run

Run project test commands (from config.json test_commands) and parse output.
Supports ExUnit, Go test, and pytest output formats.
Returns structured pass/fail results with test_gate enforcement.`,
      "search-decisions": `Usage: gsd-tools search-decisions <query>

Search for decisions in STATE.md and archived milestone states.

Arguments:
  query   Search term (case-insensitive substring match)

Examples:
  gsd-tools search-decisions "esbuild"`,
      "validate-dependencies": `Usage: gsd-tools validate-dependencies <phase>

Validate the dependency graph for plans in a phase.
Checks that depends_on references exist and are acyclic.

Arguments:
  phase   Phase number to validate

Examples:
  gsd-tools validate-dependencies 03`,
      "search-lessons": `Usage: gsd-tools search-lessons <query>

Search tasks/lessons.md for matching entries.

Arguments:
  query   Search term (case-insensitive)

Examples:
  gsd-tools search-lessons "frontmatter"`,
      "codebase-impact": `Usage: gsd-tools codebase-impact <files...>

Show module dependencies for the given files.
Reads Elixir defmodule/import/use/alias statements and reports dependents.

Arguments:
  files   One or more file paths to analyze

Examples:
  gsd-tools codebase-impact lib/my_app/accounts.ex`,
      "rollback-info": `Usage: gsd-tools rollback-info <plan-id>

Show commits associated with a plan and the git revert command to undo them.

Arguments:
  plan-id   Plan identifier (e.g., 03-01)

Examples:
  gsd-tools rollback-info 02-01`,
      "velocity": `Usage: gsd-tools velocity

Calculate planning velocity: plans/day, completion forecast, and trend.
Reads execution metrics from STATE.md performance table.`,
      "trace-requirement": `Usage: gsd-tools trace-requirement <req-id>

Full traceability from requirement to files on disk.
Traces through REQUIREMENTS.md \u2192 PLAN.md \u2192 SUMMARY.md \u2192 actual files.

Arguments:
  req-id   Requirement identifier (e.g., DX-01)

Examples:
  gsd-tools trace-requirement FOUND-01`,
      "validate-config": `Usage: gsd-tools validate-config

Schema validation and typo detection for .planning/config.json.
Checks all keys against CONFIG_SCHEMA, reports unknown keys and type mismatches.`,
      "quick-summary": `Usage: gsd-tools quick-summary

Milestone progress summary showing quick task status.`,
      "validate": `Usage: gsd-tools validate <subcommand> [options]

Validation commands.

Subcommands:
  consistency            Check phase numbering, disk/roadmap sync
  health [--repair]      Check .planning/ integrity, optionally repair

Examples:
  gsd-tools validate consistency
  gsd-tools validate health --repair`,
      "progress": `Usage: gsd-tools progress [format]

Render progress in various formats.

Formats:
  json    JSON output (default)
  table   ASCII table
  bar     Progress bar only

Examples:
  gsd-tools progress table
  gsd-tools progress bar`,
      "todo": `Usage: gsd-tools todo <subcommand> [args]

Todo management.

Subcommands:
  complete <filename>    Move todo from pending to completed

Examples:
  gsd-tools todo complete my-task.md`,
      "scaffold": `Usage: gsd-tools scaffold <type> [options]

Create scaffolded planning documents.

Types:
  context --phase N          Create CONTEXT.md template
  uat --phase N              Create UAT.md template
  verification --phase N     Create VERIFICATION.md template
  phase-dir --phase N --name "..."  Create phase directory

Examples:
  gsd-tools scaffold context --phase 03
  gsd-tools scaffold phase-dir --phase 04 --name "Build System"`,
      "phases": `Usage: gsd-tools phases list [options]

List phase directories with metadata.

Options:
  --type <type>          Filter by type (e.g., plan, summary)
  --phase <N>            Filter by phase number
  --include-archived     Include archived milestone phases

Examples:
  gsd-tools phases list
  gsd-tools phases list --phase 03`,
      "requirements": `Usage: gsd-tools requirements <subcommand> [args]

Requirements traceability operations.

Subcommands:
  mark-complete <ids>    Mark requirement IDs as complete
    Accepts: REQ-01,REQ-02 or REQ-01 REQ-02 or [REQ-01, REQ-02]

Examples:
  gsd-tools requirements mark-complete DX-01 DX-03`,
      "find-phase": `Usage: gsd-tools find-phase <phase>

Find a phase directory by number, returning its path and metadata.

Arguments:
  phase   Phase number (e.g., 03, 02.1)

Examples:
  gsd-tools find-phase 03`,
      "resolve-model": `Usage: gsd-tools resolve-model <agent-type>

Get the model assignment for an agent based on the active profile.

Arguments:
  agent-type   Agent identifier (e.g., gsd-executor, gsd-planner)

Examples:
  gsd-tools resolve-model gsd-executor`,
      "verify-summary": `Usage: gsd-tools verify-summary <path> [--check-count N]

Verify a SUMMARY.md file for completeness and structure.

Arguments:
  path            Path to SUMMARY.md file
  --check-count N Minimum number of checks required (default: 2)

Examples:
  gsd-tools verify-summary .planning/phases/01-foundation/01-01-SUMMARY.md`,
      "history-digest": `Usage: gsd-tools history-digest

Aggregate all SUMMARY.md data across phases into a single digest.
Includes archived milestone phases. Returns decisions, tech stack, and per-phase data.`,
      "phase-plan-index": `Usage: gsd-tools phase-plan-index <phase>

Index all plans in a phase with waves, dependencies, and status.

Arguments:
  phase   Phase number

Examples:
  gsd-tools phase-plan-index 03`,
      "state-snapshot": `Usage: gsd-tools state-snapshot

Structured parse of STATE.md returning all sections as JSON.
More detailed than state load \u2014 includes metrics, decisions, blockers, session info.`,
      "summary-extract": `Usage: gsd-tools summary-extract <path> [--fields f1,f2]

Extract structured data from a SUMMARY.md file.

Arguments:
  path             Path to SUMMARY.md
  --fields f1,f2   Comma-separated fields to extract (default: all)

Examples:
  gsd-tools summary-extract .planning/phases/01-foundation/01-01-SUMMARY.md
  gsd-tools summary-extract path/to/SUMMARY.md --fields phase,decisions`,
      "websearch": `Usage: gsd-tools websearch <query> [--limit N] [--freshness day|week|month]

Search the web via Brave Search API (requires brave_search config enabled).

Arguments:
  query          Search query string
  --limit N      Max results (default: 10)
  --freshness    Time filter: day, week, or month

Examples:
  gsd-tools websearch "esbuild bundler plugins" --limit 5`,
      "memory": `Usage: gsd-tools memory <subcommand> [options]

Persistent memory store for decisions, bookmarks, lessons, and todos.

Subcommands:
  write --store <name> --entry '{json}'   Write entry to a store
  read --store <name> [options]           Read entries from a store
  list                                    List stores with stats
  ensure-dir                              Create .planning/memory/ directory
  compact [--store <name>] [--threshold N] [--dry-run]  Compact old entries

Stores: decisions, bookmarks, lessons, todos

Options (read):
  --limit N          Max entries to return
  --query "text"     Case-insensitive text search across values
  --phase N          Filter by phase field

Examples:
  gsd-tools memory write --store decisions --entry '{"summary":"Chose esbuild","phase":"03"}'
  gsd-tools memory read --store decisions --query "esbuild"
  gsd-tools memory list`,
      "memory write": `Usage: gsd-tools memory write --store <name> --entry '{json}'
Write entry to store. Stores: decisions, bookmarks, lessons, todos.
decisions/lessons append-only. bookmarks prepend + trim to 20.`,
      "memory read": `Usage: gsd-tools memory read --store <name> [--limit N] [--query "text"] [--phase N]
Read entries with optional filtering.`,
      "memory list": `Usage: gsd-tools memory list \u2014 List stores with entry counts and sizes.`,
      "memory compact": `Usage: gsd-tools memory compact [--store <name>] [--threshold N] [--dry-run]
Compact non-sacred stores by summarizing old entries.`,
      "test-coverage": `Usage: gsd-tools test-coverage

Analyze test coverage by comparing test file invocations against router commands.

Reads:
  - Test file (default: bin/gsd-tools.test.cjs, override via config test_file)
  - Router file (default: src/router.js, override via config router_file)

Detects tested commands via:
  - runGsdTools('command ...') invocations in test file
  - describe('command ...') block names matching known commands
  - Template literal invocations

Output: { total_commands, commands_with_tests, coverage_percent, covered, uncovered, test_count }

Examples:
  gsd-tools test-coverage`,
      "intent": `Usage: gsd-tools intent <subcommand> [options]

Manage project intent in INTENT.md.

Subcommands:
  create      Create a new INTENT.md (errors if exists, use --force to overwrite)
  show        Display intent summary (compact by default, --full for complete, section filter supported)
  read        Read intent as JSON (alias for intent show, section filter supported)
  update      Update INTENT.md sections (--add, --remove, --set-priority, --value)
  validate    Validate INTENT.md structure (exit 0=valid, 1=issues)
  trace       Traceability matrix: desired outcomes \u2192 plans (--gaps for uncovered only)
  drift       Drift analysis: detect misalignment with 4 signals + numeric score

Examples:
  gsd-tools intent create
  gsd-tools intent show
  gsd-tools intent read outcomes
  gsd-tools intent validate
  gsd-tools intent trace
  gsd-tools intent trace --gaps
  gsd-tools intent drift`,
      "intent create": `Usage: gsd-tools intent create [--force] [--objective "text"] [--users "u1" "u2"] [--outcomes "DO-01: desc"] [--criteria "SC-01: gate"]
Create INTENT.md with 6 sections. --force overwrites existing.`,
      "intent show": `Usage: gsd-tools intent show [section] [--full]

Display intent summary from INTENT.md.

Modes:
  (default)        Compact summary (10-20 lines, outcomes sorted by priority)
  --full           Render complete INTENT.md content
  <section>        Show specific section (objective, users, outcomes, criteria, constraints, health)
             JSON output of all sections (or filtered section)

Examples:
  gsd-tools intent show
  gsd-tools intent show --full
  gsd-tools intent show outcomes
  gsd-tools intent show`,
      "intent read": `Usage: gsd-tools intent read [section]

Read intent as JSON. Alias for 'intent show'.

Arguments:
  section    Optional section filter (objective, users, outcomes, criteria, constraints, health)

Output: Full structured JSON or single section JSON

Examples:
  gsd-tools intent read
  gsd-tools intent read outcomes`,
      "intent validate": `Usage: gsd-tools intent validate

Validate INTENT.md structure: sections, ID format, uniqueness, minimums.
Exit 0=valid, 1=issues. Output (JSON): { valid, issues, sections, revision }

Examples:
  gsd-tools intent validate`,
      "intent trace": `Usage: gsd-tools intent trace [--gaps]

Traceability matrix: desired outcomes \u2192 plans addressing them.
Scans PLAN.md frontmatter for intent.outcome_ids.

Flags: --gaps (uncovered only), (JSON output)

Examples:
  gsd-tools intent trace --gaps`,
      "intent drift": `Usage: gsd-tools intent drift

Detect misalignment between work and stated intent. Drift score 0-100.

Signals: Coverage Gaps (40pts), Objective Mismatch (25pts), Feature Creep (15pts), Priority Inversion (20pts).
Score: 0-15 excellent, 16-35 good, 36-60 moderate, 61-100 poor.

Examples:
  gsd-tools intent drift`,
      "extract-sections": `Usage: gsd-tools extract-sections <file-path> [section1] [section2] ...

Extract specific named sections from a markdown file.
Supports ## headers and <!-- section: name --> markers as section boundaries.

Modes:
  Discovery     No sections specified \u2192 list available sections
  Extraction    Sections specified \u2192 return matching content

Section matching is case-insensitive.

Output (discovery):  { file, available_sections: [...] }
Output (extraction): { file, sections_found, sections_missing, content }

Examples:
  gsd-tools extract-sections references/checkpoints.md
  gsd-tools extract-sections references/checkpoints.md "types"
   gsd-tools extract-sections references/checkpoints.md "types" "guidelines"`,
      "token-budget": `Usage: gsd-tools token-budget

Show estimated token counts for all workflow files against their budgets.
Searches for workflow .md files in:
  1. <cwd>/workflows/
  2. Plugin directory workflows/
  3. ~/.config/opencode/workflows/ (home config)

Each workflow is measured (chars/4 \u2248 tokens) and compared against known budget limits.

Output: { workflows: [{ name, path, tokens, budget, within_budget }], total_tokens, over_budget_count }

Examples:
  gsd-tools token-budget`,
      "mcp-profile": `Usage: gsd-tools mcp-profile [options]

Discover MCP servers, estimate token cost, score relevance, apply/restore.

Sources: .mcp.json, opencode.json, ~/.config/opencode/opencode.json
Known-server DB covers 15+ servers. Scores keep/disable/review per server.

Options:
  --window <size>   Context window size (default: 200000)
  --apply           Disable recommended servers in opencode.json (backup first)
  --dry-run         With --apply: preview without modifying
  --restore         Restore opencode.json from opencode.json.bak
              JSON output

Only opencode.json is modified (not .mcp.json). Also: gsd-tools mcp profile

Examples:
  gsd-tools mcp-profile --apply
  gsd-tools mcp-profile --restore`,
      "mcp": `Usage: gsd-tools mcp <subcommand> [options]

MCP server management. Subcommands: profile [--window N] [--apply] [--restore]

Examples:
  gsd-tools mcp profile
  gsd-tools mcp profile --apply`,
      "assertions": `Usage: gsd-tools assertions <subcommand> [options]

Manage structured acceptance criteria in ASSERTIONS.md.

Subcommands:
  list [--req SREQ-01]    List all assertions, optionally filter by requirement ID
  validate                Check assertion format, coverage, and consistency

Output (list): { total_requirements, total_assertions, must_have_count, nice_to_have_count, requirements }
Output (validate): { valid, issues, stats: { total_reqs, total_assertions, coverage_percent } }

Examples:
  gsd-tools assertions list
  gsd-tools assertions list --req SREQ-01
  gsd-tools assertions validate`,
      "assertions list": `Usage: gsd-tools assertions list [--req <id>]

List all assertions from .planning/ASSERTIONS.md grouped by requirement ID.

Options:
  --req <id>    Filter to specific requirement (e.g., SREQ-01)

Output: { total_requirements, total_assertions, must_have_count, nice_to_have_count, requirements }

Examples:
  gsd-tools assertions list
  gsd-tools assertions list --req SREQ-01`,
      "assertions validate": `Usage: gsd-tools assertions validate

Validate ASSERTIONS.md format, coverage, and consistency with REQUIREMENTS.md.

Checks:
  - Every requirement ID exists in REQUIREMENTS.md
  - Each requirement has 2-5 assertions (advisory)
  - Every assertion has non-empty assert field
  - type values are valid: api, cli, file, behavior
  - priority values are valid: must-have, nice-to-have

Output: { valid, issues: [{reqId, issue, severity}], stats: {total_reqs, total_assertions, coverage_percent} }

Examples:
  gsd-tools assertions validate`,
      "env": `Usage: gsd-tools env <subcommand> [options]

Detect project languages, tools, and runtimes.

Subcommands:
  scan [--force] [--verbose]  Detect project environment and write manifest
  status                      Check environment manifest freshness

The scan command detects languages from manifest files (package.json, go.mod,
mix.exs, etc.), checks binary availability, detects package managers, version
managers, CI platforms, test frameworks, linters/formatters, scripts, Docker
services, MCP servers, and monorepo configurations.

Results are written to:
  .planning/env-manifest.json   Machine-specific (gitignored)
  .planning/project-profile.json  Team-visible (committed)

Flags:
  --force     Force full rescan even if manifest is fresh
  --verbose   Print human-readable summary to stderr
        Output JSON to stdout

Examples:
  gsd-tools env scan
  gsd-tools env scan --force --verbose
  gsd-tools env status`,
      "env scan": `Usage: gsd-tools env scan [--force] [--verbose]
Detect languages, tools, runtimes. Write env-manifest.json + project-profile.json.
--force bypasses freshness check. Detects 26+ language patterns.`,
      "env status": `Usage: gsd-tools env status

Report manifest freshness without triggering a scan.

Output: { exists, stale, reason, scanned_at, age_minutes, languages_count, changed_files }

Examples:
  gsd-tools env status`,
      "worktree": `Usage: gsd-tools worktree <subcommand> [options]

Manage git worktrees for parallel plan execution.

Subcommands:
  create <plan-id>    Create isolated worktree for a plan
  list                List active worktrees for this project
  remove <plan-id>    Remove a specific worktree
  cleanup             Remove all worktrees for this project`,
      "worktree create": `Usage: gsd-tools worktree create <plan-id>

Create an isolated git worktree for a plan.

Args:
  plan-id     Plan ID in NN-MM format (e.g., 21-02)

Creates worktree at {base_path}/{project}/{plan-id}/ with branch worktree-{phase}-{plan}-{wave}.
Syncs configured files (.env, config) and runs setup hooks.

Output: { created, plan_id, branch, path, synced_files, setup_status, setup_error?, resource_warnings? }`,
      "worktree list": `Usage: gsd-tools worktree list

List active worktrees for the current project.

Output: { worktrees: [{ plan_id, branch, path, head, disk_usage }] }`,
      "worktree remove": `Usage: gsd-tools worktree remove <plan-id>

Remove a specific worktree and its branch.

Args:
  plan-id     Plan ID to remove (e.g., 21-02)

Output: { removed, plan_id, path }`,
      "worktree cleanup": `Usage: gsd-tools worktree cleanup

Remove all worktrees for the current project and prune stale references.

Output: { cleaned, worktrees: [{ plan_id, path }] }`,
      "codebase context": `Usage: gsd-tools codebase context --files <file1> [file2] ... [--plan <path>]
       gsd-tools codebase context --task <file1,file2,...> [--plan <path>] [--budget <tokens>]

Assemble per-file architectural context from cached intel.

Mode 1 (--files): Full context with imports, dependents, conventions, risk levels.
Mode 2 (--task):  Task-scoped context using dep graph + relevance scoring.
  Returns only files relevant to the task with scores and optional AST signatures.

Options:
  --files <paths>    Target file paths for full context mode
  --task <paths>     Comma-separated task files for scoped context mode
  --plan <path>      Plan file for scope signal (reads files_modified)
  --budget <tokens>  Token budget for task-scoped output (default: 3000)

Output (--task): { task_files, context_files: [{path, score, reason, signatures?}], stats }

Examples:
  gsd-tools codebase context --files src/lib/ast.js
  gsd-tools codebase context --task src/lib/ast.js,src/router.js --budget 2000`,
      "codebase ast": `Usage: gsd-tools codebase ast <file>

Extract function, class, and method signatures from a source file.

For JS/TS: Uses acorn AST parsing with TypeScript stripping.
For Python, Go, Rust, Ruby, Elixir, Java, PHP: Uses regex-based extraction.

Arguments:
  file   Source file path to analyze

Output: { file, language, signatures: [{name, type, params, line, async, generator}], count }

Examples:
  gsd-tools codebase ast src/lib/ast.js
  gsd-tools codebase ast app.py`,
      "codebase exports": `Usage: gsd-tools codebase exports <file>

Extract the export surface from a JS/TS module.

Detects ESM exports (named, default, re-exports) and CJS exports
(module.exports, exports patterns). Reports module type (esm/cjs/mixed).

Arguments:
  file   Source file path to analyze

Output: { file, type, named, default, re_exports, cjs_exports }

Examples:
  gsd-tools codebase exports src/lib/ast.js
  gsd-tools codebase exports src/router.js`,
      "codebase complexity": `Usage: gsd-tools codebase complexity <file>

Compute per-function cyclomatic complexity for a source file.

For JS/TS: Uses acorn AST to walk each function body, counting branching
nodes (if, for, while, switch, catch, ternary, logical operators) and
tracking max nesting depth.

For other languages: Uses regex approximation counting branching keywords.

Arguments:
  file   Source file path to analyze

Output: { file, module_complexity, functions: [{name, line, complexity, nesting_max}] }

Color coding (formatted mode): green(1-5), yellow(6-10), red(11+)

Examples:
  gsd-tools codebase complexity src/router.js
  gsd-tools codebase complexity src/lib/ast.js`,
      "codebase repo-map": `Usage: gsd-tools codebase repo-map [--budget <tokens>]

Generate a compact repository map from AST signatures.

Walks all source files, extracts function/class/method signatures and
exports, then builds a compact text summary sorted by signature density.
Designed for agent context injection (~1k tokens by default).

Options:
  --budget <tokens>   Token budget for output (default: 1000)

Output (raw): { summary, files_included, total_signatures, token_estimate }
Output (formatted): The summary text directly

Examples:
  gsd-tools codebase repo-map
  gsd-tools codebase repo-map --budget 500`,
      "classify": `Usage: gsd-tools classify <plan|phase> <path-or-number>

Classify task complexity and recommend execution strategy.

Subcommands:
  plan <plan-path>       Classify all tasks in a single plan (1-5 complexity scores)
  phase <phase-number>   Classify all incomplete plans in a phase + execution mode

Examples:
  gsd-tools classify plan .planning/phases/39-orchestration-intelligence/39-01-PLAN.md
  gsd-tools classify phase 39`,
      "classify plan": `Usage: gsd-tools classify plan <plan-path>

Classify all tasks in a plan file with 1-5 complexity scores.

Scoring factors: file count, cross-module blast radius, test requirements,
checkpoint complexity, action length.

Model mapping: score 1-2 \u2192 sonnet, score 3 \u2192 sonnet, score 4-5 \u2192 opus

Output: { plan, wave, autonomous, task_count, tasks: [{name, complexity}], plan_complexity, recommended_model }

Examples:
  gsd-tools classify plan .planning/phases/39-orchestration-intelligence/39-01-PLAN.md`,
      "classify phase": `Usage: gsd-tools classify phase <phase-number>

Classify all incomplete plans in a phase and determine execution mode.

Execution modes:
  single      1 plan with 1-2 tasks
  parallel    Multiple plans in same wave, no file overlaps
  sequential  Plans with checkpoint tasks
  pipeline    Plans spanning 3+ waves

Output: { phase, plans_classified, plans: [...], execution_mode: { mode, reason, waves } }

Examples:
  gsd-tools classify phase 39
  gsd-tools classify phase 38`,
      "tdd": `Usage: gsd-tools tdd <subcommand> [options]

TDD validation gates for RED/GREEN/REFACTOR cycle enforcement.

Subcommands:
  validate-red --test-cmd "cmd"       Verify test fails (exit 0 if test fails)
  validate-green --test-cmd "cmd"     Verify test passes (exit 0 if test passes)
  validate-refactor --test-cmd "cmd"  Same as validate-green
  auto-test --test-cmd "cmd"          Run test, report result (no exit code override)
  detect-antipattern --phase P --files "f1,f2"  Check for TDD violations

Also: commit --tdd-phase red|green|refactor adds GSD-Phase trailer

Examples:
  gsd-tools tdd validate-red --test-cmd "npm test"
  gsd-tools tdd detect-antipattern --phase red --files "src/foo.js"`,
      "review": `Usage: gsd-tools review <phase> <plan> \u2014 Review context for reviewer agent`,
      "profile": "Set GSD_PROFILE=1 to enable performance profiling. Baselines written to .planning/baselines/",
      "git": `Usage: gsd-tools git <log|diff-summary|blame|branch-info> [options]

Structured git intelligence \u2014 JSON output for agents and workflows.

Subcommands:
  log [--count N] [--since D] [--until D] [--author A] [--path P]
    Structured commit log with file stats and conventional commit parsing.
  diff-summary [--from ref] [--to ref] [--path P]
    Diff stats between two refs (default: HEAD~1..HEAD).
  blame <file>
    Line-to-commit/author mapping for a file.
  branch-info
    Current branch state: detached, shallow, dirty, rebasing, upstream.

Examples:
  gsd-tools git log --count 5
  gsd-tools git diff-summary --from main --to HEAD
  gsd-tools git blame src/router.js
  gsd-tools git branch-info`
    };
    module2.exports = { MODEL_PROFILES, CONFIG_SCHEMA, COMMAND_HELP };
  }
});

// src/lib/output.js
var require_output = __commonJS({
  "src/lib/output.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    var _tmpFiles = [];
    process.on("exit", () => {
      for (const f of _tmpFiles) {
        try {
          fs.unlinkSync(f);
        } catch {
        }
      }
    });
    function filterFields(obj, fields) {
      if (obj === null || obj === void 0) return obj;
      if (Array.isArray(obj)) {
        return obj.map((item) => filterFields(item, fields));
      }
      if (typeof obj !== "object") return obj;
      const result = {};
      for (const field of fields) {
        const parts = field.split(".");
        if (parts.length === 1) {
          result[field] = field in obj ? obj[field] : null;
        } else {
          const topKey = parts[0];
          const rest = parts.slice(1).join(".");
          if (!(topKey in obj)) {
            result[topKey] = null;
          } else {
            const val = obj[topKey];
            if (Array.isArray(val)) {
              result[topKey] = val.map((item) => {
                if (typeof item === "object" && item !== null) {
                  return filterFields(item, [rest]);
                }
                return item;
              });
            } else if (typeof val === "object" && val !== null) {
              const existing = result[topKey] || {};
              const nested = filterFields(val, [rest]);
              result[topKey] = typeof existing === "object" && !Array.isArray(existing) ? { ...existing, ...nested } : nested;
            } else {
              result[topKey] = val;
            }
          }
        }
      }
      return result;
    }
    function outputMode() {
      return global._gsdOutputMode || "json";
    }
    function outputJSON(result, rawValue) {
      const mode = global._gsdOutputMode || "json";
      if (rawValue !== void 0 && mode !== "json") {
        process.stdout.write(String(rawValue));
        return;
      }
      let filtered = result;
      if (global._gsdRequestedFields && typeof result === "object" && result !== null) {
        filtered = filterFields(result, global._gsdRequestedFields);
      }
      const json = JSON.stringify(filtered, null, 2);
      if (json.length > 5e4 && !process.env.GSD_NO_TMPFILE) {
        const tmpPath = path.join(require("os").tmpdir(), `gsd-${Date.now()}.json`);
        fs.writeFileSync(tmpPath, json, "utf-8");
        _tmpFiles.push(tmpPath);
        process.stdout.write("@file:" + tmpPath);
      } else {
        process.stdout.write(json);
      }
    }
    function output(result, options) {
      if (typeof options === "boolean") {
        outputJSON(result, arguments[2]);
        process.exit(process.exitCode || 0);
        return;
      }
      const opts = options || {};
      const mode = outputMode();
      if (mode === "json") {
        outputJSON(result, opts.rawValue);
      } else {
        if (opts.formatter) {
          const formatted = opts.formatter(result);
          process.stdout.write(formatted + "\n");
        } else {
          outputJSON(result, opts.rawValue);
        }
      }
      process.exit(process.exitCode || 0);
    }
    function status(message) {
      process.stderr.write(message + "\n");
    }
    function error(message) {
      process.stderr.write("Error: " + message + "\n");
      process.exit(1);
    }
    function debugLog(context, message, err) {
      if (!process.env.GSD_DEBUG) return;
      let line = `[GSD_DEBUG] ${context}: ${message}`;
      if (err) line += ` | ${err.message || err}`;
      process.stderr.write(line + "\n");
    }
    module2.exports = { _tmpFiles, filterFields, output, outputMode, status, error, debugLog };
  }
});

// src/lib/config.js
var require_config = __commonJS({
  "src/lib/config.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    var { execFileSync } = require("child_process");
    var { CONFIG_SCHEMA } = require_constants();
    var { debugLog } = require_output();
    var _configCache = /* @__PURE__ */ new Map();
    function loadConfig(cwd) {
      if (_configCache.has(cwd)) {
        debugLog("config.load", `cache hit: ${cwd}`);
        return _configCache.get(cwd);
      }
      const configPath = path.join(cwd, ".planning", "config.json");
      const defaults = {};
      for (const [key, def] of Object.entries(CONFIG_SCHEMA)) {
        defaults[key] = def.default;
      }
      try {
        const raw = fs.readFileSync(configPath, "utf-8");
        const parsed = JSON.parse(raw);
        const get = (key, def) => {
          if (parsed[key] !== void 0) return parsed[key];
          if (def.nested && parsed[def.nested.section] && parsed[def.nested.section][def.nested.field] !== void 0) {
            return parsed[def.nested.section][def.nested.field];
          }
          for (const alias of def.aliases) {
            if (parsed[alias] !== void 0) return parsed[alias];
          }
          return void 0;
        };
        const result = {};
        for (const [key, def] of Object.entries(CONFIG_SCHEMA)) {
          if (def.coerce === "parallelization") {
            const val = get(key, def);
            if (typeof val === "boolean") {
              result[key] = val;
            } else if (typeof val === "object" && val !== null && "enabled" in val) {
              result[key] = val.enabled;
            } else {
              result[key] = def.default;
            }
          } else {
            result[key] = get(key, def) ?? def.default;
          }
        }
        _configCache.set(cwd, result);
        return result;
      } catch (e) {
        debugLog("config.load", "parse config.json failed, using defaults", e);
        _configCache.set(cwd, defaults);
        return defaults;
      }
    }
    function isGitIgnored(cwd, targetPath) {
      try {
        execFileSync("git", ["check-ignore", "-q", "--", targetPath], {
          cwd,
          stdio: "pipe"
        });
        return true;
      } catch (e) {
        debugLog("git.checkIgnore", "exec failed", e);
        return false;
      }
    }
    module2.exports = { loadConfig, isGitIgnored };
  }
});

// src/lib/regex-cache.js
var require_regex_cache = __commonJS({
  "src/lib/regex-cache.js"(exports2, module2) {
    var MAX_CACHE_SIZE = 200;
    var _dynamicRegexCache = /* @__PURE__ */ new Map();
    function cachedRegex(pattern, flags = "") {
      const key = `${pattern}|||${flags}`;
      if (_dynamicRegexCache.has(key)) {
        const regex2 = _dynamicRegexCache.get(key);
        _dynamicRegexCache.delete(key);
        _dynamicRegexCache.set(key, regex2);
        return regex2;
      }
      if (_dynamicRegexCache.size >= MAX_CACHE_SIZE) {
        const oldest = _dynamicRegexCache.keys().next().value;
        _dynamicRegexCache.delete(oldest);
      }
      const regex = new RegExp(pattern, flags);
      _dynamicRegexCache.set(key, regex);
      return regex;
    }
    var FRONTMATTER_DELIMITERS = /^---\n([\s\S]+?)\n---/;
    var PHASE_HEADER = /#{2,4}\s*Phase\s+(\d+(?:\.\d+)?)\s*:\s*([^\n]+)/gi;
    var ACTIVE_MILESTONE = /[-*]\s*ðŸ”µ\s*\*\*v(\d+(?:\.\d+)*)\s+([^*]+)\*\*([^\n]*)/;
    var ACTIVE_TAG_MILESTONE = /[-*]\s*(?:ðŸ”µ\s*)?\*\*v(\d+(?:\.\d+)*)\s+([^*]+)\*\*([^\n]*\(active\)[^\n]*)/i;
    var VERSION_PATTERN = /v(\d+\.\d+)/;
    var DATE_PATTERN = /^\d{4}-\d{2}-\d{2}$/;
    var PHASE_DIR_NUMBER = /^(\d+(?:\.\d+)?)-?(.*)/;
    var COMMIT_SHA = /\b([a-f0-9]{7,40})\b/g;
    var UNCHECKED_PHASE = /- \[ \] \*\*Phase/g;
    module2.exports = {
      cachedRegex,
      FRONTMATTER_DELIMITERS,
      PHASE_HEADER,
      ACTIVE_MILESTONE,
      ACTIVE_TAG_MILESTONE,
      VERSION_PATTERN,
      DATE_PATTERN,
      PHASE_DIR_NUMBER,
      COMMIT_SHA,
      UNCHECKED_PHASE
    };
  }
});

// src/lib/frontmatter.js
var require_frontmatter = __commonJS({
  "src/lib/frontmatter.js"(exports2, module2) {
    var FM_DELIMITERS = /^---\n([\s\S]+?)\n---/;
    var FM_INDENT = /^(\s*)/;
    var FM_KEY_VALUE = /^(\s*)([a-zA-Z0-9_-]+):\s*(.*)/;
    var _fmCache = /* @__PURE__ */ new Map();
    var FM_CACHE_MAX = 100;
    function extractFrontmatter(content) {
      if (!content || typeof content !== "string") return {};
      if (!content.startsWith("---\n")) return {};
      const cacheKey = content.length + ":" + content.slice(0, 200);
      if (_fmCache.has(cacheKey)) {
        return _fmCache.get(cacheKey);
      }
      const frontmatter = {};
      const match = content.match(FM_DELIMITERS);
      if (!match) return frontmatter;
      const yaml = match[1];
      const lines = yaml.split("\n");
      let stack = [{ obj: frontmatter, key: null, indent: -1 }];
      for (const line of lines) {
        if (line.trim() === "") continue;
        const indentMatch = line.match(FM_INDENT);
        const indent = indentMatch ? indentMatch[1].length : 0;
        while (stack.length > 1 && indent <= stack[stack.length - 1].indent) {
          stack.pop();
        }
        const current = stack[stack.length - 1];
        const keyMatch = line.match(FM_KEY_VALUE);
        if (keyMatch) {
          const key = keyMatch[2];
          const value = keyMatch[3].trim();
          if (value === "" || value === "[") {
            current.obj[key] = value === "[" ? [] : {};
            current.key = null;
            stack.push({ obj: current.obj[key], key: null, indent });
          } else if (value.startsWith("[") && value.endsWith("]")) {
            current.obj[key] = value.slice(1, -1).split(",").map((s) => s.trim().replace(/^["']|["']$/g, "")).filter(Boolean);
            current.key = null;
          } else {
            current.obj[key] = value.replace(/^["']|["']$/g, "");
            current.key = null;
          }
        } else if (line.trim().startsWith("- ")) {
          const itemValue = line.trim().slice(2).replace(/^["']|["']$/g, "");
          if (typeof current.obj === "object" && !Array.isArray(current.obj) && Object.keys(current.obj).length === 0) {
            const parent = stack.length > 1 ? stack[stack.length - 2] : null;
            if (parent) {
              for (const k of Object.keys(parent.obj)) {
                if (parent.obj[k] === current.obj) {
                  parent.obj[k] = [itemValue];
                  current.obj = parent.obj[k];
                  break;
                }
              }
            }
          } else if (Array.isArray(current.obj)) {
            current.obj.push(itemValue);
          }
        }
      }
      if (_fmCache.size >= FM_CACHE_MAX) {
        const oldest = _fmCache.keys().next().value;
        _fmCache.delete(oldest);
      }
      _fmCache.set(cacheKey, frontmatter);
      return frontmatter;
    }
    function reconstructFrontmatter(obj) {
      const lines = [];
      for (const [key, value] of Object.entries(obj)) {
        if (value === null || value === void 0) continue;
        if (Array.isArray(value)) {
          if (value.length === 0) {
            lines.push(`${key}: []`);
          } else if (value.every((v) => typeof v === "string") && value.length <= 3 && value.join(", ").length < 60) {
            lines.push(`${key}: [${value.join(", ")}]`);
          } else {
            lines.push(`${key}:`);
            for (const item of value) {
              lines.push(`  - ${typeof item === "string" && (item.includes(":") || item.includes("#")) ? `"${item}"` : item}`);
            }
          }
        } else if (typeof value === "object") {
          lines.push(`${key}:`);
          for (const [subkey, subval] of Object.entries(value)) {
            if (subval === null || subval === void 0) continue;
            if (Array.isArray(subval)) {
              if (subval.length === 0) {
                lines.push(`  ${subkey}: []`);
              } else if (subval.every((v) => typeof v === "string") && subval.length <= 3 && subval.join(", ").length < 60) {
                lines.push(`  ${subkey}: [${subval.join(", ")}]`);
              } else {
                lines.push(`  ${subkey}:`);
                for (const item of subval) {
                  lines.push(`    - ${typeof item === "string" && (item.includes(":") || item.includes("#")) ? `"${item}"` : item}`);
                }
              }
            } else if (typeof subval === "object") {
              lines.push(`  ${subkey}:`);
              for (const [subsubkey, subsubval] of Object.entries(subval)) {
                if (subsubval === null || subsubval === void 0) continue;
                if (Array.isArray(subsubval)) {
                  if (subsubval.length === 0) {
                    lines.push(`    ${subsubkey}: []`);
                  } else {
                    lines.push(`    ${subsubkey}:`);
                    for (const item of subsubval) {
                      lines.push(`      - ${item}`);
                    }
                  }
                } else {
                  lines.push(`    ${subsubkey}: ${subsubval}`);
                }
              }
            } else {
              const sv = String(subval);
              lines.push(`  ${subkey}: ${sv.includes(":") || sv.includes("#") ? `"${sv}"` : sv}`);
            }
          }
        } else {
          const sv = String(value);
          if (sv.includes(":") || sv.includes("#") || sv.startsWith("[") || sv.startsWith("{")) {
            lines.push(`${key}: "${sv}"`);
          } else {
            lines.push(`${key}: ${sv}`);
          }
        }
      }
      return lines.join("\n");
    }
    function spliceFrontmatter(content, newObj) {
      const yamlStr = reconstructFrontmatter(newObj);
      const match = content.match(/^---\n[\s\S]+?\n---/);
      if (match) {
        return `---
${yamlStr}
---` + content.slice(match[0].length);
      }
      return `---
${yamlStr}
---

` + content;
    }
    module2.exports = { extractFrontmatter, reconstructFrontmatter, spliceFrontmatter };
  }
});

// src/lib/helpers.js
var require_helpers = __commonJS({
  "src/lib/helpers.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    var { debugLog } = require_output();
    var { loadConfig } = require_config();
    var { MODEL_PROFILES } = require_constants();
    var { cachedRegex, PHASE_DIR_NUMBER } = require_regex_cache();
    var fileCache = /* @__PURE__ */ new Map();
    var dirCache = /* @__PURE__ */ new Map();
    function safeReadFile(filePath) {
      try {
        return fs.readFileSync(filePath, "utf-8");
      } catch (e) {
        debugLog("file.read", "read failed", e);
        return null;
      }
    }
    function cachedReadFile(filePath) {
      if (fileCache.has(filePath)) {
        debugLog("file.cache", `cache hit: ${filePath}`);
        return fileCache.get(filePath);
      }
      const content = safeReadFile(filePath);
      if (content !== null) {
        fileCache.set(filePath, content);
      }
      return content;
    }
    function invalidateFileCache(filePath) {
      if (filePath) {
        fileCache.delete(filePath);
      } else {
        fileCache.clear();
      }
    }
    function cachedReaddirSync(dirPath, options) {
      const optKey = options?.withFileTypes ? ":wt" : "";
      const key = dirPath + optKey;
      if (dirCache.has(key)) {
        return dirCache.get(key);
      }
      try {
        const entries = fs.readdirSync(dirPath, options);
        dirCache.set(key, entries);
        return entries;
      } catch (e) {
        debugLog("dir.cache", `readdir failed: ${dirPath}`, e);
        dirCache.set(key, null);
        return null;
      }
    }
    var _phaseTreeCache = null;
    var _phaseTreeCwd = null;
    function getPhaseTree(cwd) {
      if (_phaseTreeCache && _phaseTreeCwd === cwd) {
        return _phaseTreeCache;
      }
      const phasesDir = path.join(cwd, ".planning", "phases");
      const tree = /* @__PURE__ */ new Map();
      try {
        const entries = fs.readdirSync(phasesDir, { withFileTypes: true });
        const dirs = entries.filter((e) => e.isDirectory()).map((e) => e.name).sort();
        for (const dir of dirs) {
          const dirMatch = dir.match(PHASE_DIR_NUMBER);
          const phaseNumber = dirMatch ? dirMatch[1] : dir;
          const normalized = normalizePhaseName(phaseNumber);
          const phaseName = dirMatch && dirMatch[2] ? dirMatch[2] : null;
          const phaseDir = path.join(phasesDir, dir);
          const phaseFiles = fs.readdirSync(phaseDir);
          const plans = phaseFiles.filter((f) => f.endsWith("-PLAN.md") || f === "PLAN.md").sort();
          const summaries = phaseFiles.filter((f) => f.endsWith("-SUMMARY.md") || f === "SUMMARY.md").sort();
          const hasResearch = phaseFiles.some((f) => f.endsWith("-RESEARCH.md") || f === "RESEARCH.md");
          const hasContext = phaseFiles.some((f) => f.endsWith("-CONTEXT.md") || f === "CONTEXT.md");
          const hasVerification = phaseFiles.some((f) => f.endsWith("-VERIFICATION.md") || f === "VERIFICATION.md");
          const completedPlanIds = new Set(
            summaries.map((s) => s.replace("-SUMMARY.md", "").replace("SUMMARY.md", ""))
          );
          const incompletePlans = plans.filter((p) => {
            const planId = p.replace("-PLAN.md", "").replace("PLAN.md", "");
            return !completedPlanIds.has(planId);
          });
          tree.set(normalized, {
            dirName: dir,
            fullPath: phaseDir,
            relPath: path.join(".planning", "phases", dir),
            phaseNumber,
            phaseName,
            phaseSlug: phaseName ? phaseName.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "") : null,
            files: phaseFiles,
            plans,
            summaries,
            incompletePlans,
            hasResearch,
            hasContext,
            hasVerification
          });
        }
      } catch (e) {
        debugLog("phase.tree", "scan failed", e);
      }
      _phaseTreeCache = tree;
      _phaseTreeCwd = cwd;
      return tree;
    }
    function normalizePhaseName(phase) {
      const match = phase.match(/^(\d+(?:\.\d+)?)/);
      if (!match) return phase;
      const num = match[1];
      const parts = num.split(".");
      const padded = parts[0].padStart(2, "0");
      return parts.length > 1 ? `${padded}.${parts[1]}` : padded;
    }
    function parseMustHavesBlock(content, blockName) {
      const fmMatch = content.match(/^---\n([\s\S]+?)\n---/);
      if (!fmMatch) return [];
      const yaml = fmMatch[1];
      const blockPattern = cachedRegex(`^\\s{4}${blockName}:\\s*$`, "m");
      const blockStart = yaml.search(blockPattern);
      if (blockStart === -1) return [];
      const afterBlock = yaml.slice(blockStart);
      const blockLines = afterBlock.split("\n").slice(1);
      const items = [];
      let current = null;
      for (const line of blockLines) {
        if (line.trim() === "") continue;
        const indent = line.match(/^(\s*)/)[1].length;
        if (indent <= 4 && line.trim() !== "") break;
        if (line.match(/^\s{6}-\s+/)) {
          if (current) items.push(current);
          current = {};
          const simpleMatch = line.match(/^\s{6}-\s+"?([^"]+)"?\s*$/);
          if (simpleMatch && !line.includes(":")) {
            current = simpleMatch[1];
          } else {
            const kvMatch = line.match(/^\s{6}-\s+(\w+):\s*"?([^"]*)"?\s*$/);
            if (kvMatch) {
              current = {};
              current[kvMatch[1]] = kvMatch[2];
            }
          }
        } else if (current && typeof current === "object") {
          const kvMatch = line.match(/^\s{8,}(\w+):\s*"?([^"]*)"?\s*$/);
          if (kvMatch) {
            const val = kvMatch[2];
            current[kvMatch[1]] = /^\d+$/.test(val) ? parseInt(val, 10) : val;
          }
          const arrMatch = line.match(/^\s{10,}-\s+"?([^"]+)"?\s*$/);
          if (arrMatch) {
            const keys = Object.keys(current);
            const lastKey = keys[keys.length - 1];
            if (lastKey && !Array.isArray(current[lastKey])) {
              current[lastKey] = current[lastKey] ? [current[lastKey]] : [];
            }
            if (lastKey) current[lastKey].push(arrMatch[1]);
          }
        }
      }
      if (current) items.push(current);
      return items;
    }
    function sanitizeShellArg(arg) {
      return "'" + String(arg).replace(/'/g, "'\\''") + "'";
    }
    function isValidDateString(str) {
      return /^\d{4}-\d{2}-\d{2}$/.test(str);
    }
    function resolveModelInternal(cwd, agentType) {
      const config = loadConfig(cwd);
      const override = config.model_overrides?.[agentType];
      if (override) {
        return override === "opus" ? "inherit" : override;
      }
      const profile = config.model_profile || "balanced";
      const agentModels = MODEL_PROFILES[agentType];
      if (!agentModels) return "sonnet";
      const resolved = agentModels[profile] || agentModels["balanced"] || "sonnet";
      return resolved === "opus" ? "inherit" : resolved;
    }
    function getArchivedPhaseDirs(cwd) {
      const milestonesDir = path.join(cwd, ".planning", "milestones");
      const results = [];
      if (!fs.existsSync(milestonesDir)) return results;
      try {
        const milestoneEntries = fs.readdirSync(milestonesDir, { withFileTypes: true });
        const phaseDirs = milestoneEntries.filter((e) => e.isDirectory() && /^v[\d.]+-phases$/.test(e.name)).map((e) => e.name).sort().reverse();
        for (const archiveName of phaseDirs) {
          const version = archiveName.match(/^(v[\d.]+)-phases$/)[1];
          const archivePath = path.join(milestonesDir, archiveName);
          const entries = fs.readdirSync(archivePath, { withFileTypes: true });
          const dirs = entries.filter((e) => e.isDirectory()).map((e) => e.name).sort();
          for (const dir of dirs) {
            results.push({
              name: dir,
              milestone: version,
              basePath: path.join(".planning", "milestones", archiveName),
              fullPath: path.join(archivePath, dir)
            });
          }
        }
      } catch (e) {
        debugLog("phase.getArchived", "readdir failed", e);
      }
      return results;
    }
    function searchPhaseInDir(baseDir, relBase, normalized) {
      try {
        const entries = fs.readdirSync(baseDir, { withFileTypes: true });
        const dirs = entries.filter((e) => e.isDirectory()).map((e) => e.name).sort();
        const match = dirs.find((d) => d.startsWith(normalized));
        if (!match) return null;
        const dirMatch = match.match(PHASE_DIR_NUMBER);
        const phaseNumber = dirMatch ? dirMatch[1] : normalized;
        const phaseName = dirMatch && dirMatch[2] ? dirMatch[2] : null;
        const phaseDir = path.join(baseDir, match);
        const phaseFiles = fs.readdirSync(phaseDir);
        const plans = phaseFiles.filter((f) => f.endsWith("-PLAN.md") || f === "PLAN.md").sort();
        const summaries = phaseFiles.filter((f) => f.endsWith("-SUMMARY.md") || f === "SUMMARY.md").sort();
        const hasResearch = phaseFiles.some((f) => f.endsWith("-RESEARCH.md") || f === "RESEARCH.md");
        const hasContext = phaseFiles.some((f) => f.endsWith("-CONTEXT.md") || f === "CONTEXT.md");
        const hasVerification = phaseFiles.some((f) => f.endsWith("-VERIFICATION.md") || f === "VERIFICATION.md");
        const completedPlanIds = new Set(
          summaries.map((s) => s.replace("-SUMMARY.md", "").replace("SUMMARY.md", ""))
        );
        const incompletePlans = plans.filter((p) => {
          const planId = p.replace("-PLAN.md", "").replace("PLAN.md", "");
          return !completedPlanIds.has(planId);
        });
        return {
          found: true,
          directory: path.join(relBase, match),
          phase_number: phaseNumber,
          phase_name: phaseName,
          phase_slug: phaseName ? phaseName.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "") : null,
          plans,
          summaries,
          incomplete_plans: incompletePlans,
          has_research: hasResearch,
          has_context: hasContext,
          has_verification: hasVerification
        };
      } catch (e) {
        debugLog("phase.searchDir", "search directory failed", e);
        return null;
      }
    }
    function findPhaseInternal(cwd, phase) {
      if (!phase) return null;
      const normalized = normalizePhaseName(phase);
      const tree = getPhaseTree(cwd);
      const cached = tree.get(normalized);
      if (cached) {
        return {
          found: true,
          directory: cached.relPath,
          phase_number: cached.phaseNumber,
          phase_name: cached.phaseName,
          phase_slug: cached.phaseSlug,
          plans: cached.plans,
          summaries: cached.summaries,
          incomplete_plans: cached.incompletePlans,
          has_research: cached.hasResearch,
          has_context: cached.hasContext,
          has_verification: cached.hasVerification
        };
      }
      const milestonesDir = path.join(cwd, ".planning", "milestones");
      if (!fs.existsSync(milestonesDir)) return null;
      try {
        const milestoneEntries = fs.readdirSync(milestonesDir, { withFileTypes: true });
        const archiveDirs = milestoneEntries.filter((e) => e.isDirectory() && /^v[\d.]+-phases$/.test(e.name)).map((e) => e.name).sort().reverse();
        for (const archiveName of archiveDirs) {
          const version = archiveName.match(/^(v[\d.]+)-phases$/)[1];
          const archivePath = path.join(milestonesDir, archiveName);
          const relBase = path.join(".planning", "milestones", archiveName);
          const result = searchPhaseInDir(archivePath, relBase, normalized);
          if (result) {
            result.archived = version;
            return result;
          }
        }
      } catch (e) {
        debugLog("phase.findInternal", "search archived phases failed", e);
      }
      return null;
    }
    function getRoadmapPhaseInternal(cwd, phaseNum) {
      if (!phaseNum) return null;
      const roadmapPath = path.join(cwd, ".planning", "ROADMAP.md");
      try {
        const content = cachedReadFile(roadmapPath);
        if (!content) return null;
        const escapedPhase = phaseNum.toString().replace(/\./g, "\\.");
        const phasePattern = cachedRegex(`#{2,4}\\s*Phase\\s+${escapedPhase}:\\s*([^\\n]+)`, "i");
        const headerMatch = content.match(phasePattern);
        if (!headerMatch) return null;
        const phaseName = headerMatch[1].trim();
        const headerIndex = headerMatch.index;
        const restOfContent = content.slice(headerIndex);
        const nextHeaderMatch = restOfContent.match(/\n#{2,4}\s+Phase\s+\d/i);
        const sectionEnd = nextHeaderMatch ? headerIndex + nextHeaderMatch.index : content.length;
        const section = content.slice(headerIndex, sectionEnd).trim();
        const goalMatch = section.match(/\*\*Goal:?\*\*:?\s*([^\n]+)/i);
        const goal = goalMatch ? goalMatch[1].trim() : null;
        return {
          found: true,
          phase_number: phaseNum.toString(),
          phase_name: phaseName,
          goal,
          section
        };
      } catch (e) {
        debugLog("roadmap.getPhaseInternal", "read roadmap phase failed", e);
        return null;
      }
    }
    function pathExistsInternal(cwd, targetPath) {
      const fullPath = path.isAbsolute(targetPath) ? targetPath : path.join(cwd, targetPath);
      try {
        fs.statSync(fullPath);
        return true;
      } catch (e) {
        debugLog("file.exists", "stat failed", e);
        return false;
      }
    }
    function generateSlugInternal(text) {
      if (!text) return null;
      return text.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "");
    }
    var _milestoneCache = null;
    var _milestoneCwd = null;
    function getMilestoneInfo(cwd) {
      if (_milestoneCache && _milestoneCwd === cwd) {
        return _milestoneCache;
      }
      const result = _getMilestoneInfoUncached(cwd);
      _milestoneCache = result;
      _milestoneCwd = cwd;
      return result;
    }
    function _getMilestoneInfoUncached(cwd) {
      try {
        let extractPhaseRange2 = function(line) {
          const rangeMatch = line.match(/Phases?\s+(\d+)\s*[-â€“]\s*(\d+)/i);
          if (rangeMatch) return { start: parseInt(rangeMatch[1]), end: parseInt(rangeMatch[2]) };
          return null;
        };
        var extractPhaseRange = extractPhaseRange2;
        const roadmap = cachedReadFile(path.join(cwd, ".planning", "ROADMAP.md"));
        if (!roadmap) return { version: "v1.0", name: "milestone", phaseRange: null };
        let version = null;
        let name = null;
        let phaseRange = null;
        const activeMatch = roadmap.match(/[-*]\s*ðŸ”µ\s*\*\*v(\d+(?:\.\d+)*)\s+([^*]+)\*\*([^\n]*)/);
        if (activeMatch) {
          version = "v" + activeMatch[1];
          name = activeMatch[2].trim();
          phaseRange = extractPhaseRange2(activeMatch[0]);
        }
        if (!version) {
          const activeTagMatch = roadmap.match(/[-*]\s*(?:ðŸ”µ\s*)?\*\*v(\d+(?:\.\d+)*)\s+([^*]+)\*\*([^\n]*\(active\)[^\n]*)/i);
          if (activeTagMatch) {
            version = "v" + activeTagMatch[1];
            name = activeTagMatch[2].trim();
            phaseRange = extractPhaseRange2(activeTagMatch[0]);
          }
        }
        if (!version) {
          const currentWorkMatch = roadmap.match(/\*\*Active Milestone\*\*\s*[-â€”]+\s*v(\d+(?:\.\d+)*)[\s:]+([^\n]+)/i);
          if (currentWorkMatch) {
            version = "v" + currentWorkMatch[1];
            name = currentWorkMatch[2].trim();
            const listMatch = roadmap.match(cachedRegex("v" + currentWorkMatch[1].replace(".", "\\.") + "[^\\n]*Phases?\\s+(\\d+)\\s*[-\u2013]\\s*(\\d+)", "i"));
            if (listMatch) phaseRange = { start: parseInt(listMatch[1]), end: parseInt(listMatch[2]) };
          }
        }
        if (!version) {
          const milestoneLines = [...roadmap.matchAll(/[-*]\s*(?!âœ…)[^\n]*\*\*v(\d+(?:\.\d+)*)\s+([^*]+)\*\*([^\n]*)/g)];
          if (milestoneLines.length > 0) {
            const last = milestoneLines[milestoneLines.length - 1];
            version = "v" + last[1];
            name = last[2].trim();
            phaseRange = extractPhaseRange2(last[0]);
          }
        }
        if (!version) {
          const versionMatch = roadmap.match(/v(\d+\.\d+)/);
          const nameMatch = roadmap.match(/## .*v\d+\.\d+[:\s]+([^\n(]+)/);
          version = versionMatch ? versionMatch[0] : "v1.0";
          name = nameMatch ? nameMatch[1].trim() : "milestone";
        }
        return { version, name, phaseRange };
      } catch (e) {
        debugLog("milestone.info", "read roadmap for milestone failed", e);
        return { version: "v1.0", name: "milestone", phaseRange: null };
      }
    }
    function invalidateMilestoneCache() {
      _milestoneCache = null;
      _milestoneCwd = null;
    }
    function extractAtReferences(content) {
      if (!content || typeof content !== "string") return [];
      const refs = /* @__PURE__ */ new Set();
      const atPattern = /@((?:\/[\w.+\-/]+|\.[\w.+\-/]+|[\w][\w.+\-]*\/[\w.+\-/]+)(?:\.\w+)?)/g;
      let match;
      while ((match = atPattern.exec(content)) !== null) {
        const ref = match[1];
        if (ref.includes("/") && !ref.includes("@") && ref.length > 2) {
          refs.add(ref);
        }
      }
      return Array.from(refs);
    }
    function parseIntentMd(content) {
      if (!content || typeof content !== "string") {
        return {
          revision: null,
          created: null,
          updated: null,
          objective: { statement: "", elaboration: "" },
          users: [],
          outcomes: [],
          criteria: [],
          constraints: { technical: [], business: [], timeline: [] },
          health: { quantitative: [], qualitative: "" },
          history: []
        };
      }
      const revisionMatch = content.match(/\*\*Revision:\*\*\s*(\d+)/);
      const createdMatch = content.match(/\*\*Created:\*\*\s*(\S+)/);
      const updatedMatch = content.match(/\*\*Updated:\*\*\s*(\S+)/);
      const revision = revisionMatch ? parseInt(revisionMatch[1], 10) : null;
      const created = createdMatch ? createdMatch[1] : null;
      const updated = updatedMatch ? updatedMatch[1] : null;
      function extractSection(tag) {
        const pattern = new RegExp(`<${tag}>([\\s\\S]*?)<\\/${tag}>`);
        const match = content.match(pattern);
        return match ? match[1].trim() : null;
      }
      const objectiveRaw = extractSection("objective");
      const objective = { statement: "", elaboration: "" };
      if (objectiveRaw) {
        const lines = objectiveRaw.split("\n");
        objective.statement = lines[0].trim();
        objective.elaboration = lines.slice(1).join("\n").trim();
      }
      const usersRaw = extractSection("users");
      const users = [];
      if (usersRaw) {
        const userLines = usersRaw.split("\n").filter((l) => l.match(/^\s*-\s+/));
        for (const line of userLines) {
          const text = line.replace(/^\s*-\s+/, "").trim();
          if (text) users.push({ text });
        }
      }
      const outcomesRaw = extractSection("outcomes");
      const outcomes = [];
      if (outcomesRaw) {
        const outcomePattern = /^\s*-\s+(DO-\d+)\s+\[(P[123])\]:\s*(.+)/;
        for (const line of outcomesRaw.split("\n")) {
          const match = line.match(outcomePattern);
          if (match) {
            outcomes.push({ id: match[1], priority: match[2], text: match[3].trim() });
          }
        }
      }
      const criteriaRaw = extractSection("criteria");
      const criteria = [];
      if (criteriaRaw) {
        const criteriaPattern = /^\s*-\s+(SC-\d+):\s*(.+)/;
        for (const line of criteriaRaw.split("\n")) {
          const match = line.match(criteriaPattern);
          if (match) {
            criteria.push({ id: match[1], text: match[2].trim() });
          }
        }
      }
      const constraintsRaw = extractSection("constraints");
      const constraints = { technical: [], business: [], timeline: [] };
      if (constraintsRaw) {
        const constraintPattern = /^\s*-\s+(C-\d+):\s*(.+)/;
        let currentType = null;
        for (const line of constraintsRaw.split("\n")) {
          if (/^###\s*Technical/i.test(line)) {
            currentType = "technical";
            continue;
          }
          if (/^###\s*Business/i.test(line)) {
            currentType = "business";
            continue;
          }
          if (/^###\s*Timeline/i.test(line)) {
            currentType = "timeline";
            continue;
          }
          if (currentType) {
            const match = line.match(constraintPattern);
            if (match) {
              constraints[currentType].push({ id: match[1], text: match[2].trim() });
            }
          }
        }
      }
      const healthRaw = extractSection("health");
      const health = { quantitative: [], qualitative: "" };
      if (healthRaw) {
        const healthPattern = /^\s*-\s+(HM-\d+):\s*(.+)/;
        let inQuantitative = false;
        let inQualitative = false;
        const qualLines = [];
        for (const line of healthRaw.split("\n")) {
          if (/^###\s*Quantitative/i.test(line)) {
            inQuantitative = true;
            inQualitative = false;
            continue;
          }
          if (/^###\s*Qualitative/i.test(line)) {
            inQualitative = true;
            inQuantitative = false;
            continue;
          }
          if (inQuantitative) {
            const match = line.match(healthPattern);
            if (match) {
              health.quantitative.push({ id: match[1], text: match[2].trim() });
            }
          }
          if (inQualitative && line.trim()) {
            qualLines.push(line.trim());
          }
        }
        health.qualitative = qualLines.join("\n");
      }
      const historyRaw = extractSection("history");
      const history = [];
      if (historyRaw) {
        let currentEntry = null;
        let currentChange = null;
        for (const line of historyRaw.split("\n")) {
          const milestoneMatch = line.match(/^###\s+(v[\d.]+)\s+[â€”â€“-]\s+(\d{4}-\d{2}-\d{2})/);
          if (milestoneMatch) {
            if (currentChange && currentEntry) currentEntry.changes.push(currentChange);
            currentChange = null;
            if (currentEntry) history.push(currentEntry);
            currentEntry = { milestone: milestoneMatch[1], date: milestoneMatch[2], changes: [] };
            continue;
          }
          const changeMatch = line.match(/^\s*-\s+\*\*(Added|Modified|Removed)\*\*\s+(.+?):\s*(.+)/);
          if (changeMatch && currentEntry) {
            if (currentChange) currentEntry.changes.push(currentChange);
            currentChange = { type: changeMatch[1], target: changeMatch[2], description: changeMatch[3].trim() };
            continue;
          }
          const reasonMatch = line.match(/^\s+-\s+Reason:\s*(.+)/);
          if (reasonMatch && currentChange) {
            currentChange.reason = reasonMatch[1].trim();
            continue;
          }
        }
        if (currentChange && currentEntry) currentEntry.changes.push(currentChange);
        if (currentEntry) history.push(currentEntry);
      }
      return {
        revision,
        created,
        updated,
        objective,
        users,
        outcomes,
        criteria,
        constraints,
        health,
        history
      };
    }
    function generateIntentMd(data) {
      const lines = [];
      lines.push(`**Revision:** ${data.revision || 1}`);
      lines.push(`**Created:** ${data.created || (/* @__PURE__ */ new Date()).toISOString().split("T")[0]}`);
      lines.push(`**Updated:** ${data.updated || (/* @__PURE__ */ new Date()).toISOString().split("T")[0]}`);
      lines.push("");
      lines.push("<objective>");
      if (data.objective && data.objective.statement) {
        lines.push(data.objective.statement);
        if (data.objective.elaboration) {
          lines.push("");
          lines.push(data.objective.elaboration);
        }
      } else {
        lines.push("<!-- Single statement: what this project does and why -->");
      }
      lines.push("</objective>");
      lines.push("");
      lines.push("<users>");
      if (data.users && data.users.length > 0) {
        for (const u of data.users) {
          lines.push(`- ${u.text}`);
        }
      } else {
        lines.push("<!-- Brief audience descriptions, one per line -->");
      }
      lines.push("</users>");
      lines.push("");
      lines.push("<outcomes>");
      if (data.outcomes && data.outcomes.length > 0) {
        for (const o of data.outcomes) {
          lines.push(`- ${o.id} [${o.priority}]: ${o.text}`);
        }
      } else {
        lines.push("<!-- Bullet list: - DO-XX [PX]: description -->");
      }
      lines.push("</outcomes>");
      lines.push("");
      lines.push("<criteria>");
      if (data.criteria && data.criteria.length > 0) {
        for (const c of data.criteria) {
          lines.push(`- ${c.id}: ${c.text}`);
        }
      } else {
        lines.push("<!-- Bullet list: - SC-XX: launch gate -->");
      }
      lines.push("</criteria>");
      lines.push("");
      lines.push("<constraints>");
      const hasTech = data.constraints && data.constraints.technical && data.constraints.technical.length > 0;
      const hasBiz = data.constraints && data.constraints.business && data.constraints.business.length > 0;
      const hasTime = data.constraints && data.constraints.timeline && data.constraints.timeline.length > 0;
      if (hasTech || hasBiz || hasTime) {
        if (hasTech) {
          lines.push("### Technical");
          for (const c of data.constraints.technical) {
            lines.push(`- ${c.id}: ${c.text}`);
          }
          lines.push("");
        }
        if (hasBiz) {
          lines.push("### Business");
          for (const c of data.constraints.business) {
            lines.push(`- ${c.id}: ${c.text}`);
          }
          lines.push("");
        }
        if (hasTime) {
          lines.push("### Timeline");
          for (const c of data.constraints.timeline) {
            lines.push(`- ${c.id}: ${c.text}`);
          }
          lines.push("");
        }
      } else {
        lines.push("<!-- Sub-headers: ### Technical, ### Business, ### Timeline. Items: - C-XX: constraint -->");
      }
      lines.push("</constraints>");
      lines.push("");
      lines.push("<health>");
      const hasQuant = data.health && data.health.quantitative && data.health.quantitative.length > 0;
      const hasQual = data.health && data.health.qualitative && data.health.qualitative.trim();
      if (hasQuant || hasQual) {
        if (hasQuant) {
          lines.push("### Quantitative");
          for (const m of data.health.quantitative) {
            lines.push(`- ${m.id}: ${m.text}`);
          }
          lines.push("");
        }
        if (hasQual) {
          lines.push("### Qualitative");
          lines.push(data.health.qualitative);
        }
      } else {
        lines.push("<!-- Sub-headers: ### Quantitative (- HM-XX: metric) and ### Qualitative (prose) -->");
      }
      lines.push("</health>");
      lines.push("");
      if (data.history && data.history.length > 0) {
        lines.push("<history>");
        for (const entry of data.history) {
          lines.push(`### ${entry.milestone} \u2014 ${entry.date}`);
          for (const change of entry.changes) {
            lines.push(`- **${change.type}** ${change.target}: ${change.description}`);
            if (change.reason) {
              lines.push(`  - Reason: ${change.reason}`);
            }
          }
          lines.push("");
        }
        lines.push("</history>");
        lines.push("");
      }
      return lines.join("\n");
    }
    function parsePlanIntent(content) {
      if (!content || typeof content !== "string") return null;
      const { extractFrontmatter } = require_frontmatter();
      const fm = extractFrontmatter(content);
      if (!fm || !fm.intent) return null;
      const intent = fm.intent;
      let outcomeIds = [];
      let rationale = "";
      const rawIds = intent.outcome_ids || intent["outcome_ids"];
      if (rawIds) {
        if (Array.isArray(rawIds)) {
          outcomeIds = rawIds;
        } else if (typeof rawIds === "string") {
          outcomeIds = rawIds.split(",").map((s) => s.trim()).filter(Boolean);
        }
      }
      const doPattern = /^DO-\d+$/;
      outcomeIds = outcomeIds.filter((id) => doPattern.test(id));
      rationale = intent.rationale || "";
      if (outcomeIds.length === 0 && !rationale) return null;
      return { outcome_ids: outcomeIds, rationale };
    }
    module2.exports = {
      safeReadFile,
      cachedReadFile,
      invalidateFileCache,
      cachedReaddirSync,
      getPhaseTree,
      normalizePhaseName,
      parseMustHavesBlock,
      sanitizeShellArg,
      isValidDateString,
      resolveModelInternal,
      getArchivedPhaseDirs,
      searchPhaseInDir,
      findPhaseInternal,
      getRoadmapPhaseInternal,
      pathExistsInternal,
      generateSlugInternal,
      getMilestoneInfo,
      invalidateMilestoneCache,
      extractAtReferences,
      parseIntentMd,
      generateIntentMd,
      parsePlanIntent
    };
  }
});

// src/lib/git.js
var require_git = __commonJS({
  "src/lib/git.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    var { execFileSync } = require("child_process");
    var { debugLog } = require_output();
    function execGit(cwd, args) {
      try {
        const stdout = execFileSync("git", args, {
          cwd,
          stdio: "pipe",
          encoding: "utf-8"
        });
        return { exitCode: 0, stdout: stdout.trim(), stderr: "" };
      } catch (err) {
        debugLog("git.exec", "exec failed", err);
        return {
          exitCode: err.status ?? 1,
          stdout: (err.stdout ?? "").toString().trim(),
          stderr: (err.stderr ?? "").toString().trim()
        };
      }
    }
    function structuredLog(cwd, opts = {}) {
      const count = opts.count || 20;
      const logArgs = ["log", `--format=%H|%an|%ae|%ai|%s`, `-${count}`];
      if (opts.since) logArgs.push(`--since=${opts.since}`);
      if (opts.until) logArgs.push(`--until=${opts.until}`);
      if (opts.author) logArgs.push(`--author=${opts.author}`);
      if (opts.path) logArgs.push("--", opts.path);
      const logResult = execGit(cwd, logArgs);
      if (logResult.exitCode !== 0 || !logResult.stdout) {
        return { error: logResult.stderr || "No commits found" };
      }
      const lines = logResult.stdout.split("\n").filter(Boolean);
      const commits = [];
      for (const line of lines) {
        const parts = line.split("|");
        if (parts.length < 5) continue;
        const hash = parts[0];
        const author = parts[1];
        const email = parts[2];
        const date = parts[3];
        const message = parts.slice(4).join("|");
        const statResult = execGit(cwd, ["diff-tree", "--no-commit-id", "--numstat", "-r", hash]);
        const files = [];
        let totalInsertions = 0;
        let totalDeletions = 0;
        if (statResult.exitCode === 0 && statResult.stdout) {
          for (const statLine of statResult.stdout.split("\n").filter(Boolean)) {
            const [ins, del, filePath] = statLine.split("	");
            const insertions = ins === "-" ? 0 : parseInt(ins, 10) || 0;
            const deletions = del === "-" ? 0 : parseInt(del, 10) || 0;
            files.push({ path: filePath, insertions, deletions, binary: ins === "-" });
            totalInsertions += insertions;
            totalDeletions += deletions;
          }
        }
        let conventional = null;
        const ccMatch = message.match(/^(\w+)(?:\(([^)]*)\))?:\s*(.+)$/);
        if (ccMatch) {
          conventional = { type: ccMatch[1], scope: ccMatch[2] || null, description: ccMatch[3] };
        }
        commits.push({
          hash,
          author,
          email,
          date,
          message,
          conventional,
          files,
          file_count: files.length,
          total_insertions: totalInsertions,
          total_deletions: totalDeletions
        });
      }
      return commits;
    }
    function diffSummary(cwd, opts = {}) {
      const from = opts.from || "HEAD~1";
      const to = opts.to || "HEAD";
      const diffArgs = ["diff", "--numstat", from, to];
      if (opts.path) diffArgs.push("--", opts.path);
      const result = execGit(cwd, diffArgs);
      if (result.exitCode !== 0) {
        return { error: result.stderr || "diff failed" };
      }
      const files = [];
      let totalInsertions = 0;
      let totalDeletions = 0;
      if (result.stdout) {
        for (const line of result.stdout.split("\n").filter(Boolean)) {
          const [ins, del, filePath] = line.split("	");
          const insertions = ins === "-" ? 0 : parseInt(ins, 10) || 0;
          const deletions = del === "-" ? 0 : parseInt(del, 10) || 0;
          files.push({ path: filePath, insertions, deletions, binary: ins === "-" });
          totalInsertions += insertions;
          totalDeletions += deletions;
        }
      }
      return {
        from,
        to,
        files,
        file_count: files.length,
        total_insertions: totalInsertions,
        total_deletions: totalDeletions
      };
    }
    function blame(cwd, filePath) {
      if (!filePath) {
        return { error: "file path required" };
      }
      const result = execGit(cwd, ["blame", "--porcelain", filePath]);
      if (result.exitCode !== 0) {
        return { error: result.stderr || "blame failed" };
      }
      const lines = [];
      const uniqueAuthors = /* @__PURE__ */ new Set();
      const uniqueCommits = /* @__PURE__ */ new Set();
      const rawLines = result.stdout.split("\n");
      let currentHash = null;
      let currentAuthor = null;
      let currentDate = null;
      let lineNumber = 0;
      for (const raw of rawLines) {
        const commitMatch = raw.match(/^([0-9a-f]{40})\s+(\d+)\s+(\d+)/);
        if (commitMatch) {
          currentHash = commitMatch[1];
          lineNumber = parseInt(commitMatch[3], 10);
          uniqueCommits.add(currentHash);
          continue;
        }
        if (raw.startsWith("author ")) {
          currentAuthor = raw.slice(7);
          uniqueAuthors.add(currentAuthor);
          continue;
        }
        if (raw.startsWith("author-time ")) {
          const epoch = parseInt(raw.slice(12), 10);
          currentDate = new Date(epoch * 1e3).toISOString();
          continue;
        }
        if (raw.startsWith("	")) {
          lines.push({
            line_number: lineNumber,
            hash: currentHash,
            author: currentAuthor,
            date: currentDate,
            content: raw.slice(1)
          });
        }
      }
      return {
        file: filePath,
        lines,
        unique_authors: [...uniqueAuthors],
        unique_commits: [...uniqueCommits]
      };
    }
    function branchInfo(cwd) {
      const branchResult = execGit(cwd, ["rev-parse", "--abbrev-ref", "HEAD"]);
      const branch = branchResult.exitCode === 0 ? branchResult.stdout : null;
      const headResult = execGit(cwd, ["rev-parse", "HEAD"]);
      const headSha = headResult.exitCode === 0 ? headResult.stdout : null;
      const isDetached = branch === "HEAD";
      const shallowResult = execGit(cwd, ["rev-parse", "--is-shallow-repository"]);
      const isShallow = shallowResult.exitCode === 0 && shallowResult.stdout === "true";
      const statusResult = execGit(cwd, ["status", "--porcelain"]);
      const dirtyLines = statusResult.exitCode === 0 && statusResult.stdout ? statusResult.stdout.split("\n").filter(Boolean) : [];
      const hasDirtyFiles = dirtyLines.length > 0;
      const dirtyFileCount = dirtyLines.length;
      let gitDir = cwd;
      try {
        const gitDirResult = execGit(cwd, ["rev-parse", "--git-dir"]);
        if (gitDirResult.exitCode === 0) {
          gitDir = path.resolve(cwd, gitDirResult.stdout);
        }
      } catch (e) {
        debugLog("git.branchInfo", "git-dir resolution failed", e);
      }
      const isRebasing = fs.existsSync(path.join(gitDir, "rebase-merge")) || fs.existsSync(path.join(gitDir, "rebase-apply"));
      let upstream = null;
      if (!isDetached) {
        const upstreamResult = execGit(cwd, ["rev-list", "--left-right", "--count", "HEAD...@{upstream}"]);
        if (upstreamResult.exitCode === 0 && upstreamResult.stdout) {
          const [ahead, behind] = upstreamResult.stdout.split("	").map(Number);
          const upstreamNameResult = execGit(cwd, ["rev-parse", "--abbrev-ref", "@{upstream}"]);
          if (upstreamNameResult.exitCode === 0) {
            const parts = upstreamNameResult.stdout.split("/");
            upstream = {
              remote: parts[0],
              branch: parts.slice(1).join("/"),
              ahead: ahead || 0,
              behind: behind || 0
            };
          }
        }
      }
      return {
        branch,
        head_sha: headSha,
        is_detached: isDetached,
        is_shallow: isShallow,
        has_dirty_files: hasDirtyFiles,
        dirty_file_count: dirtyFileCount,
        is_rebasing: isRebasing,
        upstream
      };
    }
    module2.exports = { execGit, structuredLog, diffSummary, blame, branchInfo };
  }
});

// src/lib/format.js
var require_format = __commonJS({
  "src/lib/format.js"(exports2, module2) {
    "use strict";
    function getTerminalWidth() {
      return process.stdout.columns || 80;
    }
    function isTTY() {
      return !!process.stdout.isTTY;
    }
    var _colorEnabled = (() => {
      if ("NO_COLOR" in process.env) return false;
      if (!process.stdout.isTTY) return false;
      if (process.env.FORCE_COLOR) return true;
      return true;
    })();
    function _wrap(open, close) {
      if (!_colorEnabled) return (s) => String(s);
      return (s) => `\x1B[${open}m${s}\x1B[${close}m`;
    }
    var color = {
      enabled: _colorEnabled,
      // Modifiers
      bold: _wrap("1", "22"),
      dim: _wrap("2", "22"),
      underline: _wrap("4", "24"),
      // Colors
      red: _wrap("31", "39"),
      green: _wrap("32", "39"),
      yellow: _wrap("33", "39"),
      blue: _wrap("34", "39"),
      magenta: _wrap("35", "39"),
      cyan: _wrap("36", "39"),
      white: _wrap("37", "39"),
      gray: _wrap("90", "39")
    };
    function colorByPercent(percent) {
      if (percent <= 33) return color.red;
      if (percent <= 66) return color.yellow;
      return color.green;
    }
    var SYMBOLS = {
      check: "\u2713",
      // âœ“
      cross: "\u2717",
      // âœ—
      progress: "\u25B6",
      // â–¶
      pending: "\u25CB",
      // â—‹
      warning: "\u26A0",
      // âš 
      arrow: "\u2192",
      // â†’
      bullet: "\u2022",
      // â€¢
      dash: "\u2500",
      // â”€
      heavyDash: "\u2501"
      // â”
    };
    var _ansiRegex = /\x1b\[[0-9;]*m/g;
    function stripAnsi(text) {
      return String(text).replace(_ansiRegex, "");
    }
    function truncate(text, maxWidth) {
      const str = String(text);
      const visible = stripAnsi(str);
      if (visible.length <= maxWidth) return str;
      if (maxWidth <= 1) return "\u2026";
      return visible.slice(0, maxWidth - 1) + "\u2026";
    }
    function relativeTime(dateStr) {
      const then = new Date(dateStr);
      if (isNaN(then.getTime())) return String(dateStr);
      const now = /* @__PURE__ */ new Date();
      const diffMs = now - then;
      const diffSec = Math.floor(diffMs / 1e3);
      const diffMin = Math.floor(diffSec / 60);
      const diffHr = Math.floor(diffMin / 60);
      const diffDay = Math.floor(diffHr / 24);
      if (diffSec < 0) return "in the future";
      if (diffSec < 60) return "just now";
      if (diffMin < 60) return `${diffMin}m ago`;
      if (diffHr < 24) return `${diffHr}h ago`;
      if (diffDay === 1) return "yesterday";
      if (diffDay < 30) return `${diffDay} days ago`;
      if (diffDay < 365) {
        const months = Math.floor(diffDay / 30);
        return `${months} month${months > 1 ? "s" : ""} ago`;
      }
      const years = Math.floor(diffDay / 365);
      return `${years} year${years > 1 ? "s" : ""} ago`;
    }
    function pad(text, width, align = "left") {
      const str = String(text);
      const visible = stripAnsi(str);
      const diff = width - visible.length;
      if (diff <= 0) return str;
      if (align === "right") return " ".repeat(diff) + str;
      if (align === "center") {
        const left = Math.floor(diff / 2);
        const right = diff - left;
        return " ".repeat(left) + str + " ".repeat(right);
      }
      return str + " ".repeat(diff);
    }
    function formatTable(headers, rows, options = {}) {
      const {
        maxWidth = getTerminalWidth(),
        truncate: doTruncate = true,
        borders = false,
        indent = 1,
        colorFn = null,
        maxRows = 10,
        showAll = false
      } = options;
      if (!headers || headers.length === 0) return "";
      const indentStr = " ".repeat(indent);
      const colGap = 2;
      const colCount = headers.length;
      const colWidths = headers.map((h) => stripAnsi(String(h)).length);
      for (const row of rows) {
        for (let i = 0; i < colCount; i++) {
          const cellLen = stripAnsi(String(row[i] || "")).length;
          if (cellLen > colWidths[i]) colWidths[i] = cellLen;
        }
      }
      const totalGap = (colCount - 1) * colGap + indent;
      const availableWidth = maxWidth - totalGap;
      const totalColWidth = colWidths.reduce((a, b) => a + b, 0);
      if (totalColWidth > availableWidth && availableWidth > 0) {
        const ratio = availableWidth / totalColWidth;
        for (let i = 0; i < colCount; i++) {
          colWidths[i] = Math.max(4, Math.floor(colWidths[i] * ratio));
        }
      }
      const headerCells = headers.map(
        (h, i) => color.bold(pad(truncateCell(String(h), colWidths[i], doTruncate), colWidths[i]))
      );
      const headerLine = indentStr + headerCells.join(" ".repeat(colGap));
      const sepWidth = colWidths.reduce((a, b) => a + b, 0) + (colCount - 1) * colGap;
      const separator = indentStr + SYMBOLS.dash.repeat(sepWidth);
      const displayRows = !showAll && rows.length > maxRows ? rows.slice(0, maxRows) : rows;
      const rowLines = displayRows.map((row, rowIdx) => {
        const cells = [];
        for (let i = 0; i < colCount; i++) {
          let cellText = String(row[i] != null ? row[i] : "");
          cellText = truncateCell(cellText, colWidths[i], doTruncate);
          if (colorFn) {
            cellText = colorFn(row[i], i, rowIdx);
            cellText = truncateCell(String(cellText), colWidths[i], doTruncate);
          }
          cells.push(pad(cellText, colWidths[i]));
        }
        return indentStr + cells.join(" ".repeat(colGap));
      });
      const lines = [headerLine, separator, ...rowLines];
      if (!showAll && rows.length > maxRows) {
        const remaining = rows.length - maxRows;
        lines.push(indentStr + color.dim(`... and ${remaining} more (use --all to see full list)`));
      }
      return lines.join("\n");
    }
    function truncateCell(text, maxWidth, doTruncate) {
      if (!doTruncate) return text;
      return truncate(text, maxWidth);
    }
    function progressBar(percent, width = 20) {
      const pct = Math.max(0, Math.min(100, Math.round(percent)));
      const filled = Math.round(pct / 100 * width);
      const empty = width - filled;
      const bar = "\u2588".repeat(filled) + "\u2591".repeat(empty);
      const colorFn = colorByPercent(pct);
      const pctStr = String(pct).padStart(3) + "%";
      return `${colorFn(pctStr)} [${colorFn(bar)}]`;
    }
    function sectionHeader(label) {
      const termWidth = getTerminalWidth();
      const prefix = SYMBOLS.heavyDash.repeat(2) + " ";
      const labelStr = color.bold(color.cyan(label));
      const labelLen = stripAnsi(label).length;
      const suffixLen = Math.max(4, termWidth - 2 - 1 - labelLen - 1);
      const suffix = " " + SYMBOLS.heavyDash.repeat(suffixLen);
      return prefix + labelStr + suffix;
    }
    function banner(title, options = {}) {
      const { completion = false } = options;
      const termWidth = getTerminalWidth();
      if (completion) {
        const rule2 = SYMBOLS.heavyDash.repeat(Math.min(termWidth, 60));
        const line = `${SYMBOLS.check} ${title}`;
        return [
          color.green(rule2),
          color.bold(color.green(line)),
          color.green(rule2)
        ].join("\n");
      }
      const prefix = color.dim("bGSD") + " " + color.cyan(SYMBOLS.progress) + " ";
      const titleStr = color.bold(title);
      const ruleLen = Math.min(termWidth, 60);
      const rule = color.dim(SYMBOLS.dash.repeat(ruleLen));
      return prefix + titleStr + "\n" + rule;
    }
    var _boxPrefixes = {
      info: { fn: color.cyan, label: "INFO" },
      warning: { fn: color.yellow, label: "WARNING" },
      error: { fn: color.red, label: "ERROR" },
      success: { fn: color.green, label: "SUCCESS" }
    };
    function box(content, type = "info") {
      const termWidth = getTerminalWidth();
      const ruleLen = Math.min(termWidth, 60);
      const cfg = _boxPrefixes[type] || _boxPrefixes.info;
      const topRule = cfg.fn(SYMBOLS.dash.repeat(ruleLen));
      const prefix = cfg.fn(color.bold(cfg.label + ":"));
      const bottomRule = cfg.fn(SYMBOLS.dash.repeat(ruleLen));
      return [topRule, prefix + " " + content, bottomRule].join("\n");
    }
    function summaryLine(text) {
      const ruleLen = Math.min(getTerminalWidth(), 60);
      const rule = color.dim(SYMBOLS.dash.repeat(ruleLen));
      return rule + "\n" + color.bold(text);
    }
    function actionHint(text) {
      return color.dim(SYMBOLS.arrow + " " + text);
    }
    function listWithTruncation(items, maxItems = 10, showAll = false) {
      if (!items || items.length === 0) return "";
      const display = !showAll && items.length > maxItems ? items.slice(0, maxItems) : items;
      const lines = display.map((item, i) => ` ${i + 1}. ${item}`);
      if (!showAll && items.length > maxItems) {
        const remaining = items.length - maxItems;
        lines.push(color.dim(` ... and ${remaining} more (use --all to see full list)`));
      }
      return lines.join("\n");
    }
    module2.exports = {
      // Terminal
      getTerminalWidth,
      isTTY,
      // Color
      color,
      colorByPercent,
      // Symbols
      SYMBOLS,
      // Helpers
      stripAnsi,
      truncate,
      relativeTime,
      pad,
      // Renderers
      formatTable,
      progressBar,
      sectionHeader,
      banner,
      box,
      summaryLine,
      actionHint,
      listWithTruncation
    };
  }
});

// src/commands/state.js
var require_state = __commonJS({
  "src/commands/state.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    var { output, error, debugLog } = require_output();
    var { loadConfig } = require_config();
    var { safeReadFile, cachedReadFile, invalidateFileCache, normalizePhaseName, findPhaseInternal, getPhaseTree } = require_helpers();
    var { execGit } = require_git();
    var { banner, sectionHeader, formatTable, summaryLine, actionHint, color, SYMBOLS, progressBar, box } = require_format();
    var _fieldRegexCache = /* @__PURE__ */ new Map();
    function getFieldExtractRegex(fieldName) {
      const key = `extract:${fieldName}`;
      if (_fieldRegexCache.has(key)) return _fieldRegexCache.get(key);
      const pattern = new RegExp(`\\*\\*${fieldName}:\\*\\*\\s*(.+)`, "i");
      _fieldRegexCache.set(key, pattern);
      return pattern;
    }
    function getFieldReplaceRegex(fieldName) {
      const key = `replace:${fieldName}`;
      if (_fieldRegexCache.has(key)) return _fieldRegexCache.get(key);
      const escaped = fieldName.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      const pattern = new RegExp(`(\\*\\*${escaped}:\\*\\*\\s*)(.*)`, "i");
      _fieldRegexCache.set(key, pattern);
      return pattern;
    }
    function formatStateShow(result) {
      const lines = [];
      const c = result.config || {};
      lines.push(banner("State"));
      lines.push("");
      lines.push(sectionHeader("Configuration"));
      const configItems = [
        ["model_profile", c.model_profile || "default"],
        ["commit_docs", String(c.commit_docs ?? "true")],
        ["branching_strategy", c.branching_strategy || "none"],
        ["parallelization", String(c.parallelization ?? "false")]
      ];
      for (const [key, val] of configItems) {
        lines.push(` ${color.dim(key + ":")} ${val}`);
      }
      lines.push("");
      lines.push(sectionHeader("Files"));
      const fileChecks = [
        ["STATE.md", result.state_exists],
        ["ROADMAP.md", result.roadmap_exists],
        ["config.json", result.config_exists]
      ];
      for (const [name, exists] of fileChecks) {
        const icon = exists ? color.green(SYMBOLS.check) : color.red(SYMBOLS.cross);
        lines.push(` ${icon} ${name}`);
      }
      lines.push("");
      lines.push(summaryLine("State loaded"));
      return lines.join("\n");
    }
    function formatStateUpdateProgress(result) {
      const lines = [];
      if (result.updated) {
        lines.push(box(`Progress updated: ${result.percent}%`, "success"));
        lines.push("");
        lines.push(progressBar(result.percent));
        lines.push(` ${result.completed}/${result.total} plans`);
      } else {
        lines.push(box(result.reason || "Update failed", "warning"));
      }
      return lines.join("\n");
    }
    function cmdStateLoad(cwd, raw) {
      const config = loadConfig(cwd);
      const planningDir = path.join(cwd, ".planning");
      const stateContent = cachedReadFile(path.join(planningDir, "STATE.md"));
      const stateRaw = stateContent || "";
      const stateExists = stateRaw.length > 0;
      let configExists = false;
      let roadmapExists = false;
      try {
        fs.statSync(path.join(planningDir, "config.json"));
        configExists = true;
      } catch {
      }
      try {
        fs.statSync(path.join(planningDir, "ROADMAP.md"));
        roadmapExists = true;
      } catch {
      }
      const result = {
        config,
        state_raw: stateRaw,
        state_exists: stateExists,
        roadmap_exists: roadmapExists,
        config_exists: configExists
      };
      const c = config;
      const rawLines = [
        `model_profile=${c.model_profile}`,
        `commit_docs=${c.commit_docs}`,
        `branching_strategy=${c.branching_strategy}`,
        `phase_branch_template=${c.phase_branch_template}`,
        `milestone_branch_template=${c.milestone_branch_template}`,
        `parallelization=${c.parallelization}`,
        `research=${c.research}`,
        `plan_checker=${c.plan_checker}`,
        `verifier=${c.verifier}`,
        `config_exists=${configExists}`,
        `roadmap_exists=${roadmapExists}`,
        `state_exists=${stateExists}`
      ].join("\n");
      output(result, { formatter: formatStateShow, rawValue: rawLines });
    }
    function cmdStateGet(cwd, section, raw) {
      const statePath = path.join(cwd, ".planning", "STATE.md");
      const content = cachedReadFile(statePath);
      if (!content) {
        error("STATE.md not found");
      }
      if (!section) {
        output({ content }, raw, content);
        return;
      }
      const fieldMatch = content.match(getFieldReplaceRegex(section));
      if (fieldMatch) {
        const val = fieldMatch[2].trim();
        output({ [section]: val }, raw, val);
        return;
      }
      const fieldEscaped = section.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      const sectionPattern = new RegExp(`##\\s*${fieldEscaped}\\s*
([\\s\\S]*?)(?=\\n##|$)`, "i");
      const sectionMatch = content.match(sectionPattern);
      if (sectionMatch) {
        output({ [section]: sectionMatch[1].trim() }, raw, sectionMatch[1].trim());
        return;
      }
      output({ error: `Section or field "${section}" not found` }, raw, "");
    }
    function cmdStatePatch(cwd, patches, raw) {
      const statePath = path.join(cwd, ".planning", "STATE.md");
      let content = cachedReadFile(statePath);
      if (!content) {
        error("STATE.md not found");
      }
      const results = { updated: [], failed: [] };
      for (const [field, value] of Object.entries(patches)) {
        const pattern = getFieldReplaceRegex(field);
        if (pattern.test(content)) {
          content = content.replace(pattern, `$1${value}`);
          results.updated.push(field);
        } else {
          results.failed.push(field);
        }
      }
      if (results.updated.length > 0) {
        fs.writeFileSync(statePath, content, "utf-8");
        invalidateFileCache(statePath);
      }
      output(results, raw, results.updated.length > 0 ? "true" : "false");
    }
    function cmdStateUpdate(cwd, field, value) {
      if (!field || value === void 0) {
        error("field and value required for state update");
      }
      const statePath = path.join(cwd, ".planning", "STATE.md");
      let content = cachedReadFile(statePath);
      if (!content) {
        output({ updated: false, reason: "STATE.md not found" });
        return;
      }
      const pattern = getFieldReplaceRegex(field);
      if (pattern.test(content)) {
        content = content.replace(pattern, `$1${value}`);
        fs.writeFileSync(statePath, content, "utf-8");
        invalidateFileCache(statePath);
        output({ updated: true });
      } else {
        output({ updated: false, reason: `Field "${field}" not found in STATE.md` });
      }
    }
    function stateExtractField(content, fieldName) {
      const pattern = getFieldExtractRegex(fieldName);
      const match = content.match(pattern);
      return match ? match[1].trim() : null;
    }
    function stateReplaceField(content, fieldName, newValue) {
      const pattern = getFieldReplaceRegex(fieldName);
      if (pattern.test(content)) {
        return content.replace(pattern, `$1${newValue}`);
      }
      return null;
    }
    function cmdStateAdvancePlan(cwd, raw) {
      const statePath = path.join(cwd, ".planning", "STATE.md");
      let content = cachedReadFile(statePath);
      if (!content) {
        output({ error: "STATE.md not found" }, raw);
        return;
      }
      const currentPlan = parseInt(stateExtractField(content, "Current Plan"), 10);
      const totalPlans = parseInt(stateExtractField(content, "Total Plans in Phase"), 10);
      const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      if (isNaN(currentPlan) || isNaN(totalPlans)) {
        output({ error: "Cannot parse Current Plan or Total Plans in Phase from STATE.md" }, raw);
        return;
      }
      if (currentPlan >= totalPlans) {
        content = stateReplaceField(content, "Status", "Phase complete \u2014 ready for verification") || content;
        content = stateReplaceField(content, "Last Activity", today) || content;
        fs.writeFileSync(statePath, content, "utf-8");
        invalidateFileCache(statePath);
        output({ advanced: false, reason: "last_plan", current_plan: currentPlan, total_plans: totalPlans, status: "ready_for_verification" }, raw, "false");
      } else {
        const newPlan = currentPlan + 1;
        content = stateReplaceField(content, "Current Plan", String(newPlan)) || content;
        content = stateReplaceField(content, "Status", "Ready to execute") || content;
        content = stateReplaceField(content, "Last Activity", today) || content;
        fs.writeFileSync(statePath, content, "utf-8");
        invalidateFileCache(statePath);
        output({ advanced: true, previous_plan: currentPlan, current_plan: newPlan, total_plans: totalPlans }, raw, "true");
      }
    }
    function cmdStateRecordMetric(cwd, options, raw) {
      const statePath = path.join(cwd, ".planning", "STATE.md");
      let content = cachedReadFile(statePath);
      if (!content) {
        output({ error: "STATE.md not found" }, raw);
        return;
      }
      const { phase, plan, duration, tasks, files } = options;
      if (!phase || !plan || !duration) {
        output({ error: "phase, plan, and duration required" }, raw);
        return;
      }
      const metricsPattern = /(##\s*Performance Metrics[\s\S]*?\n\|[^\n]+\n\|[-|\s]+\n)([\s\S]*?)(?=\n##|\n$|$)/i;
      const metricsMatch = content.match(metricsPattern);
      if (metricsMatch) {
        const tableHeader = metricsMatch[1];
        let tableBody = metricsMatch[2].trimEnd();
        const newRow = `| Phase ${phase} P${plan} | ${duration} | ${tasks || "-"} tasks | ${files || "-"} files |`;
        if (tableBody.trim() === "" || tableBody.includes("None yet")) {
          tableBody = newRow;
        } else {
          tableBody = tableBody + "\n" + newRow;
        }
        content = content.replace(metricsPattern, `${tableHeader}${tableBody}
`);
        fs.writeFileSync(statePath, content, "utf-8");
        invalidateFileCache(statePath);
        output({ recorded: true, phase, plan, duration }, raw, "true");
      } else {
        output({ recorded: false, reason: "Performance Metrics section not found in STATE.md" }, raw, "false");
      }
    }
    function cmdStateUpdateProgress(cwd, raw) {
      const statePath = path.join(cwd, ".planning", "STATE.md");
      let content = cachedReadFile(statePath);
      if (!content) {
        output({ error: "STATE.md not found" }, raw);
        return;
      }
      let totalPlans = 0;
      let totalSummaries = 0;
      const phaseTree = getPhaseTree(cwd);
      for (const [, entry] of phaseTree) {
        totalPlans += entry.plans.length;
        totalSummaries += entry.summaries.length;
      }
      const percent = totalPlans > 0 ? Math.round(totalSummaries / totalPlans * 100) : 0;
      const barWidth = 10;
      const filled = Math.round(percent / 100 * barWidth);
      const bar = "\u2588".repeat(filled) + "\u2591".repeat(barWidth - filled);
      const progressStr = `[${bar}] ${percent}%`;
      const progressPattern = /(\*\*Progress:\*\*\s*).*/i;
      if (progressPattern.test(content)) {
        content = content.replace(progressPattern, `$1${progressStr}`);
        fs.writeFileSync(statePath, content, "utf-8");
        invalidateFileCache(statePath);
        output({ updated: true, percent, completed: totalSummaries, total: totalPlans, bar: progressStr }, { formatter: formatStateUpdateProgress, rawValue: progressStr });
      } else {
        output({ updated: false, reason: "Progress field not found in STATE.md" }, { formatter: formatStateUpdateProgress, rawValue: "false" });
      }
    }
    function cmdStateAddDecision(cwd, options, raw) {
      const statePath = path.join(cwd, ".planning", "STATE.md");
      let content = cachedReadFile(statePath);
      if (!content) {
        output({ error: "STATE.md not found" }, raw);
        return;
      }
      const { phase, summary, rationale } = options;
      if (!summary) {
        output({ error: "summary required" }, raw);
        return;
      }
      const entry = `- [Phase ${phase || "?"}]: ${summary}${rationale ? ` \u2014 ${rationale}` : ""}`;
      const sectionPattern = /(###?\s*(?:Decisions|Decisions Made|Accumulated.*Decisions)\s*\n)([\s\S]*?)(?=\n###?|\n##[^#]|$)/i;
      const match = content.match(sectionPattern);
      if (match) {
        let sectionBody = match[2];
        sectionBody = sectionBody.replace(/None yet\.?\s*\n?/gi, "").replace(/No decisions yet\.?\s*\n?/gi, "");
        sectionBody = sectionBody.trimEnd() + "\n" + entry + "\n";
        content = content.replace(sectionPattern, `${match[1]}${sectionBody}`);
        fs.writeFileSync(statePath, content, "utf-8");
        invalidateFileCache(statePath);
        output({ added: true, decision: entry }, raw, "true");
      } else {
        output({ added: false, reason: "Decisions section not found in STATE.md" }, raw, "false");
      }
    }
    function cmdStateAddBlocker(cwd, text, raw) {
      const statePath = path.join(cwd, ".planning", "STATE.md");
      let content = cachedReadFile(statePath);
      if (!content) {
        output({ error: "STATE.md not found" }, raw);
        return;
      }
      if (!text) {
        output({ error: "text required" }, raw);
        return;
      }
      const entry = `- ${text}`;
      const sectionPattern = /(###?\s*(?:Blockers|Blockers\/Concerns|Concerns)\s*\n)([\s\S]*?)(?=\n###?|\n##[^#]|$)/i;
      const match = content.match(sectionPattern);
      if (match) {
        let sectionBody = match[2];
        sectionBody = sectionBody.replace(/None\.?\s*\n?/gi, "").replace(/None yet\.?\s*\n?/gi, "");
        sectionBody = sectionBody.trimEnd() + "\n" + entry + "\n";
        content = content.replace(sectionPattern, `${match[1]}${sectionBody}`);
        fs.writeFileSync(statePath, content, "utf-8");
        invalidateFileCache(statePath);
        output({ added: true, blocker: text }, raw, "true");
      } else {
        output({ added: false, reason: "Blockers section not found in STATE.md" }, raw, "false");
      }
    }
    function cmdStateResolveBlocker(cwd, text, raw) {
      const statePath = path.join(cwd, ".planning", "STATE.md");
      let content = cachedReadFile(statePath);
      if (!content) {
        output({ error: "STATE.md not found" }, raw);
        return;
      }
      if (!text) {
        output({ error: "text required" }, raw);
        return;
      }
      const sectionPattern = /(###?\s*(?:Blockers|Blockers\/Concerns|Concerns)\s*\n)([\s\S]*?)(?=\n###?|\n##[^#]|$)/i;
      const match = content.match(sectionPattern);
      if (match) {
        const sectionBody = match[2];
        const lines = sectionBody.split("\n");
        const filtered = lines.filter((line) => {
          if (!line.startsWith("- ")) return true;
          return !line.toLowerCase().includes(text.toLowerCase());
        });
        let newBody = filtered.join("\n");
        if (!newBody.trim() || !newBody.includes("- ")) {
          newBody = "None\n";
        }
        content = content.replace(sectionPattern, `${match[1]}${newBody}`);
        fs.writeFileSync(statePath, content, "utf-8");
        invalidateFileCache(statePath);
        output({ resolved: true, blocker: text }, raw, "true");
      } else {
        output({ resolved: false, reason: "Blockers section not found in STATE.md" }, raw, "false");
      }
    }
    function cmdStateRecordSession(cwd, options, raw) {
      const statePath = path.join(cwd, ".planning", "STATE.md");
      let content = cachedReadFile(statePath);
      if (!content) {
        output({ error: "STATE.md not found" }, raw);
        return;
      }
      const now = (/* @__PURE__ */ new Date()).toISOString();
      const updated = [];
      let result = stateReplaceField(content, "Last session", now);
      if (result) {
        content = result;
        updated.push("Last session");
      }
      result = stateReplaceField(content, "Last Date", now);
      if (result) {
        content = result;
        updated.push("Last Date");
      }
      if (options.stopped_at) {
        result = stateReplaceField(content, "Stopped At", options.stopped_at);
        if (!result) result = stateReplaceField(content, "Stopped at", options.stopped_at);
        if (result) {
          content = result;
          updated.push("Stopped At");
        }
      }
      const resumeFile = options.resume_file || "None";
      result = stateReplaceField(content, "Resume File", resumeFile);
      if (!result) result = stateReplaceField(content, "Resume file", resumeFile);
      if (result) {
        content = result;
        updated.push("Resume File");
      }
      if (updated.length > 0) {
        fs.writeFileSync(statePath, content, "utf-8");
        invalidateFileCache(statePath);
        output({ recorded: true, updated }, raw, "true");
      } else {
        output({ recorded: false, reason: "No session fields found in STATE.md" }, raw, "false");
      }
    }
    function cmdStateValidate(cwd, options, raw) {
      const planningDir = path.join(cwd, ".planning");
      const roadmapPath = path.join(planningDir, "ROADMAP.md");
      const statePath = path.join(planningDir, "STATE.md");
      const phasesDir = path.join(planningDir, "phases");
      const issues = [];
      const fixesApplied = [];
      const roadmapContent = safeReadFile(roadmapPath);
      const stateContent = safeReadFile(statePath);
      if (!roadmapContent && !stateContent) {
        output({
          status: "errors",
          issues: [{ type: "missing_files", location: ".planning/", expected: "ROADMAP.md and STATE.md", actual: "Neither found", severity: "error" }],
          fixes_applied: [],
          summary: "Found 1 error and 0 warnings"
        }, raw);
        return;
      }
      if (roadmapContent) {
        const phasePattern = /#{2,4}\s*Phase\s+(\d+(?:\.\d+)?)\s*:\s*([^\n]+)/gi;
        let phaseMatch;
        while ((phaseMatch = phasePattern.exec(roadmapContent)) !== null) {
          const phaseNum = phaseMatch[1];
          const normalized = normalizePhaseName(phaseNum);
          const sectionStart = phaseMatch.index;
          const restOfContent = roadmapContent.slice(sectionStart);
          const nextHeader = restOfContent.match(/\n#{2,4}\s+Phase\s+\d/i);
          const sectionEnd = nextHeader ? sectionStart + nextHeader.index : roadmapContent.length;
          const section = roadmapContent.slice(sectionStart, sectionEnd);
          const plansMatch = section.match(/\*\*Plans:?\*\*:?\s*(?:(\d+)\/)?(\d+)\s*plan/i);
          const claimedPlanCount = plansMatch ? parseInt(plansMatch[2], 10) : null;
          const claimedSummaryCount = plansMatch && plansMatch[1] ? parseInt(plansMatch[1], 10) : null;
          let diskPlanCount = 0;
          let diskSummaryCount = 0;
          let phaseDirName = null;
          const phaseTree = getPhaseTree(cwd);
          const cachedPhase = phaseTree.get(normalized);
          if (cachedPhase) {
            phaseDirName = cachedPhase.dirName;
            diskPlanCount = cachedPhase.plans.length;
            diskSummaryCount = cachedPhase.summaries.length;
          }
          if (claimedPlanCount !== null && claimedPlanCount !== diskPlanCount && phaseDirName) {
            issues.push({
              type: "plan_count_drift",
              location: `ROADMAP.md Phase ${phaseNum}`,
              expected: `${diskPlanCount} plans on disk`,
              actual: `ROADMAP claims ${claimedPlanCount} plans`,
              severity: "error"
            });
            if (options.fix) {
              try {
                let updatedRoadmap = safeReadFile(roadmapPath) || roadmapContent;
                const phaseEscaped = phaseNum.replace(/\./g, "\\.");
                const fixPattern = new RegExp(
                  `(#{2,4}\\s*Phase\\s+${phaseEscaped}[\\s\\S]*?\\*\\*Plans:?\\*\\*:?\\s*)(?:\\d+\\/)?\\d+(\\s*plan)`,
                  "i"
                );
                const fixMatch = updatedRoadmap.match(fixPattern);
                if (fixMatch) {
                  const newText = claimedSummaryCount !== null ? `${fixMatch[1]}${diskSummaryCount}/${diskPlanCount}${fixMatch[2]}` : `${fixMatch[1]}${diskPlanCount}${fixMatch[2]}`;
                  updatedRoadmap = updatedRoadmap.replace(fixPattern, newText);
                  fs.writeFileSync(roadmapPath, updatedRoadmap, "utf-8");
                  execGit(cwd, ["add", roadmapPath]);
                  execGit(cwd, ["commit", "-m", `fix(state): correct phase ${phaseNum} plan count ${claimedPlanCount} \u2192 ${diskPlanCount}`]);
                  fixesApplied.push({
                    phase: phaseNum,
                    field: "plan_count",
                    old: String(claimedPlanCount),
                    new: String(diskPlanCount)
                  });
                }
              } catch (e) {
                debugLog("state.validate", "auto-fix failed for phase " + phaseNum, e);
              }
            }
          }
          if (phaseDirName && diskPlanCount > 0) {
            const checkboxPattern = new RegExp(`-\\s*\\[x\\]\\s*.*Phase\\s+${phaseNum.replace(/\./g, "\\.")}`, "i");
            const isMarkedComplete = checkboxPattern.test(roadmapContent);
            if (isMarkedComplete && diskSummaryCount < diskPlanCount) {
              issues.push({
                type: "completion_drift",
                location: `ROADMAP.md Phase ${phaseNum}`,
                expected: `${diskPlanCount} summaries for completion`,
                actual: `${diskSummaryCount} summaries on disk`,
                severity: "error"
              });
            }
          }
        }
      }
      if (stateContent) {
        const phaseFieldMatch = stateContent.match(/\*\*Phase:\*\*\s*(\d+(?:\.\d+)?)\s+of\s+(\d+)/i);
        if (phaseFieldMatch) {
          const currentPhaseNum = phaseFieldMatch[1];
          const phaseInfo = findPhaseInternal(cwd, currentPhaseNum);
          if (!phaseInfo) {
            issues.push({
              type: "position_missing",
              location: "STATE.md Phase field",
              expected: `Phase ${currentPhaseNum} directory exists`,
              actual: "Phase directory not found",
              severity: "error"
            });
          } else if (phaseInfo.plans.length > 0 && phaseInfo.summaries.length >= phaseInfo.plans.length) {
            issues.push({
              type: "position_completed",
              location: "STATE.md Phase field",
              expected: "Active phase with incomplete plans",
              actual: `Phase ${currentPhaseNum} is fully complete (${phaseInfo.summaries.length}/${phaseInfo.plans.length})`,
              severity: "warn"
            });
          }
        }
      }
      if (stateContent) {
        const activityMatch = stateContent.match(/\*\*Last Activity:\*\*\s*(\S+)/i);
        if (activityMatch) {
          const declaredDate = activityMatch[1];
          const declaredTime = new Date(declaredDate).getTime();
          const gitResult = execGit(cwd, ["log", "-1", "--format=%ci", "--", ".planning/"]);
          if (gitResult.exitCode === 0 && gitResult.stdout) {
            const gitDate = gitResult.stdout.split(" ")[0];
            const gitTime = new Date(gitDate).getTime();
            const dayMs = 24 * 60 * 60 * 1e3;
            if (!isNaN(declaredTime) && !isNaN(gitTime) && gitTime - declaredTime > dayMs) {
              issues.push({
                type: "activity_stale",
                location: "STATE.md Last Activity",
                expected: `Recent date near ${gitDate}`,
                actual: `Declared ${declaredDate}`,
                severity: "warn"
              });
            }
          }
        }
      }
      if (stateContent) {
        const config = loadConfig(cwd);
        const stalenessThreshold = config.staleness_threshold || 2;
        let totalCompletedPlans = 0;
        const phaseTreeForBlockers = getPhaseTree(cwd);
        for (const [, entry] of phaseTreeForBlockers) {
          totalCompletedPlans += entry.summaries.length;
        }
        const blockerSection = stateContent.match(/###?\s*(?:Blockers|Blockers\/Concerns|Concerns)\s*\n([\s\S]*?)(?=\n###?|\n##[^#]|$)/i);
        if (blockerSection) {
          const blockerBody = blockerSection[1].trim();
          if (blockerBody && !/^none\.?$/i.test(blockerBody) && !/^none yet\.?$/i.test(blockerBody)) {
            const blockerLines = blockerBody.split("\n").filter((l) => l.startsWith("- "));
            if (blockerLines.length > 0 && totalCompletedPlans >= stalenessThreshold) {
              for (const line of blockerLines) {
                issues.push({
                  type: "stale_blocker",
                  location: "STATE.md Blockers",
                  expected: `Resolved within ${stalenessThreshold} completed plans`,
                  actual: `"${line.slice(2).trim()}" still open after ${totalCompletedPlans} completed plans`,
                  severity: "warn"
                });
              }
            }
          }
        }
        const todoSection = stateContent.match(/###?\s*(?:Pending Todos|Todos|Open Todos)\s*\n([\s\S]*?)(?=\n###?|\n##[^#]|$)/i);
        if (todoSection) {
          const todoBody = todoSection[1].trim();
          if (todoBody && !/^none\.?$/i.test(todoBody) && !/^none yet\.?$/i.test(todoBody)) {
            const todoLines = todoBody.split("\n").filter((l) => l.startsWith("- "));
            if (todoLines.length > 0 && totalCompletedPlans >= stalenessThreshold) {
              for (const line of todoLines) {
                issues.push({
                  type: "stale_todo",
                  location: "STATE.md Pending Todos",
                  expected: `Resolved within ${stalenessThreshold} completed plans`,
                  actual: `"${line.slice(2).trim()}" still open after ${totalCompletedPlans} completed plans`,
                  severity: "warn"
                });
              }
            }
          }
        }
      }
      const errorCount = issues.filter((i) => i.severity === "error").length;
      const warnCount = issues.filter((i) => i.severity === "warn").length;
      let status = "clean";
      if (errorCount > 0) status = "errors";
      else if (warnCount > 0) status = "warnings";
      const summary = status === "clean" ? "State validation passed \u2014 no issues found" : `Found ${errorCount} error${errorCount !== 1 ? "s" : ""} and ${warnCount} warning${warnCount !== 1 ? "s" : ""}`;
      output({
        status,
        issues,
        fixes_applied: fixesApplied,
        summary
      }, raw);
    }
    module2.exports = {
      cmdStateLoad,
      cmdStateGet,
      cmdStatePatch,
      cmdStateUpdate,
      stateExtractField,
      stateReplaceField,
      cmdStateAdvancePlan,
      cmdStateRecordMetric,
      cmdStateUpdateProgress,
      cmdStateAddDecision,
      cmdStateAddBlocker,
      cmdStateResolveBlocker,
      cmdStateRecordSession,
      cmdStateValidate
    };
  }
});

// src/commands/roadmap.js
var require_roadmap = __commonJS({
  "src/commands/roadmap.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    var { output, error, debugLog } = require_output();
    var { normalizePhaseName, cachedReadFile, findPhaseInternal, getPhaseTree } = require_helpers();
    var { extractFrontmatter } = require_frontmatter();
    function cmdRoadmapGetPhase(cwd, phaseNum, raw) {
      const roadmapPath = path.join(cwd, ".planning", "ROADMAP.md");
      try {
        const content = cachedReadFile(roadmapPath);
        if (!content) {
          output({ found: false, error: "ROADMAP.md not found" }, raw, "");
          return;
        }
        const escapedPhase = phaseNum.replace(/\./g, "\\.");
        const phasePattern = new RegExp(
          `#{2,4}\\s*Phase\\s+${escapedPhase}:\\s*([^\\n]+)`,
          "i"
        );
        const headerMatch = content.match(phasePattern);
        if (!headerMatch) {
          const checklistPattern = new RegExp(
            `-\\s*\\[[ x]\\]\\s*\\*\\*Phase\\s+${escapedPhase}:\\s*([^*]+)\\*\\*`,
            "i"
          );
          const checklistMatch = content.match(checklistPattern);
          if (checklistMatch) {
            output({
              found: false,
              phase_number: phaseNum,
              phase_name: checklistMatch[1].trim(),
              error: "malformed_roadmap",
              message: `Phase ${phaseNum} exists in summary list but missing "### Phase ${phaseNum}:" detail section. ROADMAP.md needs both formats.`
            }, raw, "");
            return;
          }
          output({ found: false, phase_number: phaseNum }, raw, "");
          return;
        }
        const phaseName = headerMatch[1].trim();
        const headerIndex = headerMatch.index;
        const restOfContent = content.slice(headerIndex);
        const nextHeaderMatch = restOfContent.match(/\n#{2,4}\s+Phase\s+\d/i);
        const sectionEnd = nextHeaderMatch ? headerIndex + nextHeaderMatch.index : content.length;
        const section = content.slice(headerIndex, sectionEnd).trim();
        const goalMatch = section.match(/\*\*Goal:?\*\*:?\s*([^\n]+)/i);
        const goal = goalMatch ? goalMatch[1].trim() : null;
        const criteriaMatch = section.match(/\*\*Success Criteria\*\*[^\n]*:\s*\n((?:\s*\d+\.\s*[^\n]+\n?)+)/i);
        const success_criteria = criteriaMatch ? criteriaMatch[1].trim().split("\n").map((line) => line.replace(/^\s*\d+\.\s*/, "").trim()).filter(Boolean) : [];
        output(
          {
            found: true,
            phase_number: phaseNum,
            phase_name: phaseName,
            goal,
            success_criteria,
            section
          },
          raw,
          section
        );
      } catch (e) {
        debugLog("roadmap.getPhase", "read roadmap failed", e);
        error("Failed to read ROADMAP.md: " + e.message);
      }
    }
    function cmdRoadmapAnalyze(cwd, raw) {
      const roadmapPath = path.join(cwd, ".planning", "ROADMAP.md");
      const content = cachedReadFile(roadmapPath);
      if (!content) {
        output({ error: "ROADMAP.md not found", milestones: [], phases: [], current_phase: null }, raw);
        return;
      }
      const phasesDir = path.join(cwd, ".planning", "phases");
      const phasePattern = /#{2,4}\s*Phase\s+(\d+(?:\.\d+)?)\s*:\s*([^\n]+)/gi;
      const phases = [];
      let match;
      while ((match = phasePattern.exec(content)) !== null) {
        const phaseNum = match[1];
        const phaseName = match[2].replace(/\(INSERTED\)/i, "").trim();
        const sectionStart = match.index;
        const restOfContent = content.slice(sectionStart);
        const nextHeader = restOfContent.match(/\n#{2,4}\s+Phase\s+\d/i);
        const sectionEnd = nextHeader ? sectionStart + nextHeader.index : content.length;
        const section = content.slice(sectionStart, sectionEnd);
        const goalMatch = section.match(/\*\*Goal:?\*\*:?\s*([^\n]+)/i);
        const goal = goalMatch ? goalMatch[1].trim() : null;
        const dependsMatch = section.match(/\*\*Depends on:?\*\*:?\s*([^\n]+)/i);
        const depends_on = dependsMatch ? dependsMatch[1].trim() : null;
        const normalized = normalizePhaseName(phaseNum);
        let diskStatus = "no_directory";
        let planCount = 0;
        let summaryCount = 0;
        let hasContext = false;
        let hasResearch = false;
        const phaseTree = getPhaseTree(cwd);
        const cachedPhase = phaseTree.get(normalized);
        if (cachedPhase) {
          planCount = cachedPhase.plans.length;
          summaryCount = cachedPhase.summaries.length;
          hasContext = cachedPhase.hasContext;
          hasResearch = cachedPhase.hasResearch;
          if (summaryCount >= planCount && planCount > 0) diskStatus = "complete";
          else if (summaryCount > 0) diskStatus = "partial";
          else if (planCount > 0) diskStatus = "planned";
          else if (hasResearch) diskStatus = "researched";
          else if (hasContext) diskStatus = "discussed";
          else diskStatus = "empty";
        }
        const checkboxPattern = new RegExp(`-\\s*\\[(x| )\\]\\s*.*Phase\\s+${phaseNum.replace(".", "\\.")}`, "i");
        const checkboxMatch = content.match(checkboxPattern);
        const roadmapComplete = checkboxMatch ? checkboxMatch[1] === "x" : false;
        phases.push({
          number: phaseNum,
          name: phaseName,
          goal,
          depends_on,
          plan_count: planCount,
          summary_count: summaryCount,
          has_context: hasContext,
          has_research: hasResearch,
          disk_status: diskStatus,
          roadmap_complete: roadmapComplete
        });
      }
      const milestones = [];
      const milestonePattern = /[-*]\s*(?:âœ…|ðŸ”µ)\s*\*\*v(\d+(?:\.\d+)*)\s+([^*]+)\*\*([^\n]*)/g;
      let mMatch;
      while ((mMatch = milestonePattern.exec(content)) !== null) {
        const isActive = mMatch[0].includes("\u{1F535}");
        milestones.push({
          heading: mMatch[2].trim(),
          version: "v" + mMatch[1],
          active: isActive
        });
      }
      const currentPhase = phases.find((p) => p.disk_status === "planned" || p.disk_status === "partial") || null;
      const nextPhase = phases.find((p) => p.disk_status === "empty" || p.disk_status === "no_directory" || p.disk_status === "discussed" || p.disk_status === "researched") || null;
      const totalPlans = phases.reduce((sum, p) => sum + p.plan_count, 0);
      const totalSummaries = phases.reduce((sum, p) => sum + p.summary_count, 0);
      const completedPhases = phases.filter((p) => p.disk_status === "complete").length;
      const checklistPattern = /-\s*\[[ x]\]\s*\*\*Phase\s+(\d+(?:\.\d+)?)/gi;
      const checklistPhases = /* @__PURE__ */ new Set();
      let checklistMatch;
      while ((checklistMatch = checklistPattern.exec(content)) !== null) {
        checklistPhases.add(checklistMatch[1]);
      }
      const detailPhases = new Set(phases.map((p) => p.number));
      const missingDetails = [...checklistPhases].filter((p) => !detailPhases.has(p));
      const result = {
        milestones,
        phases,
        phase_count: phases.length,
        completed_phases: completedPhases,
        total_plans: totalPlans,
        total_summaries: totalSummaries,
        progress_percent: phases.length > 0 ? Math.round(completedPhases / phases.length * 100) : 0,
        plan_progress_percent: totalPlans > 0 ? Math.round(totalSummaries / totalPlans * 100) : 0,
        current_phase: currentPhase ? currentPhase.number : null,
        next_phase: nextPhase ? nextPhase.number : null,
        missing_phase_details: missingDetails.length > 0 ? missingDetails : null
      };
      output(result, raw);
    }
    function cmdRoadmapUpdatePlanProgress(cwd, phaseNum, raw) {
      if (!phaseNum) {
        error("phase number required for roadmap update-plan-progress");
      }
      const roadmapPath = path.join(cwd, ".planning", "ROADMAP.md");
      const phaseInfo = findPhaseInternal(cwd, phaseNum);
      if (!phaseInfo) {
        error(`Phase ${phaseNum} not found`);
      }
      const planCount = phaseInfo.plans.length;
      const summaryCount = phaseInfo.summaries.length;
      if (planCount === 0) {
        output({ updated: false, reason: "No plans found", plan_count: 0, summary_count: 0 }, raw, "no plans");
        return;
      }
      const isComplete = summaryCount >= planCount;
      const status = isComplete ? "Complete" : summaryCount > 0 ? "In Progress" : "Planned";
      const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      if (!fs.existsSync(roadmapPath)) {
        output({ updated: false, reason: "ROADMAP.md not found", plan_count: planCount, summary_count: summaryCount }, raw, "no roadmap");
        return;
      }
      let roadmapContent = fs.readFileSync(roadmapPath, "utf-8");
      const phaseEscaped = phaseNum.replace(".", "\\.");
      const tablePattern = new RegExp(
        `(\\|\\s*${phaseEscaped}\\.?\\s[^|]*\\|)[^|]*(\\|)\\s*[^|]*(\\|)\\s*[^|]*(\\|)`,
        "i"
      );
      const dateField = isComplete ? ` ${today} ` : "  ";
      roadmapContent = roadmapContent.replace(
        tablePattern,
        `$1 ${summaryCount}/${planCount} $2 ${status.padEnd(11)}$3${dateField}$4`
      );
      const planCountPattern = new RegExp(
        `(#{2,4}\\s*Phase\\s+${phaseEscaped}[\\s\\S]*?\\*\\*Plans:?\\*\\*:?\\s*)[^\\n]+`,
        "i"
      );
      const planCountText = isComplete ? `${summaryCount}/${planCount} plans complete` : `${summaryCount}/${planCount} plans executed`;
      roadmapContent = roadmapContent.replace(planCountPattern, `$1${planCountText}`);
      if (isComplete) {
        const checkboxPattern = new RegExp(
          `(-\\s*\\[)[ ](\\]\\s*.*Phase\\s+${phaseEscaped}[:\\s][^\\n]*)`,
          "i"
        );
        roadmapContent = roadmapContent.replace(checkboxPattern, `$1x$2 (completed ${today})`);
      }
      fs.writeFileSync(roadmapPath, roadmapContent, "utf-8");
      output({
        updated: true,
        phase: phaseNum,
        plan_count: planCount,
        summary_count: summaryCount,
        status,
        complete: isComplete
      }, raw, `${summaryCount}/${planCount} ${status}`);
    }
    module2.exports = {
      cmdRoadmapGetPhase,
      cmdRoadmapAnalyze,
      cmdRoadmapUpdatePlanProgress
    };
  }
});

// src/commands/phase.js
var require_phase = __commonJS({
  "src/commands/phase.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    var { output, error, debugLog } = require_output();
    var { normalizePhaseName, getArchivedPhaseDirs, findPhaseInternal, generateSlugInternal, getMilestoneInfo } = require_helpers();
    var { extractFrontmatter } = require_frontmatter();
    var { execGit } = require_git();
    function cmdPhasesList(cwd, options, raw) {
      const phasesDir = path.join(cwd, ".planning", "phases");
      const { type, phase, includeArchived } = options;
      if (!fs.existsSync(phasesDir)) {
        if (type) {
          output({ files: [], count: 0 }, raw, "");
        } else {
          output({ directories: [], count: 0 }, raw, "");
        }
        return;
      }
      try {
        const entries = fs.readdirSync(phasesDir, { withFileTypes: true });
        let dirs = entries.filter((e) => e.isDirectory()).map((e) => e.name);
        if (includeArchived) {
          const archived = getArchivedPhaseDirs(cwd);
          for (const a of archived) {
            dirs.push(`${a.name} [${a.milestone}]`);
          }
        }
        dirs.sort((a, b) => {
          const aNum = parseFloat(a.match(/^(\d+(?:\.\d+)?)/)?.[1] || "0");
          const bNum = parseFloat(b.match(/^(\d+(?:\.\d+)?)/)?.[1] || "0");
          return aNum - bNum;
        });
        if (phase) {
          const normalized = normalizePhaseName(phase);
          const match = dirs.find((d) => d.startsWith(normalized));
          if (!match) {
            output({ files: [], count: 0, phase_dir: null, error: "Phase not found" }, raw, "");
            return;
          }
          dirs = [match];
        }
        if (type) {
          const files = [];
          for (const dir of dirs) {
            const dirPath = path.join(phasesDir, dir);
            const dirFiles = fs.readdirSync(dirPath);
            let filtered;
            if (type === "plans") {
              filtered = dirFiles.filter((f) => f.endsWith("-PLAN.md") || f === "PLAN.md");
            } else if (type === "summaries") {
              filtered = dirFiles.filter((f) => f.endsWith("-SUMMARY.md") || f === "SUMMARY.md");
            } else {
              filtered = dirFiles;
            }
            files.push(...filtered.sort());
          }
          const result = {
            files,
            count: files.length,
            phase_dir: phase ? dirs[0].replace(/^\d+(?:\.\d+)?-?/, "") : null
          };
          output(result, raw, files.join("\n"));
          return;
        }
        output({ directories: dirs, count: dirs.length }, raw, dirs.join("\n"));
      } catch (e) {
        debugLog("phase.list", "list phases failed", e);
        error("Failed to list phases: " + e.message);
      }
    }
    function cmdPhaseNextDecimal(cwd, basePhase, raw) {
      const phasesDir = path.join(cwd, ".planning", "phases");
      const normalized = normalizePhaseName(basePhase);
      if (!fs.existsSync(phasesDir)) {
        output(
          {
            found: false,
            base_phase: normalized,
            next: `${normalized}.1`,
            existing: []
          },
          raw,
          `${normalized}.1`
        );
        return;
      }
      try {
        const entries = fs.readdirSync(phasesDir, { withFileTypes: true });
        const dirs = entries.filter((e) => e.isDirectory()).map((e) => e.name);
        const baseExists = dirs.some((d) => d.startsWith(normalized + "-") || d === normalized);
        const decimalPattern = new RegExp(`^${normalized}\\.(\\d+)`);
        const existingDecimals = [];
        for (const dir of dirs) {
          const match = dir.match(decimalPattern);
          if (match) {
            existingDecimals.push(`${normalized}.${match[1]}`);
          }
        }
        existingDecimals.sort((a, b) => {
          const aNum = parseFloat(a);
          const bNum = parseFloat(b);
          return aNum - bNum;
        });
        let nextDecimal;
        if (existingDecimals.length === 0) {
          nextDecimal = `${normalized}.1`;
        } else {
          const lastDecimal = existingDecimals[existingDecimals.length - 1];
          const lastNum = parseInt(lastDecimal.split(".")[1], 10);
          nextDecimal = `${normalized}.${lastNum + 1}`;
        }
        output(
          {
            found: baseExists,
            base_phase: normalized,
            next: nextDecimal,
            existing: existingDecimals
          },
          raw,
          nextDecimal
        );
      } catch (e) {
        debugLog("phase.nextDecimal", "calculate next decimal failed", e);
        error("Failed to calculate next decimal phase: " + e.message);
      }
    }
    function cmdPhaseAdd(cwd, description, raw) {
      if (!description) {
        error("description required for phase add");
      }
      const roadmapPath = path.join(cwd, ".planning", "ROADMAP.md");
      if (!fs.existsSync(roadmapPath)) {
        error("ROADMAP.md not found");
      }
      const content = fs.readFileSync(roadmapPath, "utf-8");
      const slug = generateSlugInternal(description);
      const phasePattern = /#{2,4}\s*Phase\s+(\d+)(?:\.\d+)?:/gi;
      let maxPhase = 0;
      let m;
      while ((m = phasePattern.exec(content)) !== null) {
        const num = parseInt(m[1], 10);
        if (num > maxPhase) maxPhase = num;
      }
      const newPhaseNum = maxPhase + 1;
      const paddedNum = String(newPhaseNum).padStart(2, "0");
      const dirName = `${paddedNum}-${slug}`;
      const dirPath = path.join(cwd, ".planning", "phases", dirName);
      fs.mkdirSync(dirPath, { recursive: true });
      fs.writeFileSync(path.join(dirPath, ".gitkeep"), "");
      const phaseEntry = `
### Phase ${newPhaseNum}: ${description}

**Goal:** [To be planned]
**Depends on:** Phase ${maxPhase}
**Plans:** 0 plans

Plans:
- [ ] TBD (run /gsd:plan-phase ${newPhaseNum} to break down)
`;
      let updatedContent;
      const lastSeparator = content.lastIndexOf("\n---");
      if (lastSeparator > 0) {
        updatedContent = content.slice(0, lastSeparator) + phaseEntry + content.slice(lastSeparator);
      } else {
        updatedContent = content + phaseEntry;
      }
      fs.writeFileSync(roadmapPath, updatedContent, "utf-8");
      const result = {
        phase_number: newPhaseNum,
        padded: paddedNum,
        name: description,
        slug,
        directory: `.planning/phases/${dirName}`
      };
      output(result, raw, paddedNum);
    }
    function cmdPhaseInsert(cwd, afterPhase, description, raw) {
      if (!afterPhase || !description) {
        error("after-phase and description required for phase insert");
      }
      const roadmapPath = path.join(cwd, ".planning", "ROADMAP.md");
      if (!fs.existsSync(roadmapPath)) {
        error("ROADMAP.md not found");
      }
      const content = fs.readFileSync(roadmapPath, "utf-8");
      const slug = generateSlugInternal(description);
      const normalizedAfter = normalizePhaseName(afterPhase);
      const unpadded = normalizedAfter.replace(/^0+/, "");
      const afterPhaseEscaped = unpadded.replace(/\./g, "\\.");
      const targetPattern = new RegExp(`#{2,4}\\s*Phase\\s+0*${afterPhaseEscaped}:`, "i");
      if (!targetPattern.test(content)) {
        error(`Phase ${afterPhase} not found in ROADMAP.md`);
      }
      const phasesDir = path.join(cwd, ".planning", "phases");
      const normalizedBase = normalizePhaseName(afterPhase);
      let existingDecimals = [];
      try {
        const entries = fs.readdirSync(phasesDir, { withFileTypes: true });
        const dirs = entries.filter((e) => e.isDirectory()).map((e) => e.name);
        const decimalPattern = new RegExp(`^${normalizedBase}\\.(\\d+)`);
        for (const dir of dirs) {
          const dm = dir.match(decimalPattern);
          if (dm) existingDecimals.push(parseInt(dm[1], 10));
        }
      } catch (e) {
        debugLog("phase.insert", "readdir failed", e);
      }
      const nextDecimal = existingDecimals.length === 0 ? 1 : Math.max(...existingDecimals) + 1;
      const decimalPhase = `${normalizedBase}.${nextDecimal}`;
      const dirName = `${decimalPhase}-${slug}`;
      const dirPath = path.join(cwd, ".planning", "phases", dirName);
      fs.mkdirSync(dirPath, { recursive: true });
      fs.writeFileSync(path.join(dirPath, ".gitkeep"), "");
      const phaseEntry = `
### Phase ${decimalPhase}: ${description} (INSERTED)

**Goal:** [Urgent work - to be planned]
**Depends on:** Phase ${afterPhase}
**Plans:** 0 plans

Plans:
- [ ] TBD (run /gsd:plan-phase ${decimalPhase} to break down)
`;
      const headerPattern = new RegExp(`(#{2,4}\\s*Phase\\s+0*${afterPhaseEscaped}:[^\\n]*\\n)`, "i");
      const headerMatch = content.match(headerPattern);
      if (!headerMatch) {
        error(`Could not find Phase ${afterPhase} header`);
      }
      const headerIdx = content.indexOf(headerMatch[0]);
      const afterHeader = content.slice(headerIdx + headerMatch[0].length);
      const nextPhaseMatch = afterHeader.match(/\n#{2,4}\s+Phase\s+\d/i);
      let insertIdx;
      if (nextPhaseMatch) {
        insertIdx = headerIdx + headerMatch[0].length + nextPhaseMatch.index;
      } else {
        insertIdx = content.length;
      }
      const updatedContent = content.slice(0, insertIdx) + phaseEntry + content.slice(insertIdx);
      fs.writeFileSync(roadmapPath, updatedContent, "utf-8");
      const result = {
        phase_number: decimalPhase,
        after_phase: afterPhase,
        name: description,
        slug,
        directory: `.planning/phases/${dirName}`
      };
      output(result, raw, decimalPhase);
    }
    function cmdPhaseRemove(cwd, targetPhase, options, raw) {
      if (!targetPhase) {
        error("phase number required for phase remove");
      }
      const roadmapPath = path.join(cwd, ".planning", "ROADMAP.md");
      const phasesDir = path.join(cwd, ".planning", "phases");
      const force = options.force || false;
      if (!fs.existsSync(roadmapPath)) {
        error("ROADMAP.md not found");
      }
      const normalized = normalizePhaseName(targetPhase);
      const isDecimal = targetPhase.includes(".");
      let targetDir = null;
      try {
        const entries = fs.readdirSync(phasesDir, { withFileTypes: true });
        const dirs = entries.filter((e) => e.isDirectory()).map((e) => e.name).sort();
        targetDir = dirs.find((d) => d.startsWith(normalized + "-") || d === normalized);
      } catch (e) {
        debugLog("phase.remove", "readdir failed", e);
      }
      if (targetDir && !force) {
        const targetPath = path.join(phasesDir, targetDir);
        const files = fs.readdirSync(targetPath);
        const summaries = files.filter((f) => f.endsWith("-SUMMARY.md") || f === "SUMMARY.md");
        if (summaries.length > 0) {
          error(`Phase ${targetPhase} has ${summaries.length} executed plan(s). Use --force to remove anyway.`);
        }
      }
      if (targetDir) {
        fs.rmSync(path.join(phasesDir, targetDir), { recursive: true, force: true });
      }
      const renamedDirs = [];
      const renamedFiles = [];
      if (isDecimal) {
        const baseParts = normalized.split(".");
        const baseInt = baseParts[0];
        const removedDecimal = parseInt(baseParts[1], 10);
        try {
          const entries = fs.readdirSync(phasesDir, { withFileTypes: true });
          const dirs = entries.filter((e) => e.isDirectory()).map((e) => e.name).sort();
          const decPattern = new RegExp(`^${baseInt}\\.(\\d+)-(.+)$`);
          const toRename = [];
          for (const dir of dirs) {
            const dm = dir.match(decPattern);
            if (dm && parseInt(dm[1], 10) > removedDecimal) {
              toRename.push({ dir, oldDecimal: parseInt(dm[1], 10), slug: dm[2] });
            }
          }
          toRename.sort((a, b) => b.oldDecimal - a.oldDecimal);
          for (const item of toRename) {
            const newDecimal = item.oldDecimal - 1;
            const oldPhaseId = `${baseInt}.${item.oldDecimal}`;
            const newPhaseId = `${baseInt}.${newDecimal}`;
            const newDirName = `${baseInt}.${newDecimal}-${item.slug}`;
            fs.renameSync(path.join(phasesDir, item.dir), path.join(phasesDir, newDirName));
            renamedDirs.push({ from: item.dir, to: newDirName });
            const dirFiles = fs.readdirSync(path.join(phasesDir, newDirName));
            for (const f of dirFiles) {
              if (f.includes(oldPhaseId)) {
                const newFileName = f.replace(oldPhaseId, newPhaseId);
                fs.renameSync(
                  path.join(phasesDir, newDirName, f),
                  path.join(phasesDir, newDirName, newFileName)
                );
                renamedFiles.push({ from: f, to: newFileName });
              }
            }
          }
        } catch (e) {
          debugLog("phase.remove", "rename failed", e);
        }
      } else {
        const removedInt = parseInt(normalized, 10);
        try {
          const entries = fs.readdirSync(phasesDir, { withFileTypes: true });
          const dirs = entries.filter((e) => e.isDirectory()).map((e) => e.name).sort();
          const toRename = [];
          for (const dir of dirs) {
            const dm = dir.match(/^(\d+)(?:\.(\d+))?-(.+)$/);
            if (!dm) continue;
            const dirInt = parseInt(dm[1], 10);
            if (dirInt > removedInt) {
              toRename.push({
                dir,
                oldInt: dirInt,
                decimal: dm[2] ? parseInt(dm[2], 10) : null,
                slug: dm[3]
              });
            }
          }
          toRename.sort((a, b) => {
            if (a.oldInt !== b.oldInt) return b.oldInt - a.oldInt;
            return (b.decimal || 0) - (a.decimal || 0);
          });
          for (const item of toRename) {
            const newInt = item.oldInt - 1;
            const newPadded = String(newInt).padStart(2, "0");
            const oldPadded = String(item.oldInt).padStart(2, "0");
            const decimalSuffix = item.decimal !== null ? `.${item.decimal}` : "";
            const oldPrefix = `${oldPadded}${decimalSuffix}`;
            const newPrefix = `${newPadded}${decimalSuffix}`;
            const newDirName = `${newPrefix}-${item.slug}`;
            fs.renameSync(path.join(phasesDir, item.dir), path.join(phasesDir, newDirName));
            renamedDirs.push({ from: item.dir, to: newDirName });
            const dirFiles = fs.readdirSync(path.join(phasesDir, newDirName));
            for (const f of dirFiles) {
              if (f.startsWith(oldPrefix)) {
                const newFileName = newPrefix + f.slice(oldPrefix.length);
                fs.renameSync(
                  path.join(phasesDir, newDirName, f),
                  path.join(phasesDir, newDirName, newFileName)
                );
                renamedFiles.push({ from: f, to: newFileName });
              }
            }
          }
        } catch (e) {
          debugLog("phase.remove", "rename failed", e);
        }
      }
      let roadmapContent = fs.readFileSync(roadmapPath, "utf-8");
      const targetEscaped = targetPhase.replace(/\./g, "\\.");
      const sectionPattern = new RegExp(
        `\\n?#{2,4}\\s*Phase\\s+${targetEscaped}\\s*:[\\s\\S]*?(?=\\n#{2,4}\\s+Phase\\s+\\d|$)`,
        "i"
      );
      roadmapContent = roadmapContent.replace(sectionPattern, "");
      const checkboxPattern = new RegExp(`\\n?-\\s*\\[[ x]\\]\\s*.*Phase\\s+${targetEscaped}[:\\s][^\\n]*`, "gi");
      roadmapContent = roadmapContent.replace(checkboxPattern, "");
      const tableRowPattern = new RegExp(`\\n?\\|\\s*${targetEscaped}\\.?\\s[^|]*\\|[^\\n]*`, "gi");
      roadmapContent = roadmapContent.replace(tableRowPattern, "");
      if (!isDecimal) {
        const removedInt = parseInt(normalized, 10);
        const maxPhase = 99;
        for (let oldNum = maxPhase; oldNum > removedInt; oldNum--) {
          const newNum = oldNum - 1;
          const oldStr = String(oldNum);
          const newStr = String(newNum);
          const oldPad = oldStr.padStart(2, "0");
          const newPad = newStr.padStart(2, "0");
          roadmapContent = roadmapContent.replace(
            new RegExp(`(#{2,4}\\s*Phase\\s+)${oldStr}(\\s*:)`, "gi"),
            `$1${newStr}$2`
          );
          roadmapContent = roadmapContent.replace(
            new RegExp(`(Phase\\s+)${oldStr}([:\\s])`, "g"),
            `$1${newStr}$2`
          );
          roadmapContent = roadmapContent.replace(
            new RegExp(`${oldPad}-(\\d{2})`, "g"),
            `${newPad}-$1`
          );
          roadmapContent = roadmapContent.replace(
            new RegExp(`(\\|\\s*)${oldStr}\\.\\s`, "g"),
            `$1${newStr}. `
          );
          roadmapContent = roadmapContent.replace(
            new RegExp(`(Depends on:?\\*\\*:?\\s*Phase\\s+)${oldStr}\\b`, "gi"),
            `$1${newStr}`
          );
        }
      }
      fs.writeFileSync(roadmapPath, roadmapContent, "utf-8");
      const statePath = path.join(cwd, ".planning", "STATE.md");
      if (fs.existsSync(statePath)) {
        let stateContent = fs.readFileSync(statePath, "utf-8");
        const totalPattern = /(\*\*Total Phases:\*\*\s*)(\d+)/;
        const totalMatch = stateContent.match(totalPattern);
        if (totalMatch) {
          const oldTotal = parseInt(totalMatch[2], 10);
          stateContent = stateContent.replace(totalPattern, `$1${oldTotal - 1}`);
        }
        const ofPattern = /(\bof\s+)(\d+)(\s*(?:\(|phases?))/i;
        const ofMatch = stateContent.match(ofPattern);
        if (ofMatch) {
          const oldTotal = parseInt(ofMatch[2], 10);
          stateContent = stateContent.replace(ofPattern, `$1${oldTotal - 1}$3`);
        }
        fs.writeFileSync(statePath, stateContent, "utf-8");
      }
      const result = {
        removed: targetPhase,
        directory_deleted: targetDir || null,
        renamed_directories: renamedDirs,
        renamed_files: renamedFiles,
        roadmap_updated: true,
        state_updated: fs.existsSync(statePath)
      };
      output(result, raw);
    }
    function cmdRequirementsMarkComplete(cwd, reqIdsRaw, raw) {
      if (!reqIdsRaw || reqIdsRaw.length === 0) {
        error("requirement IDs required. Usage: requirements mark-complete REQ-01,REQ-02 or REQ-01 REQ-02");
      }
      const reqIds = reqIdsRaw.join(" ").replace(/[\[\]]/g, "").split(/[,\s]+/).map((r) => r.trim()).filter(Boolean);
      if (reqIds.length === 0) {
        error("no valid requirement IDs found");
      }
      const reqPath = path.join(cwd, ".planning", "REQUIREMENTS.md");
      if (!fs.existsSync(reqPath)) {
        output({ updated: false, reason: "REQUIREMENTS.md not found", ids: reqIds }, raw, "no requirements file");
        return;
      }
      let reqContent = fs.readFileSync(reqPath, "utf-8");
      const updated = [];
      const notFound = [];
      for (const reqId of reqIds) {
        let found = false;
        const checkboxPattern = new RegExp(`(-\\s*\\[)[ ](\\]\\s*\\*\\*${reqId}\\*\\*)`, "gi");
        if (checkboxPattern.test(reqContent)) {
          reqContent = reqContent.replace(checkboxPattern, "$1x$2");
          found = true;
        }
        const tablePattern = new RegExp(`(\\|\\s*${reqId}\\s*\\|[^|]+\\|)\\s*Pending\\s*(\\|)`, "gi");
        if (tablePattern.test(reqContent)) {
          reqContent = reqContent.replace(
            new RegExp(`(\\|\\s*${reqId}\\s*\\|[^|]+\\|)\\s*Pending\\s*(\\|)`, "gi"),
            "$1 Complete $2"
          );
          found = true;
        }
        if (found) {
          updated.push(reqId);
        } else {
          notFound.push(reqId);
        }
      }
      if (updated.length > 0) {
        fs.writeFileSync(reqPath, reqContent, "utf-8");
      }
      output({
        updated: updated.length > 0,
        marked_complete: updated,
        not_found: notFound,
        total: reqIds.length
      }, raw, `${updated.length}/${reqIds.length} requirements marked complete`);
    }
    function cmdPhaseComplete(cwd, phaseNum, raw) {
      if (!phaseNum) {
        error("phase number required for phase complete");
      }
      const roadmapPath = path.join(cwd, ".planning", "ROADMAP.md");
      const statePath = path.join(cwd, ".planning", "STATE.md");
      const phasesDir = path.join(cwd, ".planning", "phases");
      const normalized = normalizePhaseName(phaseNum);
      const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      const phaseInfo = findPhaseInternal(cwd, phaseNum);
      if (!phaseInfo) {
        error(`Phase ${phaseNum} not found`);
      }
      const planCount = phaseInfo.plans.length;
      const summaryCount = phaseInfo.summaries.length;
      if (fs.existsSync(roadmapPath)) {
        let roadmapContent = fs.readFileSync(roadmapPath, "utf-8");
        const checkboxPattern = new RegExp(
          `(-\\s*\\[)[ ](\\]\\s*.*Phase\\s+${phaseNum.replace(".", "\\.")}[:\\s][^\\n]*)`,
          "i"
        );
        roadmapContent = roadmapContent.replace(checkboxPattern, `$1x$2 (completed ${today})`);
        const phaseEscaped = phaseNum.replace(".", "\\.");
        const tablePattern = new RegExp(
          `(\\|\\s*${phaseEscaped}\\.?\\s[^|]*\\|[^|]*\\|)\\s*[^|]*(\\|)\\s*[^|]*(\\|)`,
          "i"
        );
        roadmapContent = roadmapContent.replace(
          tablePattern,
          `$1 Complete    $2 ${today} $3`
        );
        const planCountPattern = new RegExp(
          `(#{2,4}\\s*Phase\\s+${phaseEscaped}[\\s\\S]*?\\*\\*Plans:?\\*\\*:?\\s*)[^\\n]+`,
          "i"
        );
        roadmapContent = roadmapContent.replace(
          planCountPattern,
          `$1${summaryCount}/${planCount} plans complete`
        );
        fs.writeFileSync(roadmapPath, roadmapContent, "utf-8");
        const reqPath = path.join(cwd, ".planning", "REQUIREMENTS.md");
        if (fs.existsSync(reqPath)) {
          const reqMatch = roadmapContent.match(
            new RegExp(`Phase\\s+${phaseNum.replace(".", "\\.")}[\\s\\S]*?\\*\\*Requirements:?\\*\\*:?\\s*([^\\n]+)`, "i")
          );
          if (reqMatch) {
            const reqIds = reqMatch[1].replace(/[\[\]]/g, "").split(/[,\s]+/).map((r) => r.trim()).filter(Boolean);
            let reqContent = fs.readFileSync(reqPath, "utf-8");
            for (const reqId of reqIds) {
              reqContent = reqContent.replace(
                new RegExp(`(-\\s*\\[)[ ](\\]\\s*\\*\\*${reqId}\\*\\*)`, "gi"),
                "$1x$2"
              );
              reqContent = reqContent.replace(
                new RegExp(`(\\|\\s*${reqId}\\s*\\|[^|]+\\|)\\s*Pending\\s*(\\|)`, "gi"),
                "$1 Complete $2"
              );
            }
            fs.writeFileSync(reqPath, reqContent, "utf-8");
          }
        }
      }
      let nextPhaseNum = null;
      let nextPhaseName = null;
      let isLastPhase = true;
      try {
        const entries = fs.readdirSync(phasesDir, { withFileTypes: true });
        const dirs = entries.filter((e) => e.isDirectory()).map((e) => e.name).sort();
        const currentFloat = parseFloat(phaseNum);
        for (const dir of dirs) {
          const dm = dir.match(/^(\d+(?:\.\d+)?)-?(.*)/);
          if (dm) {
            const dirFloat = parseFloat(dm[1]);
            if (dirFloat > currentFloat) {
              nextPhaseNum = dm[1];
              nextPhaseName = dm[2] || null;
              isLastPhase = false;
              break;
            }
          }
        }
      } catch (e) {
        debugLog("phase.complete", "find next phase failed", e);
      }
      if (fs.existsSync(statePath)) {
        let stateContent = fs.readFileSync(statePath, "utf-8");
        stateContent = stateContent.replace(
          /(\*\*Current Phase:\*\*\s*).*/,
          `$1${nextPhaseNum || phaseNum}`
        );
        if (nextPhaseName) {
          stateContent = stateContent.replace(
            /(\*\*Current Phase Name:\*\*\s*).*/,
            `$1${nextPhaseName.replace(/-/g, " ")}`
          );
        }
        stateContent = stateContent.replace(
          /(\*\*Status:\*\*\s*).*/,
          `$1${isLastPhase ? "Milestone complete" : "Ready to plan"}`
        );
        stateContent = stateContent.replace(
          /(\*\*Current Plan:\*\*\s*).*/,
          `$1Not started`
        );
        stateContent = stateContent.replace(
          /(\*\*Last Activity:\*\*\s*).*/,
          `$1${today}`
        );
        stateContent = stateContent.replace(
          /(\*\*Last Activity Description:\*\*\s*).*/,
          `$1Phase ${phaseNum} complete${nextPhaseNum ? `, transitioned to Phase ${nextPhaseNum}` : ""}`
        );
        fs.writeFileSync(statePath, stateContent, "utf-8");
      }
      const result = {
        completed_phase: phaseNum,
        phase_name: phaseInfo.phase_name,
        plans_executed: `${summaryCount}/${planCount}`,
        next_phase: nextPhaseNum,
        next_phase_name: nextPhaseName,
        is_last_phase: isLastPhase,
        date: today,
        roadmap_updated: fs.existsSync(roadmapPath),
        state_updated: fs.existsSync(statePath)
      };
      output(result, raw);
    }
    function cmdMilestoneComplete(cwd, version, options, raw) {
      if (!version) {
        error("version required for milestone complete (e.g., v1.0)");
      }
      const roadmapPath = path.join(cwd, ".planning", "ROADMAP.md");
      const reqPath = path.join(cwd, ".planning", "REQUIREMENTS.md");
      const statePath = path.join(cwd, ".planning", "STATE.md");
      const milestonesPath = path.join(cwd, ".planning", "MILESTONES.md");
      const archiveDir = path.join(cwd, ".planning", "milestones");
      const phasesDir = path.join(cwd, ".planning", "phases");
      const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      const milestoneName = options.name || version;
      fs.mkdirSync(archiveDir, { recursive: true });
      let phaseCount = 0;
      let totalPlans = 0;
      let totalTasks = 0;
      const accomplishments = [];
      try {
        const entries = fs.readdirSync(phasesDir, { withFileTypes: true });
        const dirs = entries.filter((e) => e.isDirectory()).map((e) => e.name).sort();
        for (const dir of dirs) {
          phaseCount++;
          const phaseFiles = fs.readdirSync(path.join(phasesDir, dir));
          const plans = phaseFiles.filter((f) => f.endsWith("-PLAN.md") || f === "PLAN.md");
          const summaries = phaseFiles.filter((f) => f.endsWith("-SUMMARY.md") || f === "SUMMARY.md");
          totalPlans += plans.length;
          for (const s of summaries) {
            try {
              const content = fs.readFileSync(path.join(phasesDir, dir, s), "utf-8");
              const fm = extractFrontmatter(content);
              if (fm["one-liner"]) {
                accomplishments.push(fm["one-liner"]);
              }
              const taskMatches = content.match(/##\s*Task\s*\d+/gi) || [];
              totalTasks += taskMatches.length;
            } catch (e) {
              debugLog("milestone.complete", "frontmatter extraction failed", e);
            }
          }
        }
      } catch (e) {
        debugLog("milestone.complete", "frontmatter extraction failed", e);
      }
      if (fs.existsSync(roadmapPath)) {
        const roadmapContent = fs.readFileSync(roadmapPath, "utf-8");
        fs.writeFileSync(path.join(archiveDir, `${version}-ROADMAP.md`), roadmapContent, "utf-8");
      }
      if (fs.existsSync(reqPath)) {
        const reqContent = fs.readFileSync(reqPath, "utf-8");
        const archiveHeader = `# Requirements Archive: ${version} ${milestoneName}

**Archived:** ${today}
**Status:** SHIPPED

For current requirements, see \`.planning/REQUIREMENTS.md\`.

---

`;
        fs.writeFileSync(path.join(archiveDir, `${version}-REQUIREMENTS.md`), archiveHeader + reqContent, "utf-8");
      }
      const auditFile = path.join(cwd, ".planning", `${version}-MILESTONE-AUDIT.md`);
      if (fs.existsSync(auditFile)) {
        fs.renameSync(auditFile, path.join(archiveDir, `${version}-MILESTONE-AUDIT.md`));
      }
      const accomplishmentsList = accomplishments.map((a) => `- ${a}`).join("\n");
      const milestoneEntry = `## ${version} ${milestoneName} (Shipped: ${today})

**Phases completed:** ${phaseCount} phases, ${totalPlans} plans, ${totalTasks} tasks

**Key accomplishments:**
${accomplishmentsList || "- (none recorded)"}

---

`;
      if (fs.existsSync(milestonesPath)) {
        const existing = fs.readFileSync(milestonesPath, "utf-8");
        fs.writeFileSync(milestonesPath, existing + "\n" + milestoneEntry, "utf-8");
      } else {
        fs.writeFileSync(milestonesPath, `# Milestones

${milestoneEntry}`, "utf-8");
      }
      if (fs.existsSync(statePath)) {
        let stateContent = fs.readFileSync(statePath, "utf-8");
        stateContent = stateContent.replace(
          /(\*\*Status:\*\*\s*).*/,
          `$1${version} milestone complete`
        );
        stateContent = stateContent.replace(
          /(\*\*Last Activity:\*\*\s*).*/,
          `$1${today}`
        );
        stateContent = stateContent.replace(
          /(\*\*Last Activity Description:\*\*\s*).*/,
          `$1${version} milestone completed and archived`
        );
        fs.writeFileSync(statePath, stateContent, "utf-8");
      }
      let phasesArchived = false;
      try {
        const phaseArchiveDir = path.join(archiveDir, `${version}-phases`);
        fs.mkdirSync(phaseArchiveDir, { recursive: true });
        const milestone = getMilestoneInfo(cwd);
        const phaseRange = milestone.phaseRange;
        const phaseEntries = fs.readdirSync(phasesDir, { withFileTypes: true });
        const phaseDirNames = phaseEntries.filter((e) => e.isDirectory()).map((e) => e.name);
        for (const dir of phaseDirNames) {
          if (phaseRange) {
            const dirMatch = dir.match(/^(\d+)/);
            if (dirMatch) {
              const num = parseInt(dirMatch[1]);
              if (num < phaseRange.start || num > phaseRange.end) continue;
            }
          } else if (!options.archivePhases) {
            continue;
          }
          fs.renameSync(path.join(phasesDir, dir), path.join(phaseArchiveDir, dir));
        }
        const archivedEntries = fs.readdirSync(phaseArchiveDir);
        phasesArchived = archivedEntries.length > 0;
      } catch (e) {
        debugLog("milestone.complete", "readdir failed", e);
      }
      const result = {
        version,
        name: milestoneName,
        date: today,
        phases: phaseCount,
        plans: totalPlans,
        tasks: totalTasks,
        accomplishments,
        archived: {
          roadmap: fs.existsSync(path.join(archiveDir, `${version}-ROADMAP.md`)),
          requirements: fs.existsSync(path.join(archiveDir, `${version}-REQUIREMENTS.md`)),
          audit: fs.existsSync(path.join(archiveDir, `${version}-MILESTONE-AUDIT.md`)),
          phases: phasesArchived
        },
        milestones_updated: true,
        state_updated: fs.existsSync(statePath)
      };
      output(result, raw);
    }
    module2.exports = {
      cmdPhasesList,
      cmdPhaseNextDecimal,
      cmdPhaseAdd,
      cmdPhaseInsert,
      cmdPhaseRemove,
      cmdRequirementsMarkComplete,
      cmdPhaseComplete,
      cmdMilestoneComplete
    };
  }
});

// src/commands/verify.js
var require_verify = __commonJS({
  "src/commands/verify.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var { output, error, debugLog } = require_output();
    var { safeReadFile, cachedReadFile, findPhaseInternal, normalizePhaseName, parseMustHavesBlock, getArchivedPhaseDirs, getMilestoneInfo, getPhaseTree } = require_helpers();
    var { extractFrontmatter } = require_frontmatter();
    var { execGit } = require_git();
    var { banner, sectionHeader, formatTable, summaryLine, color, SYMBOLS, colorByPercent, progressBar, box } = require_format();
    function cmdVerifyPlanStructure(cwd, filePath, raw) {
      if (!filePath) {
        error("file path required");
      }
      const fullPath = path.isAbsolute(filePath) ? filePath : path.join(cwd, filePath);
      const content = safeReadFile(fullPath);
      if (!content) {
        output({ error: "File not found", path: filePath }, raw);
        return;
      }
      const fm = extractFrontmatter(content);
      const errors = [];
      const warnings = [];
      const required = ["phase", "plan", "type", "wave", "depends_on", "files_modified", "autonomous", "must_haves"];
      for (const field of required) {
        if (fm[field] === void 0) errors.push(`Missing required frontmatter field: ${field}`);
      }
      const taskPattern = /<task[^>]*>([\s\S]*?)<\/task>/g;
      const tasks = [];
      let taskMatch;
      while ((taskMatch = taskPattern.exec(content)) !== null) {
        const taskContent = taskMatch[1];
        const nameMatch = taskContent.match(/<name>([\s\S]*?)<\/name>/);
        const taskName = nameMatch ? nameMatch[1].trim() : "unnamed";
        const hasFiles = /<files>/.test(taskContent);
        const hasAction = /<action>/.test(taskContent);
        const hasVerify = /<verify>/.test(taskContent);
        const hasDone = /<done>/.test(taskContent);
        if (!nameMatch) errors.push("Task missing <name> element");
        if (!hasAction) errors.push(`Task '${taskName}' missing <action>`);
        if (!hasVerify) warnings.push(`Task '${taskName}' missing <verify>`);
        if (!hasDone) warnings.push(`Task '${taskName}' missing <done>`);
        if (!hasFiles) warnings.push(`Task '${taskName}' missing <files>`);
        tasks.push({ name: taskName, hasFiles, hasAction, hasVerify, hasDone });
      }
      if (tasks.length === 0) warnings.push("No <task> elements found");
      if (fm.wave && parseInt(fm.wave) > 1 && (!fm.depends_on || Array.isArray(fm.depends_on) && fm.depends_on.length === 0)) {
        warnings.push("Wave > 1 but depends_on is empty");
      }
      const hasCheckpoints = /<task\s+type=["']?checkpoint/.test(content);
      if (hasCheckpoints && fm.autonomous !== "false" && fm.autonomous !== false) {
        errors.push("Has checkpoint tasks but autonomous is not false");
      }
      const templateCompliance = { valid: true, missing_fields: [], type_issues: [] };
      const planType = fm.type || "execute";
      const typeRequiredFields = {
        execute: ["wave", "depends_on", "files_modified", "autonomous", "requirements", "must_haves"],
        tdd: ["wave", "depends_on", "files_modified", "autonomous", "requirements"]
      };
      const requiredForType = typeRequiredFields[planType] || typeRequiredFields.execute;
      for (const field of requiredForType) {
        if (fm[field] === void 0) {
          templateCompliance.missing_fields.push(field);
        }
      }
      if (fm.requirements !== void 0) {
        const reqEmpty = Array.isArray(fm.requirements) && fm.requirements.length === 0 || typeof fm.requirements === "string" && fm.requirements.trim() === "" || typeof fm.requirements === "object" && !Array.isArray(fm.requirements) && Object.keys(fm.requirements).length === 0;
        if (reqEmpty) {
          templateCompliance.type_issues.push("requirements is empty \u2014 every plan should map to requirements");
        }
      }
      if (planType === "tdd") {
        if (!/<feature>/.test(content)) {
          templateCompliance.type_issues.push("TDD plan missing <feature> block");
        }
      }
      for (const task of tasks) {
        if (!task.hasAction) templateCompliance.type_issues.push(`Task '${task.name}' missing <action>`);
        if (!task.hasVerify) templateCompliance.type_issues.push(`Task '${task.name}' missing <verify>`);
        if (!task.hasDone) templateCompliance.type_issues.push(`Task '${task.name}' missing <done>`);
      }
      if (templateCompliance.missing_fields.length > 0 || templateCompliance.type_issues.length > 0) {
        templateCompliance.valid = false;
      }
      output({
        valid: errors.length === 0,
        errors,
        warnings,
        task_count: tasks.length,
        tasks,
        frontmatter_fields: Object.keys(fm),
        template_compliance: templateCompliance
      }, raw, errors.length === 0 ? "valid" : "invalid");
    }
    function cmdVerifyPhaseCompleteness(cwd, phase, raw) {
      if (!phase) {
        error("phase required");
      }
      const phaseInfo = findPhaseInternal(cwd, phase);
      if (!phaseInfo || !phaseInfo.found) {
        output({ error: "Phase not found", phase }, raw);
        return;
      }
      const errors = [];
      const warnings = [];
      const phaseDir = path.join(cwd, phaseInfo.directory);
      let files;
      try {
        files = fs.readdirSync(phaseDir);
      } catch (e) {
        debugLog("verify.phaseComplete", "readdir phase failed", e);
        output({ error: "Cannot read phase directory" }, raw);
        return;
      }
      const plans = files.filter((f) => f.match(/-PLAN\.md$/i));
      const summaries = files.filter((f) => f.match(/-SUMMARY\.md$/i));
      const planIds = new Set(plans.map((p) => p.replace(/-PLAN\.md$/i, "")));
      const summaryIds = new Set(summaries.map((s) => s.replace(/-SUMMARY\.md$/i, "")));
      const incompletePlans = [...planIds].filter((id) => !summaryIds.has(id));
      if (incompletePlans.length > 0) {
        errors.push(`Plans without summaries: ${incompletePlans.join(", ")}`);
      }
      const orphanSummaries = [...summaryIds].filter((id) => !planIds.has(id));
      if (orphanSummaries.length > 0) {
        warnings.push(`Summaries without plans: ${orphanSummaries.join(", ")}`);
      }
      output({
        complete: errors.length === 0,
        phase: phaseInfo.phase_number,
        plan_count: plans.length,
        summary_count: summaries.length,
        incomplete_plans: incompletePlans,
        orphan_summaries: orphanSummaries,
        errors,
        warnings
      }, raw, errors.length === 0 ? "complete" : "incomplete");
    }
    function cmdVerifyReferences(cwd, filePath, raw) {
      if (!filePath) {
        error("file path required");
      }
      const fullPath = path.isAbsolute(filePath) ? filePath : path.join(cwd, filePath);
      const content = safeReadFile(fullPath);
      if (!content) {
        output({ error: "File not found", path: filePath }, raw);
        return;
      }
      const found = [];
      const missing = [];
      const atRefs = content.match(/@([^\s\n,)]+\/[^\s\n,)]+)/g) || [];
      for (const ref of atRefs) {
        const cleanRef = ref.slice(1);
        const resolved = cleanRef.startsWith("~/") ? path.join(process.env.HOME || "", cleanRef.slice(2)) : path.join(cwd, cleanRef);
        if (fs.existsSync(resolved)) {
          found.push(cleanRef);
        } else {
          missing.push(cleanRef);
        }
      }
      const backtickRefs = content.match(/`([^`]+\/[^`]+\.[a-zA-Z]{1,10})`/g) || [];
      for (const ref of backtickRefs) {
        const cleanRef = ref.slice(1, -1);
        if (cleanRef.startsWith("http") || cleanRef.includes("${") || cleanRef.includes("{{")) continue;
        if (found.includes(cleanRef) || missing.includes(cleanRef)) continue;
        const resolved = path.join(cwd, cleanRef);
        if (fs.existsSync(resolved)) {
          found.push(cleanRef);
        } else {
          missing.push(cleanRef);
        }
      }
      output({
        valid: missing.length === 0,
        found: found.length,
        missing,
        total: found.length + missing.length
      }, raw, missing.length === 0 ? "valid" : "invalid");
    }
    function cmdVerifyCommits(cwd, hashes, raw) {
      if (!hashes || hashes.length === 0) {
        error("At least one commit hash required");
      }
      const valid = [];
      const invalid = [];
      for (const hash of hashes) {
        const result = execGit(cwd, ["cat-file", "-t", hash]);
        if (result.exitCode === 0 && result.stdout.trim() === "commit") {
          valid.push(hash);
        } else {
          invalid.push(hash);
        }
      }
      output({
        all_valid: invalid.length === 0,
        valid,
        invalid,
        total: hashes.length
      }, raw, invalid.length === 0 ? "valid" : "invalid");
    }
    function cmdVerifyArtifacts(cwd, planFilePath, raw) {
      if (!planFilePath) {
        error("plan file path required");
      }
      const fullPath = path.isAbsolute(planFilePath) ? planFilePath : path.join(cwd, planFilePath);
      const content = safeReadFile(fullPath);
      if (!content) {
        output({ error: "File not found", path: planFilePath }, raw);
        return;
      }
      const artifacts = parseMustHavesBlock(content, "artifacts");
      if (artifacts.length === 0) {
        output({ error: "No must_haves.artifacts found in frontmatter", path: planFilePath }, raw);
        return;
      }
      const results = [];
      for (const artifact of artifacts) {
        if (typeof artifact === "string") continue;
        const artPath = artifact.path;
        if (!artPath) continue;
        const artFullPath = path.join(cwd, artPath);
        const exists = fs.existsSync(artFullPath);
        const check = { path: artPath, exists, issues: [], passed: false };
        if (exists) {
          const fileContent = safeReadFile(artFullPath) || "";
          const lineCount = fileContent.split("\n").length;
          if (artifact.min_lines && lineCount < artifact.min_lines) {
            check.issues.push(`Only ${lineCount} lines, need ${artifact.min_lines}`);
          }
          if (artifact.contains && !fileContent.includes(artifact.contains)) {
            check.issues.push(`Missing pattern: ${artifact.contains}`);
          }
          if (artifact.exports) {
            const exports3 = Array.isArray(artifact.exports) ? artifact.exports : [artifact.exports];
            for (const exp of exports3) {
              if (!fileContent.includes(exp)) check.issues.push(`Missing export: ${exp}`);
            }
          }
          check.passed = check.issues.length === 0;
        } else {
          check.issues.push("File not found");
        }
        results.push(check);
      }
      const passed = results.filter((r) => r.passed).length;
      output({
        all_passed: passed === results.length,
        passed,
        total: results.length,
        artifacts: results
      }, raw, passed === results.length ? "valid" : "invalid");
    }
    function cmdVerifyKeyLinks(cwd, planFilePath, raw) {
      if (!planFilePath) {
        error("plan file path required");
      }
      const fullPath = path.isAbsolute(planFilePath) ? planFilePath : path.join(cwd, planFilePath);
      const content = safeReadFile(fullPath);
      if (!content) {
        output({ error: "File not found", path: planFilePath }, raw);
        return;
      }
      const keyLinks = parseMustHavesBlock(content, "key_links");
      if (keyLinks.length === 0) {
        output({ error: "No must_haves.key_links found in frontmatter", path: planFilePath }, raw);
        return;
      }
      const results = [];
      for (const link of keyLinks) {
        if (typeof link === "string") continue;
        const check = { from: link.from, to: link.to, via: link.via || "", verified: false, detail: "" };
        const sourceContent = safeReadFile(path.join(cwd, link.from || ""));
        if (!sourceContent) {
          check.detail = "Source file not found";
        } else if (link.pattern) {
          try {
            const regex = new RegExp(link.pattern);
            if (regex.test(sourceContent)) {
              check.verified = true;
              check.detail = "Pattern found in source";
            } else {
              const targetContent = safeReadFile(path.join(cwd, link.to || ""));
              if (targetContent && regex.test(targetContent)) {
                check.verified = true;
                check.detail = "Pattern found in target";
              } else {
                check.detail = `Pattern "${link.pattern}" not found in source or target`;
              }
            }
          } catch (e) {
            debugLog("verify.keyLinks", "read failed", e);
            check.detail = `Invalid regex pattern: ${link.pattern}`;
          }
        } else {
          if (sourceContent.includes(link.to || "")) {
            check.verified = true;
            check.detail = "Target referenced in source";
          } else {
            check.detail = "Target not referenced in source";
          }
        }
        results.push(check);
      }
      const verified = results.filter((r) => r.verified).length;
      output({
        all_verified: verified === results.length,
        verified,
        total: results.length,
        links: results
      }, raw, verified === results.length ? "valid" : "invalid");
    }
    function cmdValidateConsistency(cwd, raw) {
      const roadmapPath = path.join(cwd, ".planning", "ROADMAP.md");
      const errors = [];
      const warnings = [];
      const roadmapContent = cachedReadFile(roadmapPath);
      if (!roadmapContent) {
        errors.push("ROADMAP.md not found");
        output({ passed: false, errors, warnings }, raw, "failed");
        return;
      }
      const roadmapPhases = /* @__PURE__ */ new Set();
      const phasePattern = /#{2,4}\s*Phase\s+(\d+(?:\.\d+)?)\s*:/gi;
      let m;
      while ((m = phasePattern.exec(roadmapContent)) !== null) {
        roadmapPhases.add(m[1]);
      }
      const phaseTree = getPhaseTree(cwd);
      const diskPhases = /* @__PURE__ */ new Set();
      for (const [, entry] of phaseTree) {
        diskPhases.add(entry.phaseNumber);
      }
      for (const p of roadmapPhases) {
        if (!diskPhases.has(p) && !diskPhases.has(normalizePhaseName(p))) {
          warnings.push(`Phase ${p} in ROADMAP.md but no directory on disk`);
        }
      }
      for (const p of diskPhases) {
        const unpadded = String(parseInt(p, 10));
        if (!roadmapPhases.has(p) && !roadmapPhases.has(unpadded)) {
          warnings.push(`Phase ${p} exists on disk but not in ROADMAP.md`);
        }
      }
      const integerPhases = [...diskPhases].filter((p) => !p.includes(".")).map((p) => parseInt(p, 10)).sort((a, b) => a - b);
      for (let i = 1; i < integerPhases.length; i++) {
        if (integerPhases[i] !== integerPhases[i - 1] + 1) {
          warnings.push(`Gap in phase numbering: ${integerPhases[i - 1]} \u2192 ${integerPhases[i]}`);
        }
      }
      for (const [, entry] of phaseTree) {
        const plans = entry.plans;
        const summaries = entry.summaries;
        const planNums = plans.map((p) => {
          const pm = p.match(/-(\d{2})-PLAN\.md$/);
          return pm ? parseInt(pm[1], 10) : null;
        }).filter((n) => n !== null);
        for (let i = 1; i < planNums.length; i++) {
          if (planNums[i] !== planNums[i - 1] + 1) {
            warnings.push(`Gap in plan numbering in ${entry.dirName}: plan ${planNums[i - 1]} \u2192 ${planNums[i]}`);
          }
        }
        const planIds = new Set(plans.map((p) => p.replace("-PLAN.md", "")));
        const summaryIds = new Set(summaries.map((s) => s.replace("-SUMMARY.md", "")));
        for (const sid of summaryIds) {
          if (!planIds.has(sid)) {
            warnings.push(`Summary ${sid}-SUMMARY.md in ${entry.dirName} has no matching PLAN.md`);
          }
        }
        for (const plan of plans) {
          const content = cachedReadFile(path.join(entry.fullPath, plan));
          if (!content) continue;
          const fm = extractFrontmatter(content);
          if (!fm.wave) {
            warnings.push(`${entry.dirName}/${plan}: missing 'wave' in frontmatter`);
          }
        }
      }
      const passed = errors.length === 0;
      output({ passed, errors, warnings, warning_count: warnings.length }, raw, passed ? "passed" : "failed");
    }
    function cmdValidateHealth(cwd, options, raw) {
      const planningDir = path.join(cwd, ".planning");
      const projectPath = path.join(planningDir, "PROJECT.md");
      const roadmapPath = path.join(planningDir, "ROADMAP.md");
      const statePath = path.join(planningDir, "STATE.md");
      const configPath = path.join(planningDir, "config.json");
      const phasesDir = path.join(planningDir, "phases");
      const errors = [];
      const warnings = [];
      const info = [];
      const repairs = [];
      const addIssue = (severity, code, message, fix, repairable = false) => {
        const issue = { code, message, fix, repairable };
        if (severity === "error") errors.push(issue);
        else if (severity === "warning") warnings.push(issue);
        else info.push(issue);
      };
      if (!fs.existsSync(planningDir)) {
        addIssue("error", "E001", ".planning/ directory not found", "Run /gsd:new-project to initialize");
        output({
          status: "broken",
          errors,
          warnings,
          info,
          repairable_count: 0
        }, raw);
        return;
      }
      const projectContent = cachedReadFile(projectPath);
      if (!projectContent) {
        addIssue("error", "E002", "PROJECT.md not found", "Run /gsd:new-project to create");
      } else {
        const requiredSections = ["## What This Is", "## Core Value", "## Requirements"];
        for (const section of requiredSections) {
          if (!projectContent.includes(section)) {
            addIssue("warning", "W001", `PROJECT.md missing section: ${section}`, "Add section manually");
          }
        }
      }
      if (!fs.existsSync(roadmapPath)) {
        addIssue("error", "E003", "ROADMAP.md not found", "Run /gsd:new-milestone to create roadmap");
      }
      const stateContent = cachedReadFile(statePath);
      if (!stateContent) {
        addIssue("error", "E004", "STATE.md not found", "Run /gsd:health --repair to regenerate", true);
        repairs.push("regenerateState");
      } else {
        const phaseRefs = [...stateContent.matchAll(/[Pp]hase\s+(\d+(?:\.\d+)?)/g)].map((m) => m[1]);
        const phaseTree = getPhaseTree(cwd);
        const diskPhases = /* @__PURE__ */ new Set();
        for (const [, entry] of phaseTree) {
          diskPhases.add(entry.phaseNumber);
        }
        for (const ref of phaseRefs) {
          const normalizedRef = String(parseInt(ref, 10)).padStart(2, "0");
          if (!diskPhases.has(ref) && !diskPhases.has(normalizedRef) && !diskPhases.has(String(parseInt(ref, 10)))) {
            if (diskPhases.size > 0) {
              addIssue("warning", "W002", `STATE.md references phase ${ref}, but only phases ${[...diskPhases].sort().join(", ")} exist`, "Run /gsd:health --repair to regenerate STATE.md", true);
              if (!repairs.includes("regenerateState")) repairs.push("regenerateState");
            }
          }
        }
      }
      const configContent = cachedReadFile(configPath);
      if (!configContent) {
        addIssue("warning", "W003", "config.json not found", "Run /gsd:health --repair to create with defaults", true);
        repairs.push("createConfig");
      } else {
        try {
          const parsed = JSON.parse(configContent);
          const validProfiles = ["quality", "balanced", "budget"];
          if (parsed.model_profile && !validProfiles.includes(parsed.model_profile)) {
            addIssue("warning", "W004", `config.json: invalid model_profile "${parsed.model_profile}"`, `Valid values: ${validProfiles.join(", ")}`);
          }
        } catch (err) {
          debugLog("validate.health", "JSON parse failed", err);
          addIssue("error", "E005", `config.json: JSON parse error - ${err.message}`, "Run /gsd:health --repair to reset to defaults", true);
          repairs.push("resetConfig");
        }
      }
      const healthPhaseTree = getPhaseTree(cwd);
      for (const [, entry] of healthPhaseTree) {
        if (!entry.dirName.match(/^\d{2}(?:\.\d+)?-[\w-]+$/)) {
          addIssue("warning", "W005", `Phase directory "${entry.dirName}" doesn't follow NN-name format`, "Rename to match pattern (e.g., 01-setup)");
        }
        const summaryBases = new Set(entry.summaries.map((s) => s.replace("-SUMMARY.md", "").replace("SUMMARY.md", "")));
        for (const plan of entry.plans) {
          const planBase = plan.replace("-PLAN.md", "").replace("PLAN.md", "");
          if (!summaryBases.has(planBase)) {
            addIssue("info", "I001", `${entry.dirName}/${plan} has no SUMMARY.md`, "May be in progress");
          }
        }
      }
      if (fs.existsSync(roadmapPath)) {
        const roadmapContent = fs.readFileSync(roadmapPath, "utf-8");
        const roadmapPhases = /* @__PURE__ */ new Set();
        const phasePattern = /#{2,4}\s*Phase\s+(\d+(?:\.\d+)?)\s*:/gi;
        let m;
        while ((m = phasePattern.exec(roadmapContent)) !== null) {
          roadmapPhases.add(m[1]);
        }
        const diskPhases = /* @__PURE__ */ new Set();
        try {
          const entries = fs.readdirSync(phasesDir, { withFileTypes: true });
          for (const e of entries) {
            if (e.isDirectory()) {
              const dm = e.name.match(/^(\d+(?:\.\d+)?)/);
              if (dm) diskPhases.add(dm[1]);
            }
          }
        } catch (e) {
          debugLog("validate.health", "readdir failed", e);
        }
        for (const p of roadmapPhases) {
          const padded = String(parseInt(p, 10)).padStart(2, "0");
          if (!diskPhases.has(p) && !diskPhases.has(padded)) {
            addIssue("warning", "W006", `Phase ${p} in ROADMAP.md but no directory on disk`, "Create phase directory or remove from roadmap");
          }
        }
        for (const p of diskPhases) {
          const unpadded = String(parseInt(p, 10));
          if (!roadmapPhases.has(p) && !roadmapPhases.has(unpadded)) {
            addIssue("warning", "W007", `Phase ${p} exists on disk but not in ROADMAP.md`, "Add to roadmap or remove directory");
          }
        }
      }
      const repairActions = [];
      if (options.repair && repairs.length > 0) {
        for (const repair of repairs) {
          try {
            switch (repair) {
              case "createConfig":
              case "resetConfig": {
                const defaults = {
                  model_profile: "balanced",
                  commit_docs: true,
                  search_gitignored: false,
                  branching_strategy: "none",
                  research: true,
                  plan_checker: true,
                  verifier: true,
                  parallelization: true
                };
                fs.writeFileSync(configPath, JSON.stringify(defaults, null, 2), "utf-8");
                repairActions.push({ action: repair, success: true, path: "config.json" });
                break;
              }
              case "regenerateState": {
                if (fs.existsSync(statePath)) {
                  const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-").slice(0, 19);
                  const backupPath = `${statePath}.bak-${timestamp}`;
                  fs.copyFileSync(statePath, backupPath);
                  repairActions.push({ action: "backupState", success: true, path: backupPath });
                }
                const milestone = getMilestoneInfo(cwd);
                let stateContent2 = `# Session State

`;
                stateContent2 += `## Project Reference

`;
                stateContent2 += `See: .planning/PROJECT.md

`;
                stateContent2 += `## Position

`;
                stateContent2 += `**Milestone:** ${milestone.version} ${milestone.name}
`;
                stateContent2 += `**Current phase:** (determining...)
`;
                stateContent2 += `**Status:** Resuming

`;
                stateContent2 += `## Session Log

`;
                stateContent2 += `- ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}: STATE.md regenerated by /gsd:health --repair
`;
                fs.writeFileSync(statePath, stateContent2, "utf-8");
                repairActions.push({ action: repair, success: true, path: "STATE.md" });
                break;
              }
            }
          } catch (err) {
            debugLog("validate.health", "write failed", err);
            repairActions.push({ action: repair, success: false, error: err.message });
          }
        }
      }
      let status;
      if (errors.length > 0) {
        status = "broken";
      } else if (warnings.length > 0) {
        status = "degraded";
      } else {
        status = "healthy";
      }
      const repairableCount = errors.filter((e) => e.repairable).length + warnings.filter((w) => w.repairable).length;
      output({
        status,
        errors,
        warnings,
        info,
        repairable_count: repairableCount,
        repairs_performed: repairActions.length > 0 ? repairActions : void 0
      }, raw);
    }
    function cmdAnalyzePlan(cwd, planPath, raw) {
      if (!planPath) {
        error("plan file path required");
      }
      const fullPath = path.isAbsolute(planPath) ? planPath : path.join(cwd, planPath);
      const content = safeReadFile(fullPath);
      if (!content) {
        output({ error: "File not found", path: planPath }, raw);
        return;
      }
      const fm = extractFrontmatter(content);
      const planId = fm.phase && fm.plan ? `${String(fm.phase).replace(/^0+/, "")}-${String(fm.plan).replace(/^0+/, "").padStart(2, "0")}` : path.basename(planPath, ".md").replace(/-PLAN$/i, "");
      const taskPattern = /<task[^>]*>([\s\S]*?)<\/task>/g;
      const tasks = [];
      let taskMatch;
      while ((taskMatch = taskPattern.exec(content)) !== null) {
        const taskContent = taskMatch[1];
        const nameMatch = taskContent.match(/<name>([\s\S]*?)<\/name>/);
        const filesMatch = taskContent.match(/<files>([\s\S]*?)<\/files>/);
        const taskName = nameMatch ? nameMatch[1].trim() : "unnamed";
        const taskFiles = filesMatch ? filesMatch[1].split("\n").map((f) => f.trim()).filter((f) => f.length > 0) : [];
        tasks.push({ name: taskName, files: taskFiles });
      }
      const allFiles = [];
      const dirSet = /* @__PURE__ */ new Set();
      for (const task of tasks) {
        for (const file of task.files) {
          allFiles.push(file);
          const dir = path.dirname(file);
          dirSet.add(dir === "." ? "(root)" : dir);
        }
      }
      const taskDirs = tasks.map((t) => {
        const dirs = /* @__PURE__ */ new Set();
        for (const f of t.files) {
          const dir = path.dirname(f);
          dirs.add(dir === "." ? "(root)" : dir);
        }
        return dirs;
      });
      const parent = tasks.map((_, i) => i);
      function find(x) {
        while (parent[x] !== x) {
          parent[x] = parent[parent[x]];
          x = parent[x];
        }
        return x;
      }
      function union(a, b) {
        const ra = find(a);
        const rb = find(b);
        if (ra !== rb) parent[ra] = rb;
      }
      for (let i = 0; i < tasks.length; i++) {
        for (let j = i + 1; j < tasks.length; j++) {
          for (const dir of taskDirs[i]) {
            if (taskDirs[j].has(dir)) {
              union(i, j);
              break;
            }
          }
        }
      }
      const groups = {};
      for (let i = 0; i < tasks.length; i++) {
        const root = find(i);
        if (!groups[root]) groups[root] = { tasks: [], files: /* @__PURE__ */ new Set(), dirs: /* @__PURE__ */ new Set() };
        groups[root].tasks.push(tasks[i].name);
        for (const f of tasks[i].files) groups[root].files.add(f);
        for (const d of taskDirs[i]) groups[root].dirs.add(d);
      }
      const concerns = Object.values(groups).map((g, idx) => {
        const dirsArr = [...g.dirs];
        const area = dirsArr.length > 0 ? dirsArr[0].split("/").filter((s) => s !== "(root)")[0] || "(root)" : "(none)";
        return {
          group: idx + 1,
          tasks: g.tasks,
          files: [...g.files],
          area
        };
      });
      const concernCount = concerns.length;
      const taskCount = tasks.length;
      const dirCount = dirSet.size;
      let base = 5;
      if (concernCount > 1) base -= 1;
      if (concernCount > 2) base -= 1;
      if (concernCount > 3) base -= 1;
      if (taskCount > 3) base -= 1;
      if (taskCount > 5) base -= 1;
      const srScore = Math.max(1, Math.min(5, base));
      const labels = { 5: "Excellent", 4: "Good", 3: "Acceptable", 2: "Poor", 1: "Bad" };
      const srLabel = labels[srScore];
      let splitSuggestion = null;
      if (srScore <= 3 && concernCount > 1) {
        splitSuggestion = {
          recommended_splits: concernCount,
          proposed_plans: concerns.map((c, idx) => ({
            plan_suffix: String(idx + 1).padStart(2, "0"),
            area: c.area,
            tasks: c.tasks,
            files: c.files
          }))
        };
      }
      const flags = [];
      if (taskCount === 0) flags.push("no_tasks_found");
      if (dirCount > 5) flags.push("high_directory_spread");
      if (concernCount > 3) flags.push("many_concerns");
      output({
        plan: planId,
        sr_score: srScore,
        sr_label: srLabel,
        concern_count: concernCount,
        concerns,
        task_count: taskCount,
        files_total: allFiles.length,
        directories_touched: dirCount,
        split_suggestion: splitSuggestion,
        flags
      }, raw);
    }
    function cmdVerifyDeliverables(cwd, options, raw) {
      const { execSync } = require("child_process");
      const { loadConfig } = require_config();
      let testCommand = null;
      let framework = null;
      const config = loadConfig(cwd);
      if (config.test_commands && typeof config.test_commands === "object") {
        const keys = Object.keys(config.test_commands);
        if (keys.length > 0) {
          framework = keys[0];
          testCommand = config.test_commands[framework];
        }
      }
      if (!testCommand) {
        if (fs.existsSync(path.join(cwd, "package.json"))) {
          framework = "npm";
          testCommand = "npm test";
        } else if (fs.existsSync(path.join(cwd, "mix.exs"))) {
          framework = "mix";
          testCommand = "mix test";
        } else if (fs.existsSync(path.join(cwd, "go.mod"))) {
          framework = "go";
          testCommand = "go test ./...";
        }
      }
      if (!testCommand) {
        output({
          test_result: "skip",
          tests_passed: 0,
          tests_failed: 0,
          tests_total: 0,
          framework: null,
          verdict: "skip",
          reason: "No test framework detected"
        }, raw, "skip");
        return;
      }
      let testOutput = "";
      let testExitCode = 0;
      try {
        testOutput = execSync(testCommand, {
          cwd,
          encoding: "utf-8",
          timeout: 6e4,
          stdio: ["pipe", "pipe", "pipe"]
        });
      } catch (err) {
        testExitCode = err.status || 1;
        testOutput = (err.stdout || "") + "\n" + (err.stderr || "");
      }
      let testsPassed = 0;
      let testsFailed = 0;
      let testsTotal = 0;
      const passMatch = testOutput.match(/(\d+)\s+pass(?:ing|ed)?/i) || testOutput.match(/pass\s+(\d+)/i);
      const failMatch = testOutput.match(/(\d+)\s+fail(?:ing|ed|ure)?/i) || testOutput.match(/fail\s+(\d+)/i);
      const totalMatch = testOutput.match(/(?:tests?|suites?)\s+(\d+)/i) || testOutput.match(/(\d+)\s+tests?/i);
      if (passMatch) testsPassed = parseInt(passMatch[1], 10);
      if (failMatch) testsFailed = parseInt(failMatch[1], 10);
      if (totalMatch) testsTotal = parseInt(totalMatch[1], 10);
      if (testsTotal === 0 && (testsPassed > 0 || testsFailed > 0)) {
        testsTotal = testsPassed + testsFailed;
      }
      const testResult = testExitCode === 0 ? "pass" : "fail";
      let artifactsOk = true;
      let keyLinksOk = true;
      if (options && options.plan) {
        const planPath = path.isAbsolute(options.plan) ? options.plan : path.join(cwd, options.plan);
        const planContent = safeReadFile(planPath);
        if (planContent) {
          const artifacts = parseMustHavesBlock(planContent, "artifacts");
          if (artifacts.length > 0) {
            for (const artifact of artifacts) {
              if (typeof artifact === "string") continue;
              const artPath = artifact.path;
              if (!artPath) continue;
              if (!fs.existsSync(path.join(cwd, artPath))) {
                artifactsOk = false;
                break;
              }
            }
          }
          const keyLinks = parseMustHavesBlock(planContent, "key_links");
          if (keyLinks.length > 0) {
            for (const link of keyLinks) {
              if (typeof link === "string") continue;
              const sourceContent = safeReadFile(path.join(cwd, link.from || ""));
              if (!sourceContent) {
                keyLinksOk = false;
                break;
              }
            }
          }
        }
      }
      const verdict = testResult === "pass" && artifactsOk && keyLinksOk ? "pass" : "fail";
      output({
        test_result: testResult,
        tests_passed: testsPassed,
        tests_failed: testsFailed,
        tests_total: testsTotal,
        framework,
        artifacts_ok: artifactsOk,
        key_links_ok: keyLinksOk,
        verdict
      }, raw, verdict);
    }
    function formatVerifyRequirements(result) {
      const lines = [];
      lines.push(banner("Requirements"));
      lines.push("");
      if (result.error) {
        lines.push(box(result.error, "warning"));
        return lines.join("\n");
      }
      const addressedPercent = result.total > 0 ? Math.round(result.addressed / result.total * 100) : 0;
      lines.push(`  ${result.addressed}/${result.total} requirements addressed`);
      lines.push("  " + progressBar(addressedPercent));
      lines.push("");
      if (result.unaddressed_list && result.unaddressed_list.length > 0) {
        lines.push(sectionHeader("Unaddressed"));
        lines.push("");
        const rows = result.unaddressed_list.map((u) => [
          SYMBOLS.cross + " " + u.id,
          u.phase ? "Phase " + u.phase : color.dim("n/a"),
          u.reason || ""
        ]);
        lines.push(formatTable(["ID", "Phase", "Reason"], rows));
        lines.push("");
      }
      if (result.assertions) {
        const a = result.assertions;
        lines.push(sectionHeader("Assertions"));
        lines.push("");
        const passStr = color.green(a.verified + " pass");
        const failStr = a.failed > 0 ? color.red(a.failed + " fail") : color.dim(a.failed + " fail");
        const humanStr = a.needs_human > 0 ? color.yellow(a.needs_human + " needs human") : color.dim(a.needs_human + " needs human");
        lines.push("  " + passStr + ", " + failStr + ", " + humanStr);
        lines.push("");
      }
      if (result.addressed === result.total) {
        lines.push(summaryLine(SYMBOLS.check + " All requirements addressed"));
      } else {
        lines.push(summaryLine(result.unaddressed + " requirements need attention"));
      }
      return lines.join("\n");
    }
    function cmdVerifyRequirements(cwd, options, raw) {
      const reqPath = path.join(cwd, ".planning", "REQUIREMENTS.md");
      const content = safeReadFile(reqPath);
      if (!content) {
        output({
          total: 0,
          addressed: 0,
          unaddressed: 0,
          unaddressed_list: [],
          error: "REQUIREMENTS.md not found"
        }, raw, "skip");
        return;
      }
      const reqPattern = /- \[(x| )\] \*\*(\w+-\d+)\*\*/g;
      const requirements = [];
      let match;
      while ((match = reqPattern.exec(content)) !== null) {
        requirements.push({
          id: match[2],
          checked: match[1] === "x"
        });
      }
      const tracePattern = /\| (\w+-\d+) \| Phase (\d+)[^|\n]*\|[^|\n]*\|([^|\n]*)/g;
      const traceMap = {};
      while ((match = tracePattern.exec(content)) !== null) {
        const testCommand = match[3] ? match[3].trim() : null;
        traceMap[match[1]] = { phase: match[2], testCommand: testCommand || null };
      }
      if (Object.keys(traceMap).length === 0) {
        const simpleTracePattern = /\| (\w+-\d+) \| Phase (\d+)/g;
        while ((match = simpleTracePattern.exec(content)) !== null) {
          traceMap[match[1]] = { phase: match[2], testCommand: null };
        }
      }
      const unaddressedList = [];
      let addressedCount = 0;
      for (const req of requirements) {
        if (req.checked) {
          addressedCount++;
          continue;
        }
        const traceEntry = traceMap[req.id];
        const phase = traceEntry ? traceEntry.phase : null;
        if (phase) {
          const phasePadded = phase.padStart(2, "0");
          const phasesDir = path.join(cwd, ".planning", "phases");
          let hasSummaries = false;
          try {
            const entries = fs.readdirSync(phasesDir, { withFileTypes: true });
            for (const entry of entries) {
              if (entry.isDirectory() && entry.name.startsWith(phasePadded)) {
                const phaseFiles = fs.readdirSync(path.join(phasesDir, entry.name));
                if (phaseFiles.some((f) => f.endsWith("-SUMMARY.md") || f === "SUMMARY.md")) {
                  hasSummaries = true;
                }
                break;
              }
            }
          } catch (e) {
            debugLog("verify.requirements", "readdir failed", e);
          }
          if (hasSummaries) {
            addressedCount++;
          } else {
            unaddressedList.push({ id: req.id, phase, reason: "Phase has no summaries" });
          }
        } else {
          unaddressedList.push({ id: req.id, phase: null, reason: "Not in traceability table" });
        }
      }
      const testCommands = { total: 0, valid: 0, invalid: 0, coverage_percent: 0, commands: [] };
      const knownCommands = /* @__PURE__ */ new Set(["npm", "node", "npx", "mix", "go", "cargo", "pytest", "python", "python3", "ruby", "bundle", "jest", "mocha", "vitest"]);
      for (const [reqId, entry] of Object.entries(traceMap)) {
        if (entry.testCommand) {
          testCommands.total++;
          const baseCommand = entry.testCommand.split(/\s+/)[0];
          const valid = knownCommands.has(baseCommand);
          if (valid) testCommands.valid++;
          else testCommands.invalid++;
          testCommands.commands.push({ reqId, command: entry.testCommand, valid });
        }
      }
      testCommands.coverage_percent = requirements.length > 0 ? Math.round(testCommands.total / requirements.length * 100) : 0;
      const assertionsPath = path.join(cwd, ".planning", "ASSERTIONS.md");
      const assertionsContent = safeReadFile(assertionsPath);
      const allAssertions = assertionsContent ? parseAssertionsMd(assertionsContent) : null;
      let assertionsResult = null;
      if (allAssertions && Object.keys(allAssertions).length > 0) {
        let totalAssertions = 0;
        let verified = 0;
        let failed = 0;
        let needsHuman = 0;
        let mustHavePass = 0;
        let mustHaveFail = 0;
        const byRequirement = {};
        for (const [reqId, data] of Object.entries(allAssertions)) {
          const reqResult = { assertion_count: 0, pass: 0, fail: 0, needs_human: 0, assertions: [] };
          for (const a of data.assertions) {
            totalAssertions++;
            reqResult.assertion_count++;
            let status = "needs_human";
            let evidence = null;
            if (a.type === "file") {
              const filePatterns = a.assert.match(/[\w./-]+\.\w{1,10}/g) || [];
              const whenPatterns = a.when ? a.when.match(/[\w./-]+\.\w{1,10}/g) || [] : [];
              const thenPatterns = a.then ? a.then.match(/[\w./-]+\.\w{1,10}/g) || [] : [];
              const allPatterns = [...filePatterns, ...whenPatterns, ...thenPatterns];
              if (allPatterns.length > 0) {
                const existingFiles = allPatterns.filter((p) => {
                  return fs.existsSync(path.join(cwd, p)) || fs.existsSync(path.join(cwd, ".planning", p)) || fs.existsSync(path.join(cwd, "templates", p));
                });
                if (existingFiles.length > 0) {
                  status = "pass";
                  evidence = `Files found: ${existingFiles.join(", ")}`;
                } else {
                  status = "fail";
                  evidence = `No matching files on disk for: ${allPatterns.join(", ")}`;
                }
              } else {
                status = "needs_human";
                evidence = "No file path detected in assertion text";
              }
            } else if (a.type === "cli") {
              const whenText = (a.when || a.assert || "").toLowerCase();
              const gsdCommands = [
                "assertions",
                "verify",
                "trace-requirement",
                "env",
                "mcp-profile",
                "init",
                "state",
                "roadmap",
                "phase",
                "memory",
                "intent",
                "context-budget",
                "test-run",
                "search-decisions",
                "validate-dependencies",
                "search-lessons",
                "codebase-impact",
                "rollback-info",
                "velocity",
                "validate-config",
                "quick-summary",
                "extract-sections",
                "test-coverage",
                "token-budget",
                "session-diff"
              ];
              const matchedCmd = gsdCommands.find((cmd) => whenText.includes(cmd));
              if (matchedCmd) {
                status = "pass";
                evidence = `CLI command "${matchedCmd}" exists in gsd-tools`;
              } else {
                status = "needs_human";
                evidence = "Could not map assertion to a known CLI command";
              }
            }
            if (status === "pass") {
              verified++;
              reqResult.pass++;
              if (a.priority === "must-have") mustHavePass++;
            } else if (status === "fail") {
              failed++;
              reqResult.fail++;
              if (a.priority === "must-have") mustHaveFail++;
            } else {
              needsHuman++;
              reqResult.needs_human++;
            }
            const assertionEntry = {
              assert: a.assert,
              priority: a.priority,
              type: a.type || null,
              status,
              evidence
            };
            if (status === "fail" && a.priority === "must-have") {
              assertionEntry.gap_description = `[${reqId}] Must-have assertion failed: ${a.assert}`;
            }
            reqResult.assertions.push(assertionEntry);
          }
          byRequirement[reqId] = reqResult;
        }
        const coveragePercent = totalAssertions > 0 ? Math.round((verified + failed) / totalAssertions * 100) : 0;
        assertionsResult = {
          total: totalAssertions,
          verified,
          failed,
          needs_human: needsHuman,
          must_have_pass: mustHavePass,
          must_have_fail: mustHaveFail,
          coverage_percent: coveragePercent,
          by_requirement: byRequirement
        };
      }
      const result = {
        total: requirements.length,
        addressed: addressedCount,
        unaddressed: unaddressedList.length,
        unaddressed_list: unaddressedList
      };
      if (assertionsResult) {
        result.assertions = assertionsResult;
      }
      if (testCommands.total > 0) {
        result.test_commands = testCommands;
      }
      let rawValue;
      if (assertionsResult) {
        rawValue = `${requirements.length} reqs (${addressedCount} addressed), ${assertionsResult.total} assertions (${assertionsResult.verified} pass, ${assertionsResult.failed} fail, ${assertionsResult.needs_human} human)`;
      } else {
        rawValue = unaddressedList.length === 0 ? "pass" : "fail";
      }
      output(result, { formatter: formatVerifyRequirements, rawValue });
    }
    function cmdVerifyRegression(cwd, options, raw) {
      const memoryDir = path.join(cwd, ".planning", "memory");
      const baselinePath = path.join(memoryDir, "test-baseline.json");
      let beforeData = null;
      let afterData = null;
      if (options && options.before && options.after) {
        const beforePath = path.isAbsolute(options.before) ? options.before : path.join(cwd, options.before);
        const afterPath = path.isAbsolute(options.after) ? options.after : path.join(cwd, options.after);
        const beforeContent = safeReadFile(beforePath);
        const afterContent = safeReadFile(afterPath);
        if (!beforeContent) {
          output({ error: "Before file not found", path: options.before }, raw, "error");
          return;
        }
        if (!afterContent) {
          output({ error: "After file not found", path: options.after }, raw, "error");
          return;
        }
        try {
          beforeData = JSON.parse(beforeContent);
          afterData = JSON.parse(afterContent);
        } catch (e) {
          debugLog("verify.regression", "JSON parse failed", e);
          output({ error: "Invalid JSON in before/after files" }, raw, "error");
          return;
        }
      } else {
        const baselineContent = safeReadFile(baselinePath);
        if (!baselineContent) {
          output({
            regressions: [],
            regression_count: 0,
            verdict: "pass",
            note: "No baseline found. Save a baseline with --before/--after or store test-baseline.json in .planning/memory/"
          }, raw, "pass");
          return;
        }
        try {
          beforeData = JSON.parse(baselineContent);
        } catch (e) {
          debugLog("verify.regression", "baseline parse failed", e);
          output({ error: "Invalid JSON in test-baseline.json" }, raw, "error");
          return;
        }
        if (!afterData) {
          output({
            regressions: [],
            regression_count: 0,
            verdict: "pass",
            note: "Baseline found but no current results provided. Pass --after to compare."
          }, raw, "pass");
          return;
        }
      }
      const beforeMap = {};
      if (beforeData.tests && Array.isArray(beforeData.tests)) {
        for (const t of beforeData.tests) {
          beforeMap[t.name] = t.status;
        }
      }
      const regressions = [];
      if (afterData.tests && Array.isArray(afterData.tests)) {
        for (const t of afterData.tests) {
          const beforeStatus = beforeMap[t.name];
          if (beforeStatus === "pass" && t.status === "fail") {
            regressions.push({
              test_name: t.name,
              before: "pass",
              after: "fail"
            });
          }
        }
      }
      output({
        regressions,
        regression_count: regressions.length,
        verdict: regressions.length === 0 ? "pass" : "fail"
      }, raw, regressions.length === 0 ? "pass" : "fail");
    }
    function cmdVerifyPlanWave(cwd, phasePath, raw) {
      if (!phasePath) {
        error("phase directory path required");
      }
      const fullPath = path.isAbsolute(phasePath) ? phasePath : path.join(cwd, phasePath);
      let files;
      try {
        files = fs.readdirSync(fullPath);
      } catch (e) {
        debugLog("verify.planWave", "readdir failed", e);
        output({ error: "Cannot read phase directory", path: phasePath }, raw);
        return;
      }
      const planFiles = files.filter((f) => f.match(/-PLAN\.md$/i)).sort();
      const dirName = path.basename(fullPath);
      const phaseMatch = dirName.match(/^(\d+(?:\.\d+)?)/);
      const phaseNum = phaseMatch ? phaseMatch[1] : dirName;
      const plansByWave = {};
      for (const planFile of planFiles) {
        const content = safeReadFile(path.join(fullPath, planFile));
        if (!content) continue;
        const fm = extractFrontmatter(content);
        const wave = fm.wave ? String(fm.wave) : "1";
        const planId = planFile.replace(/-PLAN\.md$/i, "");
        let filesModified = [];
        if (Array.isArray(fm.files_modified)) {
          filesModified = fm.files_modified;
        } else if (typeof fm.files_modified === "string" && fm.files_modified.trim()) {
          filesModified = [fm.files_modified];
        }
        if (!plansByWave[wave]) plansByWave[wave] = [];
        plansByWave[wave].push({ id: planId, files: filesModified });
      }
      const waves = {};
      for (const [wave, plans] of Object.entries(plansByWave)) {
        waves[wave] = plans.map((p) => p.id);
      }
      const conflicts = [];
      for (const [wave, plans] of Object.entries(plansByWave)) {
        const fileMap = {};
        for (const plan of plans) {
          for (const file of plan.files) {
            if (!fileMap[file]) fileMap[file] = [];
            fileMap[file].push(plan.id);
          }
        }
        for (const [file, planIds] of Object.entries(fileMap)) {
          if (planIds.length > 1) {
            conflicts.push({ wave: parseInt(wave, 10), file, plans: planIds });
          }
        }
      }
      const verdict = conflicts.length > 0 ? "conflicts_found" : "clean";
      output({
        phase: phaseNum,
        waves,
        conflicts,
        verdict
      }, raw, verdict);
    }
    function cmdVerifyPlanDeps(cwd, phasePath, raw) {
      if (!phasePath) {
        error("phase directory path required");
      }
      const fullPath = path.isAbsolute(phasePath) ? phasePath : path.join(cwd, phasePath);
      let files;
      try {
        files = fs.readdirSync(fullPath);
      } catch (e) {
        debugLog("verify.planDeps", "readdir failed", e);
        output({ error: "Cannot read phase directory", path: phasePath }, raw);
        return;
      }
      const planFiles = files.filter((f) => f.match(/-PLAN\.md$/i)).sort();
      const dirName = path.basename(fullPath);
      const phaseMatch = dirName.match(/^(\d+(?:\.\d+)?)/);
      const phaseNum = phaseMatch ? phaseMatch[1] : dirName;
      const plans = {};
      for (const planFile of planFiles) {
        const content = safeReadFile(path.join(fullPath, planFile));
        if (!content) continue;
        const fm = extractFrontmatter(content);
        const planIdMatch = planFile.match(/(\d{2})-PLAN\.md$/i);
        const planId = planIdMatch ? planIdMatch[1] : fm.plan || planFile.replace(/-PLAN\.md$/i, "");
        let dependsOn = [];
        if (Array.isArray(fm.depends_on)) {
          dependsOn = fm.depends_on;
        } else if (typeof fm.depends_on === "string" && fm.depends_on.trim()) {
          dependsOn = [fm.depends_on];
        }
        const normalizedDeps = dependsOn.map((d) => {
          const depMatch = d.match(/(?:\d+-)?(\d+)$/);
          return depMatch ? depMatch[1] : d;
        }).filter((d) => d.trim());
        const wave = fm.wave ? parseInt(fm.wave, 10) : 1;
        plans[planId] = { deps: normalizedDeps, wave };
      }
      const planIds = new Set(Object.keys(plans));
      const dependencyGraph = {};
      for (const [id, info] of Object.entries(plans)) {
        dependencyGraph[id] = info.deps;
      }
      const issues = [];
      for (const [id, info] of Object.entries(plans)) {
        for (const dep of info.deps) {
          if (!planIds.has(dep)) {
            issues.push({ type: "unreachable", plan: id, dep, message: `Plan ${id} depends on ${dep} which is not in this phase` });
          }
        }
      }
      const WHITE = 0, GRAY = 1, BLACK = 2;
      const color2 = {};
      for (const id of planIds) color2[id] = WHITE;
      function dfs(node, pathStack) {
        color2[node] = GRAY;
        pathStack.push(node);
        const deps = plans[node] ? plans[node].deps : [];
        for (const dep of deps) {
          if (!planIds.has(dep)) continue;
          if (color2[dep] === GRAY) {
            const cycleStart = pathStack.indexOf(dep);
            const cycle = pathStack.slice(cycleStart).concat(dep);
            issues.push({ type: "cycle", plans: cycle, message: `Dependency cycle: ${cycle.join(" \u2192 ")}` });
            return;
          }
          if (color2[dep] === WHITE) {
            dfs(dep, pathStack);
          }
        }
        pathStack.pop();
        color2[node] = BLACK;
      }
      for (const id of planIds) {
        if (color2[id] === WHITE) {
          dfs(id, []);
        }
      }
      for (const [id, info] of Object.entries(plans)) {
        if (info.wave > 1) {
          const hasLowerWaveDep = info.deps.some((dep) => {
            return planIds.has(dep) && plans[dep] && plans[dep].wave < info.wave;
          });
          if (!hasLowerWaveDep && info.deps.length === 0) {
            issues.push({
              type: "unnecessary_serialization",
              plan: id,
              wave: info.wave,
              message: `Plan ${id} is in wave ${info.wave} but has no dependencies on lower waves \u2014 could be wave 1`
            });
          }
        }
      }
      const verdict = issues.length > 0 ? "issues_found" : "clean";
      output({
        phase: phaseNum,
        plan_count: planIds.size,
        dependency_graph: dependencyGraph,
        issues,
        verdict
      }, raw, verdict);
    }
    function formatVerifyQuality(result) {
      const lines = [];
      lines.push(banner("Quality"));
      lines.push("");
      const scorePct = Math.max(0, Math.min(100, result.score || 0));
      const gradeColor = colorByPercent(scorePct);
      lines.push("  " + color.bold(gradeColor(result.grade)) + " " + gradeColor("(" + scorePct + "/100)"));
      lines.push("");
      const dimNames = { tests: "Tests", must_haves: "Must-Haves", requirements: "Requirements", regression: "Regression" };
      lines.push(sectionHeader("Dimensions"));
      lines.push("");
      const rows = [];
      for (const [key, dim] of Object.entries(result.dimensions || {})) {
        const name = dimNames[key] || key;
        let scoreStr;
        if (dim.score === null || dim.score === void 0) {
          scoreStr = color.dim("n/a");
        } else {
          const dimColor = colorByPercent(dim.score);
          scoreStr = dimColor(String(dim.score));
        }
        rows.push([name, scoreStr, String(dim.weight) + "%", dim.detail || ""]);
      }
      lines.push(formatTable(["Dimension", "Score", "Weight", "Detail"], rows));
      lines.push("");
      const trend = result.trend || "stable";
      let trendStr;
      if (trend === "improving") {
        trendStr = color.green("\u2191 improving");
      } else if (trend === "declining") {
        trendStr = color.red("\u2193 declining");
      } else {
        trendStr = color.dim("\u2192 stable");
      }
      lines.push("  Trend: " + trendStr);
      lines.push("");
      lines.push(summaryLine("Quality: " + result.grade + " (" + scorePct + "/100) \u2014 " + trend));
      return lines.join("\n");
    }
    function cmdVerifyQuality(cwd, options, raw) {
      const { execSync } = require("child_process");
      const { loadConfig } = require_config();
      const phaseNum = options.phase || null;
      const planPath = options.plan || null;
      let testsScore = null;
      let testsDetail = "no test framework detected";
      const config = loadConfig(cwd);
      let testCommand = null;
      let framework = null;
      if (config.test_commands && typeof config.test_commands === "object") {
        const keys = Object.keys(config.test_commands);
        if (keys.length > 0) {
          framework = keys[0];
          testCommand = config.test_commands[framework];
        }
      }
      if (!testCommand) {
        if (fs.existsSync(path.join(cwd, "package.json"))) {
          framework = "npm";
          testCommand = "npm test";
        } else if (fs.existsSync(path.join(cwd, "mix.exs"))) {
          framework = "mix";
          testCommand = "mix test";
        } else if (fs.existsSync(path.join(cwd, "go.mod"))) {
          framework = "go";
          testCommand = "go test ./...";
        }
      }
      if (testCommand) {
        let testExitCode = 0;
        let testOutput = "";
        try {
          testOutput = execSync(testCommand, {
            cwd,
            encoding: "utf-8",
            timeout: 12e4,
            stdio: ["pipe", "pipe", "pipe"]
          });
        } catch (err) {
          testExitCode = err.status || 1;
          testOutput = (err.stdout || "") + "\n" + (err.stderr || "");
        }
        if (testExitCode === 0) {
          testsScore = 100;
          const passMatch = testOutput.match(/(\d+)\s+pass(?:ing|ed)?/i) || testOutput.match(/pass\s+(\d+)/i);
          const count = passMatch ? passMatch[1] : "?";
          testsDetail = `all ${count} pass`;
        } else {
          testsScore = 0;
          const failMatch = testOutput.match(/(\d+)\s+fail(?:ing|ed|ure)?/i) || testOutput.match(/fail\s+(\d+)/i);
          const count = failMatch ? failMatch[1] : "?";
          testsDetail = `${count} failing`;
        }
      }
      let mustHavesScore = null;
      let mustHavesDetail = "no plan specified";
      if (planPath) {
        const fullPlanPath = path.isAbsolute(planPath) ? planPath : path.join(cwd, planPath);
        const planContent = safeReadFile(fullPlanPath);
        if (planContent) {
          const artifacts = parseMustHavesBlock(planContent, "artifacts");
          const keyLinks = parseMustHavesBlock(planContent, "key_links");
          let total = 0;
          let verified = 0;
          for (const artifact of artifacts) {
            if (typeof artifact === "string") continue;
            if (!artifact.path) continue;
            total++;
            const artFullPath = path.join(cwd, artifact.path);
            if (fs.existsSync(artFullPath)) {
              let ok = true;
              if (artifact.contains) {
                const fileContent = safeReadFile(artFullPath) || "";
                if (!fileContent.includes(artifact.contains)) ok = false;
              }
              if (ok) verified++;
            }
          }
          for (const link of keyLinks) {
            if (typeof link === "string") continue;
            total++;
            const sourceContent = safeReadFile(path.join(cwd, link.from || ""));
            if (sourceContent) {
              if (link.pattern) {
                try {
                  const regex = new RegExp(link.pattern);
                  if (regex.test(sourceContent)) {
                    verified++;
                  }
                } catch (e) {
                  debugLog("verify.quality", "regex failed", e);
                }
              } else {
                verified++;
              }
            }
          }
          if (total > 0) {
            mustHavesScore = Math.round(verified / total * 100);
            mustHavesDetail = `${verified}/${total} verified`;
          } else {
            mustHavesDetail = "no must_haves defined";
          }
        } else {
          mustHavesDetail = "plan file not found";
        }
      }
      let reqScore = null;
      let reqDetail = "no REQUIREMENTS.md";
      const reqPath = path.join(cwd, ".planning", "REQUIREMENTS.md");
      const reqContent = safeReadFile(reqPath);
      if (reqContent) {
        const reqPattern = /- \[(x| )\] \*\*(\w+-\d+)\*\*/g;
        const requirements = [];
        let reqMatch;
        while ((reqMatch = reqPattern.exec(reqContent)) !== null) {
          requirements.push({ id: reqMatch[2], checked: reqMatch[1] === "x" });
        }
        let filteredReqs = requirements;
        if (phaseNum) {
          const tracePattern = /\| (\w+-\d+) \| Phase (\d+)/g;
          const traceMap = {};
          let tm;
          while ((tm = tracePattern.exec(reqContent)) !== null) {
            traceMap[tm[1]] = tm[2];
          }
          const pn = String(parseInt(phaseNum, 10));
          filteredReqs = requirements.filter((r) => {
            const mapped = traceMap[r.id];
            return mapped && String(parseInt(mapped, 10)) === pn;
          });
        }
        if (filteredReqs.length > 0) {
          const addressed = filteredReqs.filter((r) => r.checked).length;
          reqScore = Math.round(addressed / filteredReqs.length * 100);
          reqDetail = `${addressed}/${filteredReqs.length} addressed`;
        } else {
          reqDetail = phaseNum ? `no requirements mapped to phase ${phaseNum}` : "no requirements found";
        }
      }
      let regressionScore = null;
      let regressionDetail = "no baseline";
      const baselinePath = path.join(cwd, ".planning", "memory", "test-baseline.json");
      const baselineContent = safeReadFile(baselinePath);
      if (baselineContent) {
        try {
          const baseline = JSON.parse(baselineContent);
          if (baseline.tests_total !== void 0 && baseline.tests_failed !== void 0) {
            regressionScore = baseline.tests_failed === 0 ? 100 : 0;
            regressionDetail = baseline.tests_failed === 0 ? "no regressions" : `${baseline.tests_failed} regressions`;
          } else if (baseline.tests && Array.isArray(baseline.tests)) {
            const failures = baseline.tests.filter((t) => t.status === "fail").length;
            regressionScore = failures === 0 ? 100 : 0;
            regressionDetail = failures === 0 ? "no regressions" : `${failures} regressions`;
          }
        } catch (e) {
          debugLog("verify.quality", "baseline parse failed", e);
          regressionDetail = "invalid baseline JSON";
        }
      }
      const dimensions = {
        tests: { score: testsScore, weight: 30, detail: testsDetail },
        must_haves: { score: mustHavesScore, weight: 30, detail: mustHavesDetail },
        requirements: { score: reqScore, weight: 20, detail: reqDetail },
        regression: { score: regressionScore, weight: 20, detail: regressionDetail }
      };
      let totalWeight = 0;
      let weightedSum = 0;
      for (const dim of Object.values(dimensions)) {
        if (dim.score !== null) {
          totalWeight += dim.weight;
          weightedSum += dim.score * dim.weight;
        }
      }
      const score = totalWeight > 0 ? Math.round(weightedSum / totalWeight) : 0;
      let grade;
      if (score >= 90) grade = "A";
      else if (score >= 80) grade = "B";
      else if (score >= 70) grade = "C";
      else if (score >= 60) grade = "D";
      else grade = "F";
      let planId = null;
      if (planPath) {
        const planBase = path.basename(planPath, ".md").replace(/-PLAN$/i, "");
        planId = planBase;
      }
      const memoryDir = path.join(cwd, ".planning", "memory");
      const scoresPath = path.join(memoryDir, "quality-scores.json");
      let scores = [];
      const scoresContent = safeReadFile(scoresPath);
      if (scoresContent) {
        try {
          scores = JSON.parse(scoresContent);
          if (!Array.isArray(scores)) scores = [];
        } catch (e) {
          debugLog("verify.quality", "scores parse failed", e);
          scores = [];
        }
      }
      const entry = {
        phase: phaseNum || (planId ? planId.split("-")[0] : null),
        plan: planId,
        score,
        grade,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
      scores.push(entry);
      try {
        if (!fs.existsSync(memoryDir)) {
          fs.mkdirSync(memoryDir, { recursive: true });
        }
        fs.writeFileSync(scoresPath, JSON.stringify(scores, null, 2), "utf-8");
      } catch (e) {
        debugLog("verify.quality", "write scores failed", e);
      }
      let trend = "stable";
      if (scores.length >= 3) {
        const last3 = scores.slice(-3);
        const s = last3.map((e) => e.score);
        if (s[0] < s[1] && s[1] < s[2]) trend = "improving";
        else if (s[0] > s[1] && s[1] > s[2]) trend = "declining";
      }
      output({
        score,
        grade,
        dimensions,
        trend,
        plan: planId,
        phase: phaseNum || (planId ? planId.split("-")[0] : null)
      }, { formatter: formatVerifyQuality });
    }
    function cmdAssertionsList(cwd, options, raw) {
      const assertionsPath = path.join(cwd, ".planning", "ASSERTIONS.md");
      const content = safeReadFile(assertionsPath);
      if (!content) {
        output({ error: "ASSERTIONS.md not found", path: ".planning/ASSERTIONS.md" }, raw, "ASSERTIONS.md not found");
        return;
      }
      const parsed = parseAssertionsMd(content);
      const reqId = options && options.reqId;
      const requirements = {};
      let totalAssertions = 0;
      let mustHaveCount = 0;
      let niceToHaveCount = 0;
      for (const [id, data] of Object.entries(parsed)) {
        if (reqId && id !== reqId) continue;
        const assertions = data.assertions || [];
        const must = assertions.filter((a) => a.priority === "must-have").length;
        const nice = assertions.filter((a) => a.priority === "nice-to-have").length;
        totalAssertions += assertions.length;
        mustHaveCount += must;
        niceToHaveCount += nice;
        requirements[id] = {
          description: data.description,
          assertion_count: assertions.length,
          assertions
        };
      }
      const totalRequirements = Object.keys(requirements).length;
      const rawValue = `${totalRequirements} requirements, ${totalAssertions} assertions (${mustHaveCount} must-have, ${niceToHaveCount} nice-to-have)`;
      output({
        total_requirements: totalRequirements,
        total_assertions: totalAssertions,
        must_have_count: mustHaveCount,
        nice_to_have_count: niceToHaveCount,
        requirements
      }, raw, rawValue);
    }
    function cmdAssertionsValidate(cwd, raw) {
      const assertionsPath = path.join(cwd, ".planning", "ASSERTIONS.md");
      const content = safeReadFile(assertionsPath);
      if (!content) {
        output({ error: "ASSERTIONS.md not found", path: ".planning/ASSERTIONS.md" }, raw, "ASSERTIONS.md not found");
        return;
      }
      const parsed = parseAssertionsMd(content);
      const issues = [];
      const reqPath = path.join(cwd, ".planning", "REQUIREMENTS.md");
      const reqContent = safeReadFile(reqPath);
      const reqIds = /* @__PURE__ */ new Set();
      if (reqContent) {
        const reqPattern = /- \[(x| )\] \*\*(\w+-\d+)\*\*/g;
        let m;
        while ((m = reqPattern.exec(reqContent)) !== null) {
          reqIds.add(m[2]);
        }
      }
      const validTypes = /* @__PURE__ */ new Set(["api", "cli", "file", "behavior"]);
      const validPriorities = /* @__PURE__ */ new Set(["must-have", "nice-to-have"]);
      let totalAssertions = 0;
      for (const [reqId, data] of Object.entries(parsed)) {
        if (reqIds.size > 0 && !reqIds.has(reqId)) {
          issues.push({ reqId, issue: `Requirement ${reqId} not found in REQUIREMENTS.md`, severity: "warning" });
        }
        const assertions = data.assertions || [];
        totalAssertions += assertions.length;
        if (assertions.length < 2) {
          issues.push({ reqId, issue: `Only ${assertions.length} assertion(s), recommended 2-5`, severity: "info" });
        } else if (assertions.length > 5) {
          issues.push({ reqId, issue: `${assertions.length} assertions, recommended max 5`, severity: "info" });
        }
        for (let i = 0; i < assertions.length; i++) {
          const a = assertions[i];
          if (!a.assert || !a.assert.trim()) {
            issues.push({ reqId, issue: `Assertion ${i + 1} has empty assert field`, severity: "error" });
          }
          if (a.type && !validTypes.has(a.type)) {
            issues.push({ reqId, issue: `Assertion ${i + 1} has invalid type "${a.type}"`, severity: "error" });
          }
          if (a.priority && !validPriorities.has(a.priority)) {
            issues.push({ reqId, issue: `Assertion ${i + 1} has invalid priority "${a.priority}"`, severity: "error" });
          }
        }
      }
      const assertionReqCount = Object.keys(parsed).length;
      const totalReqs = reqIds.size || assertionReqCount;
      const coveragePercent = totalReqs > 0 ? Math.round(assertionReqCount / totalReqs * 100) : 0;
      const valid = issues.filter((i) => i.severity === "error").length === 0;
      const rawValue = valid ? "valid" : `${issues.length} issues found`;
      output({
        valid,
        issues,
        stats: {
          total_reqs: totalReqs,
          total_assertions: totalAssertions,
          reqs_with_assertions: assertionReqCount,
          coverage_percent: coveragePercent
        }
      }, raw, rawValue);
    }
    function parseAssertionsMd(content) {
      if (!content || typeof content !== "string") return {};
      const result = {};
      const sections = content.split(/^## /m).slice(1);
      for (const section of sections) {
        const lines = section.split("\n");
        const heading = lines[0].trim();
        const idMatch = heading.match(/^([A-Z][\w]+-\d+)\s*:\s*(.+)/);
        if (!idMatch) continue;
        const reqId = idMatch[1];
        const description = idMatch[2].trim();
        const assertions = [];
        let current = null;
        for (let i = 1; i < lines.length; i++) {
          const line = lines[i];
          const assertMatch = line.match(/^- assert:\s*"?([^"]*)"?\s*$/);
          if (assertMatch) {
            if (current) assertions.push(current);
            current = {
              assert: assertMatch[1].trim(),
              when: null,
              then: null,
              type: null,
              priority: "must-have"
            };
            continue;
          }
          if (current) {
            const fieldMatch = line.match(/^\s+(when|then|type|priority):\s*"?([^"]*)"?\s*$/);
            if (fieldMatch) {
              const key = fieldMatch[1];
              const val = fieldMatch[2].trim();
              if (key === "priority") {
                current.priority = val === "nice-to-have" ? "nice-to-have" : "must-have";
              } else {
                current[key] = val || null;
              }
            }
          }
        }
        if (current) assertions.push(current);
        result[reqId] = { description, assertions };
      }
      return result;
    }
    module2.exports = {
      cmdVerifyPlanStructure,
      cmdVerifyPhaseCompleteness,
      cmdVerifyReferences,
      cmdVerifyCommits,
      cmdVerifyArtifacts,
      cmdVerifyKeyLinks,
      cmdValidateConsistency,
      cmdValidateHealth,
      cmdAnalyzePlan,
      cmdVerifyDeliverables,
      cmdVerifyRequirements,
      cmdVerifyRegression,
      cmdVerifyPlanWave,
      cmdVerifyPlanDeps,
      cmdVerifyQuality,
      parseAssertionsMd,
      cmdAssertionsList,
      cmdAssertionsValidate
    };
  }
});

// src/commands/intent.js
var require_intent = __commonJS({
  "src/commands/intent.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    var { output, error, debugLog } = require_output();
    var { loadConfig } = require_config();
    var { execGit } = require_git();
    var { parseIntentMd, generateIntentMd, parsePlanIntent, getMilestoneInfo, normalizePhaseName } = require_helpers();
    var { extractFrontmatter } = require_frontmatter();
    var { banner, sectionHeader, formatTable, summaryLine, color, SYMBOLS, box, colorByPercent, actionHint } = require_format();
    function cmdIntentCreate(cwd, args, raw) {
      const planningDir = path.join(cwd, ".planning");
      if (!fs.existsSync(planningDir)) {
        error(".planning/ directory not found. Run project initialization first.");
      }
      const intentPath = path.join(planningDir, "INTENT.md");
      const force = args.includes("--force");
      if (fs.existsSync(intentPath) && !force) {
        error("INTENT.md already exists. Use --force to overwrite.");
      }
      const getFlag = (flag) => {
        const idx = args.indexOf(flag);
        if (idx === -1 || idx + 1 >= args.length) return null;
        return args[idx + 1];
      };
      const getMultiFlag = (flag) => {
        const idx = args.indexOf(flag);
        if (idx === -1) return [];
        const values = [];
        for (let i = idx + 1; i < args.length; i++) {
          if (args[i].startsWith("--")) break;
          values.push(args[i]);
        }
        return values;
      };
      const now = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      const data = {
        revision: 1,
        created: now,
        updated: now,
        objective: { statement: "", elaboration: "" },
        users: [],
        outcomes: [],
        criteria: [],
        constraints: { technical: [], business: [], timeline: [] },
        health: { quantitative: [], qualitative: "" },
        history: []
      };
      const objectiveText = getFlag("--objective");
      if (objectiveText) {
        const parts = objectiveText.split("\n");
        data.objective.statement = parts[0] || "";
        data.objective.elaboration = parts.slice(1).join("\n").trim();
      }
      const userArgs = getMultiFlag("--users");
      for (const u of userArgs) {
        data.users.push({ text: u });
      }
      const outcomeArgs = getMultiFlag("--outcomes");
      for (const o of outcomeArgs) {
        const match = o.match(/^(DO-\d+)\s+\[(P[123])\]:\s*(.+)$/);
        if (match) {
          data.outcomes.push({ id: match[1], priority: match[2], text: match[3] });
        }
      }
      const criteriaArgs = getMultiFlag("--criteria");
      for (const c of criteriaArgs) {
        const match = c.match(/^(SC-\d+):\s*(.+)$/);
        if (match) {
          data.criteria.push({ id: match[1], text: match[2] });
        }
      }
      const content = generateIntentMd(data);
      fs.writeFileSync(intentPath, content, "utf-8");
      const sections = ["objective", "users", "outcomes", "criteria", "constraints", "health"];
      const config = loadConfig(cwd);
      let commitHash = null;
      if (config.commit_docs) {
        execGit(cwd, ["add", ".planning/INTENT.md"]);
        const commitResult = execGit(cwd, ["commit", "-m", "docs(intent): create INTENT.md"]);
        if (commitResult.exitCode === 0) {
          const hashResult = execGit(cwd, ["rev-parse", "--short", "HEAD"]);
          commitHash = hashResult.exitCode === 0 ? hashResult.stdout : null;
        }
      }
      const result = {
        created: true,
        path: ".planning/INTENT.md",
        revision: 1,
        sections,
        commit: commitHash
      };
      output(result, raw, commitHash || "created");
    }
    var SECTION_ALIASES = ["objective", "users", "outcomes", "criteria", "constraints", "health", "history"];
    function makeFormatIntentShow(args, rawContent) {
      const sectionFilter = args.length > 0 && SECTION_ALIASES.includes(args[0]) ? args[0] : null;
      const fullFlag = args.includes("--full");
      return function formatIntentShow(data) {
        if (fullFlag) {
          return rawContent;
        }
        if (sectionFilter) {
          return renderSection(data, sectionFilter);
        }
        return renderCompactSummary(data);
      };
    }
    function cmdIntentShow(cwd, args, raw) {
      const planningDir = path.join(cwd, ".planning");
      const intentPath = path.join(planningDir, "INTENT.md");
      if (!fs.existsSync(intentPath)) {
        error("No INTENT.md found. Run `intent create` first.");
      }
      const content = fs.readFileSync(intentPath, "utf-8");
      const data = parseIntentMd(content);
      const sectionFilter = args.length > 0 && SECTION_ALIASES.includes(args[0]) ? args[0] : null;
      if (raw) {
        if (sectionFilter) {
          const sectionData = {};
          sectionData[sectionFilter] = data[sectionFilter];
          output(sectionData, false);
        } else {
          output(data, false);
        }
        return;
      }
      if (sectionFilter) {
        const sectionData = {};
        sectionData[sectionFilter] = data[sectionFilter];
        output(sectionData, { formatter: makeFormatIntentShow(args, content) });
      } else {
        output(data, { formatter: makeFormatIntentShow(args, content) });
      }
    }
    function renderCompactSummary(data) {
      const lines = [];
      const updated = data.updated || "unknown";
      lines.push(banner("Intent"));
      lines.push(`  Revision ${color.bold(String(data.revision || "?"))} (updated ${updated})`);
      lines.push("");
      const obj = data.objective.statement || "(not set)";
      const truncObj = obj.length > 80 ? obj.slice(0, 77) + "..." : obj;
      lines.push(`  Objective: ${truncObj}`);
      lines.push("");
      if (data.outcomes.length > 0) {
        const sorted = [...data.outcomes].sort((a, b) => {
          const pa = parseInt(a.priority.replace("P", ""), 10);
          const pb = parseInt(b.priority.replace("P", ""), 10);
          return pa - pb;
        });
        const counts = { P1: 0, P2: 0, P3: 0 };
        for (const o of sorted) {
          if (counts[o.priority] !== void 0) counts[o.priority]++;
        }
        const countParts = [];
        if (counts.P1 > 0) countParts.push(`${counts.P1}\xD7P1`);
        if (counts.P2 > 0) countParts.push(`${counts.P2}\xD7P2`);
        if (counts.P3 > 0) countParts.push(`${counts.P3}\xD7P3`);
        lines.push(sectionHeader("Outcomes"));
        lines.push(`  ${sorted.length} outcomes: ${countParts.join("  ")}`);
        for (const o of sorted) {
          const priorityLabel = colorPriority(o.priority);
          lines.push(`  ${priorityLabel}: ${o.id} ${SYMBOLS.dash} ${o.text}`);
        }
      } else {
        lines.push(sectionHeader("Outcomes"));
        lines.push("  none defined");
      }
      lines.push("");
      lines.push(`  Success Criteria: ${color.bold(String(data.criteria.length))} defined`);
      const techCount = data.constraints.technical.length;
      const bizCount = data.constraints.business.length;
      const timeCount = data.constraints.timeline.length;
      lines.push(`  Constraints: ${techCount} technical, ${bizCount} business, ${timeCount} timeline`);
      const quantCount = data.health.quantitative.length;
      const hasQual = data.health.qualitative && data.health.qualitative.trim() ? "defined" : "none";
      lines.push(`  Health Metrics: ${quantCount} quantitative, qualitative ${hasQual}`);
      lines.push(`  Target Users: ${data.users.length} audience${data.users.length !== 1 ? "s" : ""}`);
      if (data.history && data.history.length > 0) {
        const totalChanges = data.history.reduce((sum, e) => sum + e.changes.length, 0);
        const milestones = data.history.map((e) => e.milestone).join(", ");
        lines.push(`  Evolution: ${totalChanges} change${totalChanges !== 1 ? "s" : ""} across ${milestones}`);
      }
      lines.push("");
      lines.push(summaryLine(`Rev ${data.revision || "?"} ${SYMBOLS.dash} ${data.outcomes.length} outcomes, ${data.criteria.length} criteria`));
      return lines.join("\n") + "\n";
    }
    function renderSection(data, section) {
      const lines = [];
      switch (section) {
        case "objective":
          lines.push(sectionHeader("Objective"));
          lines.push("");
          lines.push(data.objective.statement || "(not set)");
          if (data.objective.elaboration) {
            lines.push("");
            lines.push(data.objective.elaboration);
          }
          break;
        case "users":
          lines.push(sectionHeader("Target Users"));
          lines.push("");
          if (data.users.length > 0) {
            for (const u of data.users) {
              lines.push(`- ${u.text}`);
            }
          } else {
            lines.push("(none defined)");
          }
          break;
        case "outcomes":
          lines.push(sectionHeader("Desired Outcomes"));
          lines.push("");
          if (data.outcomes.length > 0) {
            const sorted = [...data.outcomes].sort((a, b) => {
              const pa = parseInt(a.priority.replace("P", ""), 10);
              const pb = parseInt(b.priority.replace("P", ""), 10);
              return pa - pb;
            });
            for (const o of sorted) {
              const priorityLabel = colorPriority(o.priority);
              lines.push(`- ${o.id} [${priorityLabel}]: ${o.text}`);
            }
          } else {
            lines.push("(none defined)");
          }
          break;
        case "criteria":
          lines.push(sectionHeader("Success Criteria"));
          lines.push("");
          if (data.criteria.length > 0) {
            for (const c of data.criteria) {
              lines.push(`- ${c.id}: ${c.text}`);
            }
          } else {
            lines.push("(none defined)");
          }
          break;
        case "constraints":
          lines.push(sectionHeader("Constraints"));
          if (data.constraints.technical.length > 0) {
            lines.push("");
            lines.push(`  ${color.bold("Technical")}`);
            for (const c of data.constraints.technical) {
              lines.push(`  - ${c.id}: ${c.text}`);
            }
          }
          if (data.constraints.business.length > 0) {
            lines.push("");
            lines.push(`  ${color.bold("Business")}`);
            for (const c of data.constraints.business) {
              lines.push(`  - ${c.id}: ${c.text}`);
            }
          }
          if (data.constraints.timeline.length > 0) {
            lines.push("");
            lines.push(`  ${color.bold("Timeline")}`);
            for (const c of data.constraints.timeline) {
              lines.push(`  - ${c.id}: ${c.text}`);
            }
          }
          if (data.constraints.technical.length === 0 && data.constraints.business.length === 0 && data.constraints.timeline.length === 0) {
            lines.push("");
            lines.push("(none defined)");
          }
          break;
        case "health":
          lines.push(sectionHeader("Health Metrics"));
          if (data.health.quantitative.length > 0) {
            lines.push("");
            lines.push(`  ${color.bold("Quantitative")}`);
            for (const m of data.health.quantitative) {
              lines.push(`  - ${m.id}: ${m.text}`);
            }
          }
          if (data.health.qualitative && data.health.qualitative.trim()) {
            lines.push("");
            lines.push(`  ${color.bold("Qualitative")}`);
            lines.push(data.health.qualitative);
          }
          if (data.health.quantitative.length === 0 && (!data.health.qualitative || !data.health.qualitative.trim())) {
            lines.push("");
            lines.push("(none defined)");
          }
          break;
        case "history":
          lines.push(sectionHeader("Intent Evolution"));
          lines.push("");
          if (data.history && data.history.length > 0) {
            for (const entry of data.history) {
              lines.push(`  ${color.bold(entry.milestone)} ${SYMBOLS.dash} ${entry.date}`);
              for (const change of entry.changes) {
                lines.push(`  - ${color.bold(change.type)} ${change.target}: ${change.description}`);
                if (change.reason) {
                  lines.push(`    Reason: ${change.reason}`);
                }
              }
              lines.push("");
            }
          } else {
            lines.push("(no history recorded)");
          }
          break;
      }
      return lines.join("\n") + "\n";
    }
    function colorPriority(priority) {
      switch (priority) {
        case "P1":
          return color.red(priority);
        case "P2":
          return color.yellow(priority);
        case "P3":
          return color.dim(priority);
        default:
          return priority;
      }
    }
    function cmdIntentUpdate(cwd, args, raw) {
      const planningDir = path.join(cwd, ".planning");
      const intentPath = path.join(planningDir, "INTENT.md");
      if (!fs.existsSync(intentPath)) {
        error("No INTENT.md found. Run `intent create` first.");
      }
      const reasonIndex = args.indexOf("--reason");
      let reason = null;
      if (reasonIndex !== -1) {
        const reasonParts = [];
        for (let i = reasonIndex + 1; i < args.length; i++) {
          if (args[i].startsWith("--")) break;
          reasonParts.push(args[i]);
        }
        reason = reasonParts.join(" ") || null;
        args.splice(reasonIndex, reasonParts.length + 1);
      }
      const content = fs.readFileSync(intentPath, "utf-8");
      const data = parseIntentMd(content);
      const oldOutcomeIds = new Set((data.outcomes || []).map((o) => o.id));
      const oldCriteriaIds = new Set((data.criteria || []).map((c) => c.id));
      const oldConstraintIds = /* @__PURE__ */ new Set([
        ...(data.constraints.technical || []).map((c) => c.id),
        ...(data.constraints.business || []).map((c) => c.id),
        ...(data.constraints.timeline || []).map((c) => c.id)
      ]);
      const oldHealthIds = new Set((data.health.quantitative || []).map((m) => m.id));
      const oldUserTexts = new Set((data.users || []).map((u) => u.text));
      const oldObjective = data.objective ? data.objective.statement : "";
      const section = args.length > 0 && SECTION_ALIASES.includes(args[0]) ? args[0] : null;
      if (!section) {
        error("Usage: intent update <section> [--add|--remove|--set-priority|--value] [value]\nSections: objective, users, outcomes, criteria, constraints, health");
      }
      const getFlag = (flag) => {
        const idx = args.indexOf(flag);
        if (idx === -1 || idx + 1 >= args.length) return null;
        return args[idx + 1];
      };
      const addValue = getFlag("--add");
      const removeValue = getFlag("--remove");
      const setPriorityId = getFlag("--set-priority");
      const replaceValue = getFlag("--value");
      const priorityValue = getFlag("--priority");
      const typeValue = getFlag("--type");
      let operation = null;
      let operationDetail = null;
      let commitMessage = null;
      if (setPriorityId) {
        if (section !== "outcomes") {
          error("--set-priority is only valid for outcomes");
        }
        const idIdx = args.indexOf("--set-priority");
        const id = args[idIdx + 1];
        const newPriority = args[idIdx + 2];
        if (!id || !newPriority || !/^P[123]$/.test(newPriority)) {
          error("Usage: intent update outcomes --set-priority <DO-XX> <P1|P2|P3>");
        }
        const outcome = data.outcomes.find((o) => o.id === id);
        if (!outcome) {
          error(`Outcome ${id} not found`);
        }
        outcome.priority = newPriority;
        operation = "set-priority";
        operationDetail = { id, priority: newPriority };
        commitMessage = `docs(intent): set ${id} priority to ${newPriority}`;
      } else if (removeValue) {
        operation = "remove";
        if (section === "outcomes") {
          data.outcomes = data.outcomes.filter((o) => o.id !== removeValue);
          operationDetail = { id: removeValue };
          commitMessage = `docs(intent): remove ${removeValue} from outcomes`;
        } else if (section === "criteria") {
          data.criteria = data.criteria.filter((c) => c.id !== removeValue);
          operationDetail = { id: removeValue };
          commitMessage = `docs(intent): remove ${removeValue} from criteria`;
        } else if (section === "constraints") {
          for (const type of ["technical", "business", "timeline"]) {
            data.constraints[type] = data.constraints[type].filter((c) => c.id !== removeValue);
          }
          operationDetail = { id: removeValue };
          commitMessage = `docs(intent): remove ${removeValue} from constraints`;
        } else if (section === "health") {
          data.health.quantitative = data.health.quantitative.filter((m) => m.id !== removeValue);
          operationDetail = { id: removeValue };
          commitMessage = `docs(intent): remove ${removeValue} from health`;
        } else if (section === "users") {
          data.users = data.users.filter((u) => u.text !== removeValue);
          operationDetail = { text: removeValue };
          commitMessage = `docs(intent): remove user from target users`;
        } else {
          error(`--remove is not supported for section: ${section}`);
        }
      } else if (addValue) {
        operation = "add";
        if (section === "outcomes") {
          const nextId = getNextId(data.outcomes, "DO");
          const priority = priorityValue || "P2";
          data.outcomes.push({ id: nextId, priority, text: addValue });
          operationDetail = { id: nextId, priority };
          commitMessage = `docs(intent): add ${nextId} to outcomes`;
        } else if (section === "criteria") {
          const nextId = getNextId(data.criteria, "SC");
          data.criteria.push({ id: nextId, text: addValue });
          operationDetail = { id: nextId };
          commitMessage = `docs(intent): add ${nextId} to criteria`;
        } else if (section === "constraints") {
          const type = typeValue || "technical";
          if (!["technical", "business", "timeline"].includes(type)) {
            error("--type must be one of: technical, business, timeline");
          }
          const allConstraints = [
            ...data.constraints.technical,
            ...data.constraints.business,
            ...data.constraints.timeline
          ];
          const nextId = getNextId(allConstraints, "C");
          data.constraints[type].push({ id: nextId, text: addValue });
          operationDetail = { id: nextId, type };
          commitMessage = `docs(intent): add ${nextId} to constraints (${type})`;
        } else if (section === "health") {
          const nextId = getNextId(data.health.quantitative, "HM");
          data.health.quantitative.push({ id: nextId, text: addValue });
          operationDetail = { id: nextId };
          commitMessage = `docs(intent): add ${nextId} to health metrics`;
        } else if (section === "users") {
          data.users.push({ text: addValue });
          operationDetail = { text: addValue };
          commitMessage = `docs(intent): add user to target users`;
        } else {
          error(`--add is not supported for section: ${section}`);
        }
      } else if (replaceValue) {
        operation = "replace";
        if (section === "objective") {
          const parts = replaceValue.split("\n");
          data.objective.statement = parts[0] || "";
          data.objective.elaboration = parts.slice(1).join("\n").trim();
        } else if (section === "users") {
          data.users = replaceValue.split("\n").filter((l) => l.trim()).map((l) => ({ text: l.trim() }));
        } else {
          error(`--value for section "${section}" is not supported. Use --add/--remove for list sections.`);
        }
        operationDetail = { section };
        commitMessage = `docs(intent): update ${section}`;
      } else {
        error("No operation specified. Use --add, --remove, --set-priority, or --value");
      }
      data.revision = (data.revision || 0) + 1;
      data.updated = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      const historyChanges = [];
      const defaultReason = reason || `Updated via intent update ${section}`;
      if (section === "outcomes") {
        const newOutcomeIds = new Set((data.outcomes || []).map((o) => o.id));
        for (const o of data.outcomes || []) {
          if (!oldOutcomeIds.has(o.id)) {
            historyChanges.push({ type: "Added", target: `${o.id} [${o.priority}]`, description: o.text, reason: defaultReason });
          }
        }
        for (const id of oldOutcomeIds) {
          if (!newOutcomeIds.has(id)) {
            historyChanges.push({ type: "Removed", target: id, description: `Removed from outcomes`, reason: defaultReason });
          }
        }
        if (operation === "set-priority" && operationDetail) {
          historyChanges.push({ type: "Modified", target: operationDetail.id, description: `Priority changed to ${operationDetail.priority}`, reason: defaultReason });
        }
      } else if (section === "criteria") {
        const newCriteriaIds = new Set((data.criteria || []).map((c) => c.id));
        for (const c of data.criteria || []) {
          if (!oldCriteriaIds.has(c.id)) {
            historyChanges.push({ type: "Added", target: c.id, description: c.text, reason: defaultReason });
          }
        }
        for (const id of oldCriteriaIds) {
          if (!newCriteriaIds.has(id)) {
            historyChanges.push({ type: "Removed", target: id, description: `Removed from criteria`, reason: defaultReason });
          }
        }
      } else if (section === "constraints") {
        const allNewConstraints = [
          ...data.constraints.technical || [],
          ...data.constraints.business || [],
          ...data.constraints.timeline || []
        ];
        const newConstraintIds = new Set(allNewConstraints.map((c) => c.id));
        for (const c of allNewConstraints) {
          if (!oldConstraintIds.has(c.id)) {
            historyChanges.push({ type: "Added", target: c.id, description: c.text, reason: defaultReason });
          }
        }
        for (const id of oldConstraintIds) {
          if (!newConstraintIds.has(id)) {
            historyChanges.push({ type: "Removed", target: id, description: `Removed from constraints`, reason: defaultReason });
          }
        }
      } else if (section === "health") {
        const newHealthIds = new Set((data.health.quantitative || []).map((m) => m.id));
        for (const m of data.health.quantitative || []) {
          if (!oldHealthIds.has(m.id)) {
            historyChanges.push({ type: "Added", target: m.id, description: m.text, reason: defaultReason });
          }
        }
        for (const id of oldHealthIds) {
          if (!newHealthIds.has(id)) {
            historyChanges.push({ type: "Removed", target: id, description: `Removed from health metrics`, reason: defaultReason });
          }
        }
      } else if (section === "users") {
        const newUserTexts = new Set((data.users || []).map((u) => u.text));
        for (const u of data.users || []) {
          if (!oldUserTexts.has(u.text)) {
            historyChanges.push({ type: "Added", target: "user", description: u.text, reason: defaultReason });
          }
        }
        for (const text of oldUserTexts) {
          if (!newUserTexts.has(text)) {
            historyChanges.push({ type: "Removed", target: "user", description: text, reason: defaultReason });
          }
        }
      } else if (section === "objective") {
        const newObjective = data.objective ? data.objective.statement : "";
        if (newObjective !== oldObjective) {
          historyChanges.push({ type: "Modified", target: "objective", description: newObjective, reason: defaultReason });
        }
      }
      if (historyChanges.length > 0) {
        if (!data.history) data.history = [];
        const milestone = getMilestoneInfo(cwd);
        const milestoneVersion = milestone.version || "unknown";
        const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
        let entry = data.history.find((e) => e.milestone === milestoneVersion && e.date === today);
        if (entry) {
          entry.changes.push(...historyChanges);
        } else {
          entry = { milestone: milestoneVersion, date: today, changes: historyChanges };
          data.history.unshift(entry);
        }
      }
      const newContent = generateIntentMd(data);
      fs.writeFileSync(intentPath, newContent, "utf-8");
      const config = loadConfig(cwd);
      let commitHash = null;
      if (config.commit_docs && commitMessage) {
        execGit(cwd, ["add", ".planning/INTENT.md"]);
        const commitResult = execGit(cwd, ["commit", "-m", commitMessage]);
        if (commitResult.exitCode === 0) {
          const hashResult = execGit(cwd, ["rev-parse", "--short", "HEAD"]);
          commitHash = hashResult.exitCode === 0 ? hashResult.stdout : null;
        }
      }
      const result = {
        updated: true,
        section,
        operation,
        ...operationDetail,
        revision: data.revision,
        commit: commitHash
      };
      output(result, raw);
    }
    function getNextId(items, prefix) {
      let maxNum = 0;
      const pattern = new RegExp(`^${prefix}-(\\d+)$`);
      for (const item of items) {
        const match = item.id.match(pattern);
        if (match) {
          const num = parseInt(match[1], 10);
          if (num > maxNum) maxNum = num;
        }
      }
      const nextNum = (maxNum + 1).toString().padStart(2, "0");
      return `${prefix}-${nextNum}`;
    }
    function formatIntentValidate(result) {
      const lines = [];
      lines.push(banner("Intent Validate"));
      lines.push("");
      if (result.valid) {
        lines.push(box("Intent is valid", "success"));
      } else {
        lines.push(box(`${result.issues.length} issue${result.issues.length !== 1 ? "s" : ""} found`, "error"));
      }
      lines.push("");
      lines.push(sectionHeader("Sections"));
      const sections = result.sections;
      const sym = (v) => v ? color.green(SYMBOLS.check) : color.red(SYMBOLS.cross);
      lines.push(`  ${sym(sections.objective.valid)} Objective: ${sections.objective.message || "defined"}`);
      if (sections.users.valid) {
        lines.push(`  ${sym(true)} Target Users: ${sections.users.count} audience${sections.users.count !== 1 ? "s" : ""}`);
      } else {
        lines.push(`  ${sym(false)} Target Users: missing or empty`);
      }
      if (sections.outcomes.valid) {
        lines.push(`  ${sym(true)} Outcomes: ${sections.outcomes.count} items, IDs valid`);
      } else if (sections.outcomes.count > 0) {
        lines.push(`  ${sym(false)} Outcomes: ${(sections.outcomes.issues || []).join("; ")}`);
      } else {
        lines.push(`  ${sym(false)} Outcomes: no items defined (minimum 1)`);
      }
      if (sections.criteria.valid) {
        lines.push(`  ${sym(true)} Success Criteria: ${sections.criteria.count} items, IDs valid`);
      } else if (sections.criteria.count > 0) {
        lines.push(`  ${sym(false)} Success Criteria: ${(sections.criteria.issues || []).join("; ")}`);
      } else {
        lines.push(`  ${sym(false)} Success Criteria: no items defined (minimum 1)`);
      }
      if (sections.constraints.valid) {
        const subCount = (sections.constraints.sub_sections || []).length;
        lines.push(`  ${sym(true)} Constraints: ${subCount} sub-section${subCount !== 1 ? "s" : ""} (${(sections.constraints.sub_sections || []).join(", ")})`);
      } else {
        lines.push(`  ${sym(false)} Constraints: ${(sections.constraints.issues || []).join("; ")}`);
      }
      if (sections.health.valid) {
        lines.push(`  ${sym(true)} Health Metrics: quantitative (${sections.health.quantitative_count} items), qualitative ${sections.health.qualitative ? "defined" : "none"}`);
      } else {
        lines.push(`  ${sym(false)} Health Metrics: ${(sections.health.issues || []).join("; ")}`);
      }
      if (result.revision && Number.isInteger(result.revision) && result.revision > 0) {
        lines.push(`  ${sym(true)} Revision: ${result.revision}`);
      } else {
        lines.push(`  ${sym(false)} Revision: missing or invalid`);
      }
      if (sections.history) {
        if (sections.history.valid) {
          lines.push(`  ${sym(true)} History: ${sections.history.count} milestone${sections.history.count !== 1 ? "s" : ""} recorded`);
        } else {
          lines.push(`  ${color.yellow(SYMBOLS.warning)} History: ${(sections.history.issues || []).join("; ")}`);
        }
      }
      if (result.issues.length > 0) {
        lines.push("");
        lines.push(sectionHeader("Issues"));
        for (const iss of result.issues) {
          lines.push(`  ${color.red(SYMBOLS.cross)} ${iss.message}`);
        }
      }
      lines.push("");
      if (result.valid) {
        const warningNote = result.warnings && result.warnings.length > 0 ? ` (${result.warnings.length} advisory warning${result.warnings.length !== 1 ? "s" : ""})` : "";
        lines.push(summaryLine(`${SYMBOLS.check} Intent valid${warningNote}`));
      } else {
        lines.push(summaryLine(`${result.issues.length} issue${result.issues.length !== 1 ? "s" : ""}`));
      }
      return lines.join("\n");
    }
    function cmdIntentValidate(cwd, args, raw) {
      const planningDir = path.join(cwd, ".planning");
      const intentPath = path.join(planningDir, "INTENT.md");
      if (!fs.existsSync(intentPath)) {
        error("No INTENT.md found. Run `intent create` first.");
      }
      const content = fs.readFileSync(intentPath, "utf-8");
      const data = parseIntentMd(content);
      const issues = [];
      const sections = {};
      if (data.objective && data.objective.statement && data.objective.statement.trim()) {
        sections.objective = { valid: true, message: "defined" };
      } else {
        sections.objective = { valid: false, message: "missing or empty" };
        issues.push({ section: "objective", type: "missing", message: "Objective: missing or empty" });
      }
      if (data.users && data.users.length > 0) {
        sections.users = { valid: true, count: data.users.length };
      } else {
        sections.users = { valid: false, count: 0, issues: ["missing or empty"] };
        issues.push({ section: "users", type: "missing", message: "Target Users: missing or empty" });
      }
      if (data.outcomes && data.outcomes.length > 0) {
        const outcomeIssues = [];
        const seenIds = /* @__PURE__ */ new Set();
        for (const o of data.outcomes) {
          if (!/^DO-\d+$/.test(o.id)) {
            outcomeIssues.push(`${o.id} has invalid format`);
          }
          if (seenIds.has(o.id)) {
            outcomeIssues.push(`duplicate ID ${o.id}`);
          }
          seenIds.add(o.id);
        }
        if (outcomeIssues.length > 0) {
          sections.outcomes = { valid: false, count: data.outcomes.length, issues: outcomeIssues };
          for (const iss of outcomeIssues) {
            issues.push({ section: "outcomes", type: "format", message: `Outcomes: ${iss}` });
          }
        } else {
          sections.outcomes = { valid: true, count: data.outcomes.length };
        }
      } else {
        sections.outcomes = { valid: false, count: 0, issues: ["no items defined (minimum 1)"] };
        issues.push({ section: "outcomes", type: "missing", message: "Outcomes: no items defined (minimum 1)" });
      }
      if (data.criteria && data.criteria.length > 0) {
        const criteriaIssues = [];
        const seenIds = /* @__PURE__ */ new Set();
        for (const c of data.criteria) {
          if (!/^SC-\d+$/.test(c.id)) {
            criteriaIssues.push(`${c.id} has invalid format`);
          }
          if (seenIds.has(c.id)) {
            criteriaIssues.push(`duplicate ID ${c.id}`);
          }
          seenIds.add(c.id);
        }
        if (criteriaIssues.length > 0) {
          sections.criteria = { valid: false, count: data.criteria.length, issues: criteriaIssues };
          for (const iss of criteriaIssues) {
            issues.push({ section: "criteria", type: "format", message: `Criteria: ${iss}` });
          }
        } else {
          sections.criteria = { valid: true, count: data.criteria.length };
        }
      } else {
        sections.criteria = { valid: false, count: 0, issues: ["no items defined (minimum 1)"] };
        issues.push({ section: "criteria", type: "missing", message: "Success Criteria: no items defined (minimum 1)" });
      }
      const techCount = data.constraints ? data.constraints.technical.length : 0;
      const bizCount = data.constraints ? data.constraints.business.length : 0;
      const timeCount = data.constraints ? data.constraints.timeline.length : 0;
      const totalConstraints = techCount + bizCount + timeCount;
      if (totalConstraints > 0) {
        const constraintIssues = [];
        const subSections = [];
        if (techCount > 0) subSections.push("technical");
        if (bizCount > 0) subSections.push("business");
        if (timeCount > 0) subSections.push("timeline");
        const seenIds = /* @__PURE__ */ new Set();
        const allConstraints = [
          ...data.constraints.technical || [],
          ...data.constraints.business || [],
          ...data.constraints.timeline || []
        ];
        for (const c of allConstraints) {
          if (!/^C-\d+$/.test(c.id)) {
            constraintIssues.push(`${c.id} has invalid format`);
          }
          if (seenIds.has(c.id)) {
            constraintIssues.push(`duplicate ID ${c.id}`);
          }
          seenIds.add(c.id);
        }
        if (constraintIssues.length > 0) {
          sections.constraints = { valid: false, count: totalConstraints, sub_sections: subSections, issues: constraintIssues };
          for (const iss of constraintIssues) {
            issues.push({ section: "constraints", type: "format", message: `Constraints: ${iss}` });
          }
        } else {
          sections.constraints = { valid: true, count: totalConstraints, sub_sections: subSections };
        }
      } else {
        const constraintsRaw = content.match(/<constraints>([\s\S]*?)<\/constraints>/);
        const rawText = constraintsRaw ? constraintsRaw[1] : "";
        const hasTechHeader = /^###\s*Technical/im.test(rawText);
        const hasBizHeader = /^###\s*Business/im.test(rawText);
        const hasTimeHeader = /^###\s*Timeline/im.test(rawText);
        if (hasTechHeader || hasBizHeader || hasTimeHeader) {
          const subSections = [];
          if (hasTechHeader) subSections.push("technical");
          if (hasBizHeader) subSections.push("business");
          if (hasTimeHeader) subSections.push("timeline");
          sections.constraints = { valid: true, count: 0, sub_sections: subSections };
        } else {
          sections.constraints = { valid: false, count: 0, issues: ["missing sub-sections (need at least ### Technical, ### Business, or ### Timeline)"] };
          issues.push({ section: "constraints", type: "missing", message: "Constraints: missing sub-sections" });
        }
      }
      const quantCount = data.health ? data.health.quantitative.length : 0;
      const hasQual = data.health && data.health.qualitative && data.health.qualitative.trim();
      const healthRaw = content.match(/<health>([\s\S]*?)<\/health>/);
      const healthText = healthRaw ? healthRaw[1] : "";
      const hasQuantHeader = /^###\s*Quantitative/im.test(healthText);
      const hasQualHeader = /^###\s*Qualitative/im.test(healthText);
      if (hasQuantHeader || hasQualHeader) {
        const healthIssues = [];
        if (quantCount > 0) {
          const seenIds = /* @__PURE__ */ new Set();
          for (const m of data.health.quantitative) {
            if (!/^HM-\d+$/.test(m.id)) {
              healthIssues.push(`${m.id} has invalid format`);
            }
            if (seenIds.has(m.id)) {
              healthIssues.push(`duplicate ID ${m.id}`);
            }
            seenIds.add(m.id);
          }
        }
        if (!hasQuantHeader) {
          healthIssues.push("missing ### Quantitative");
        }
        if (!hasQualHeader) {
          healthIssues.push("missing ### Qualitative");
        }
        if (healthIssues.length > 0) {
          sections.health = { valid: false, quantitative_count: quantCount, qualitative: !!hasQual, issues: healthIssues };
          for (const iss of healthIssues) {
            issues.push({ section: "health", type: "format", message: `Health: ${iss}` });
          }
        } else {
          sections.health = { valid: true, quantitative_count: quantCount, qualitative: !!hasQual };
        }
      } else {
        sections.health = { valid: false, quantitative_count: 0, qualitative: false, issues: ["missing or empty"] };
        issues.push({ section: "health", type: "missing", message: "Health Metrics: missing or empty" });
      }
      const warnings = [];
      if (data.history && data.history.length > 0) {
        const historyWarnings = [];
        for (const entry of data.history) {
          if (!entry.milestone) {
            historyWarnings.push("History entry missing milestone");
          }
          if (!entry.date || !/^\d{4}-\d{2}-\d{2}$/.test(entry.date)) {
            historyWarnings.push(`History entry has invalid date: ${entry.date || "(empty)"}`);
          }
          for (const change of entry.changes || []) {
            if (!change.type || !["Added", "Modified", "Removed"].includes(change.type)) {
              historyWarnings.push(`History change has invalid type: ${change.type || "(empty)"}`);
            }
            if (!change.target) {
              historyWarnings.push("History change missing target");
            }
          }
        }
        if (historyWarnings.length > 0) {
          sections.history = { valid: false, count: data.history.length, issues: historyWarnings };
          for (const warn of historyWarnings) {
            warnings.push({ section: "history", type: "warning", message: `History: ${warn}` });
          }
        } else {
          sections.history = { valid: true, count: data.history.length };
        }
      }
      const revision = data.revision;
      const revisionValid = revision !== null && Number.isInteger(revision) && revision > 0;
      const valid = issues.length === 0 && revisionValid;
      if (!revisionValid) {
        issues.push({ section: "revision", type: "missing", message: "Revision: missing or invalid" });
      }
      const result = {
        valid,
        issues,
        warnings,
        sections,
        revision: revision || null
      };
      if (!valid) process.exitCode = 1;
      output(result, { formatter: formatIntentValidate });
    }
    function cmdIntentTrace(cwd, args, raw) {
      const planningDir = path.join(cwd, ".planning");
      const intentPath = path.join(planningDir, "INTENT.md");
      if (!fs.existsSync(intentPath)) {
        error("No INTENT.md found. Run `intent create` first.");
      }
      const intentContent = fs.readFileSync(intentPath, "utf-8");
      const intentData = parseIntentMd(intentContent);
      if (!intentData.outcomes || intentData.outcomes.length === 0) {
        error("INTENT.md has no desired outcomes defined.");
      }
      const gapsOnly = args.includes("--gaps");
      const milestone = getMilestoneInfo(cwd);
      const phaseRange = milestone.phaseRange;
      const phasesDir = path.join(planningDir, "phases");
      const plans = [];
      if (fs.existsSync(phasesDir)) {
        try {
          const entries = fs.readdirSync(phasesDir, { withFileTypes: true });
          const phaseDirs = entries.filter((e) => e.isDirectory()).map((e) => e.name).sort();
          for (const dir of phaseDirs) {
            const phaseNumMatch = dir.match(/^(\d+)/);
            if (phaseNumMatch && phaseRange) {
              const phaseNum = parseInt(phaseNumMatch[1], 10);
              if (phaseNum < phaseRange.start || phaseNum > phaseRange.end) continue;
            }
            const phaseDir = path.join(phasesDir, dir);
            const files = fs.readdirSync(phaseDir);
            const planFiles = files.filter((f) => f.endsWith("-PLAN.md") || f === "PLAN.md").sort();
            for (const planFile of planFiles) {
              const planPath = path.join(phaseDir, planFile);
              const planContent = fs.readFileSync(planPath, "utf-8");
              const fm = extractFrontmatter(planContent);
              const intentInfo = parsePlanIntent(planContent);
              const planPhase = fm.phase || dir;
              const planNum = fm.plan || planFile.replace(/-PLAN\.md$/, "").split("-").pop() || "01";
              const paddedPhase = normalizePhaseName(planPhase);
              const paddedPlan = String(planNum).padStart(2, "0");
              const planId = `${paddedPhase}-${paddedPlan}`;
              plans.push({
                plan_id: planId,
                phase: planPhase,
                outcome_ids: intentInfo ? intentInfo.outcome_ids : [],
                rationale: intentInfo ? intentInfo.rationale : ""
              });
            }
          }
        } catch (e) {
          debugLog("intent.trace", "scan phase dirs failed", e);
        }
      }
      const matrix = [];
      const gaps = [];
      let coveredCount = 0;
      for (const outcome of intentData.outcomes) {
        const tracingPlans = plans.filter((p) => p.outcome_ids.includes(outcome.id)).map((p) => p.plan_id);
        const entry = {
          outcome_id: outcome.id,
          priority: outcome.priority,
          text: outcome.text,
          plans: tracingPlans
        };
        matrix.push(entry);
        if (tracingPlans.length === 0) {
          gaps.push({
            outcome_id: outcome.id,
            priority: outcome.priority,
            text: outcome.text
          });
        } else {
          coveredCount++;
        }
      }
      const totalOutcomes = intentData.outcomes.length;
      const coveragePercent = totalOutcomes > 0 ? Math.round(coveredCount / totalOutcomes * 100) : 0;
      const priorityOrder = (a, b) => {
        const pa = parseInt((a.priority || "P9").replace("P", ""), 10);
        const pb = parseInt((b.priority || "P9").replace("P", ""), 10);
        return pa - pb;
      };
      const sortedMatrix = [
        ...matrix.filter((m) => m.plans.length === 0).sort(priorityOrder),
        ...matrix.filter((m) => m.plans.length > 0).sort(priorityOrder)
      ];
      const result = {
        total_outcomes: totalOutcomes,
        covered_outcomes: coveredCount,
        coverage_percent: coveragePercent,
        matrix: gapsOnly ? gaps.sort(priorityOrder) : sortedMatrix,
        gaps: gaps.sort(priorityOrder),
        plans: plans.map((p) => ({
          plan_id: p.plan_id,
          phase: p.phase,
          outcome_ids: p.outcome_ids
        }))
      };
      if (raw) {
        output(result, false);
        return;
      }
      const lines = [];
      lines.push("Intent Traceability \u2014 .planning/INTENT.md");
      lines.push(`Coverage: ${coveredCount}/${totalOutcomes} outcomes (${coveragePercent}%)`);
      lines.push("");
      if (gapsOnly) {
        if (gaps.length === 0) {
          lines.push("  No gaps \u2014 all outcomes have at least one plan tracing to them.");
        } else {
          for (const gap of gaps.sort(priorityOrder)) {
            lines.push(`  \u2717 ${gap.outcome_id} [${gap.priority}]: ${gap.text} \u2192 (no plans)`);
          }
        }
      } else {
        for (const entry of sortedMatrix) {
          if (entry.plans.length === 0) {
            lines.push(`  \u2717 ${entry.outcome_id} [${entry.priority}]: ${entry.text} \u2192 (no plans)`);
          } else {
            lines.push(`  \u2713 ${entry.outcome_id} [${entry.priority}]: ${entry.text} \u2192 ${entry.plans.join(", ")}`);
          }
        }
      }
      if (gaps.length > 0) {
        lines.push("");
        const gapCounts = {};
        for (const g of gaps) {
          gapCounts[g.priority] = (gapCounts[g.priority] || 0) + 1;
        }
        const gapParts = Object.entries(gapCounts).sort(([a], [b]) => a.localeCompare(b)).map(([p, c]) => `${c}\xD7${p}`);
        lines.push(`Gaps: ${gaps.length} outcomes uncovered (${gapParts.join(", ")})`);
      }
      output(null, true, lines.join("\n") + "\n");
    }
    function calculateDriftScore(data) {
      const { outcomes, plans, signalData } = data;
      const totalOutcomes = outcomes.length;
      const totalPlans = plans.length;
      let coverageGap = 0;
      if (totalOutcomes > 0) {
        let weightedGapSum = 0;
        let weightedTotal = 0;
        for (const o of outcomes) {
          const weight = o.priority === "P1" ? 3 : o.priority === "P2" ? 2 : 1;
          weightedTotal += weight;
          if (!signalData.coveredOutcomeIds.has(o.id)) {
            weightedGapSum += weight;
          }
        }
        coverageGap = weightedTotal > 0 ? weightedGapSum / weightedTotal * 40 : 0;
      }
      let objectiveMismatch = 0;
      if (totalPlans > 0) {
        const untracedCount = signalData.untracedPlans.length;
        objectiveMismatch = untracedCount / totalPlans * 25;
      }
      let featureCreep = 0;
      const totalRefs = signalData.totalOutcomeRefs;
      if (totalRefs > 0) {
        featureCreep = signalData.invalidRefs.length / totalRefs * 15;
      }
      const priorityInversion = signalData.inversions.length > 0 ? 20 : 0;
      const score = Math.round(Math.min(100, Math.max(0, coverageGap + objectiveMismatch + featureCreep + priorityInversion)));
      return {
        score,
        components: {
          coverage_gap: Math.round(coverageGap * 10) / 10,
          objective_mismatch: Math.round(objectiveMismatch * 10) / 10,
          feature_creep: Math.round(featureCreep * 10) / 10,
          priority_inversion: Math.round(priorityInversion * 10) / 10
        }
      };
    }
    function getAlignmentLabel(score) {
      if (score <= 15) return "excellent";
      if (score <= 35) return "good";
      if (score <= 60) return "moderate";
      return "poor";
    }
    function getIntentDriftData(cwd) {
      const planningDir = path.join(cwd, ".planning");
      const intentPath = path.join(planningDir, "INTENT.md");
      if (!fs.existsSync(intentPath)) return null;
      const intentContent = fs.readFileSync(intentPath, "utf-8");
      const intentData = parseIntentMd(intentContent);
      if (!intentData.outcomes || intentData.outcomes.length === 0) return null;
      const outcomes = intentData.outcomes;
      const validOutcomeIds = new Set(outcomes.map((o) => o.id));
      const milestone = getMilestoneInfo(cwd);
      const phaseRange = milestone.phaseRange;
      const phasesDir = path.join(planningDir, "phases");
      const plans = [];
      if (fs.existsSync(phasesDir)) {
        try {
          const entries = fs.readdirSync(phasesDir, { withFileTypes: true });
          const phaseDirs = entries.filter((e) => e.isDirectory()).map((e) => e.name).sort();
          for (const dir of phaseDirs) {
            const phaseNumMatch = dir.match(/^(\d+)/);
            if (phaseNumMatch && phaseRange) {
              const phaseNum = parseInt(phaseNumMatch[1], 10);
              if (phaseNum < phaseRange.start || phaseNum > phaseRange.end) continue;
            }
            const phaseDir = path.join(phasesDir, dir);
            const files = fs.readdirSync(phaseDir);
            const planFiles = files.filter((f) => f.endsWith("-PLAN.md") || f === "PLAN.md").sort();
            for (const planFile of planFiles) {
              const planPath = path.join(phaseDir, planFile);
              const planContent = fs.readFileSync(planPath, "utf-8");
              const fm = extractFrontmatter(planContent);
              const intentInfo = parsePlanIntent(planContent);
              const planPhase = fm.phase || dir;
              const planNum = fm.plan || planFile.replace(/-PLAN\.md$/, "").split("-").pop() || "01";
              const paddedPhase = normalizePhaseName(planPhase);
              const paddedPlan = String(planNum).padStart(2, "0");
              const planId = `${paddedPhase}-${paddedPlan}`;
              plans.push({
                plan_id: planId,
                phase: planPhase,
                outcome_ids: intentInfo ? intentInfo.outcome_ids : []
              });
            }
          }
        } catch (e) {
          debugLog("intent.drift", "scan phase dirs failed", e);
        }
      }
      const coveredOutcomeIds = /* @__PURE__ */ new Set();
      for (const plan of plans) {
        for (const id of plan.outcome_ids) {
          if (validOutcomeIds.has(id)) {
            coveredOutcomeIds.add(id);
          }
        }
      }
      const coverageGapDetails = outcomes.filter((o) => !coveredOutcomeIds.has(o.id)).sort((a, b) => {
        const pa = parseInt(a.priority.replace("P", ""), 10);
        const pb = parseInt(b.priority.replace("P", ""), 10);
        return pa - pb;
      }).map((o) => ({ outcome_id: o.id, priority: o.priority, text: o.text }));
      const untracedPlans = plans.filter((p) => p.outcome_ids.length === 0).map((p) => p.plan_id);
      const invalidRefs = [];
      let totalOutcomeRefs = 0;
      for (const plan of plans) {
        for (const id of plan.outcome_ids) {
          totalOutcomeRefs++;
          if (!validOutcomeIds.has(id)) {
            invalidRefs.push({ plan_id: plan.plan_id, invalid_id: id });
          }
        }
      }
      const inversions = [];
      const uncoveredP1 = outcomes.filter((o) => o.priority === "P1" && !coveredOutcomeIds.has(o.id));
      const coveredP2P3 = outcomes.filter(
        (o) => (o.priority === "P2" || o.priority === "P3") && coveredOutcomeIds.has(o.id)
      );
      for (const p1 of uncoveredP1) {
        for (const lower of coveredP2P3) {
          const lowerPlanCount = plans.filter((p) => p.outcome_ids.includes(lower.id)).length;
          inversions.push({
            uncovered: { outcome_id: p1.id, priority: p1.priority, text: p1.text },
            covered: { outcome_id: lower.id, priority: lower.priority, text: lower.text, plan_count: lowerPlanCount }
          });
        }
      }
      const signalData = {
        coveredOutcomeIds,
        untracedPlans,
        invalidRefs,
        totalOutcomeRefs,
        inversions
      };
      const { score, components } = calculateDriftScore({ outcomes, plans, signalData });
      const alignment = getAlignmentLabel(score);
      return {
        drift_score: score,
        alignment,
        signals: {
          coverage_gap: {
            score: components.coverage_gap,
            details: coverageGapDetails
          },
          objective_mismatch: {
            score: components.objective_mismatch,
            plans: untracedPlans
          },
          feature_creep: {
            score: components.feature_creep,
            invalid_refs: invalidRefs
          },
          priority_inversion: {
            score: components.priority_inversion,
            inversions: inversions.map((inv) => ({
              uncovered_id: inv.uncovered.outcome_id,
              uncovered_priority: inv.uncovered.priority,
              covered_id: inv.covered.outcome_id,
              covered_priority: inv.covered.priority,
              covered_plan_count: inv.covered.plan_count
            }))
          }
        },
        total_outcomes: outcomes.length,
        covered_outcomes: coveredOutcomeIds.size,
        total_plans: plans.length,
        traced_plans: plans.length - untracedPlans.length
      };
    }
    function formatIntentDrift(data) {
      const lines = [];
      lines.push(banner("Intent Drift"));
      let scoreColorFn = color.green;
      if (data.alignment === "moderate") scoreColorFn = color.yellow;
      else if (data.alignment === "poor") scoreColorFn = color.red;
      const scoreLabel = scoreColorFn(`${data.drift_score}/100 (${data.alignment})`);
      lines.push(`  Score: ${scoreLabel}`);
      lines.push("");
      const cg = data.signals.coverage_gap;
      lines.push(sectionHeader(`Coverage Gaps (${cg.score} pts)`));
      if (cg.details.length === 0) {
        lines.push(`  ${color.green(SYMBOLS.check)} All outcomes have plans`);
      } else {
        for (const gap of cg.details) {
          lines.push(`  ${color.red(SYMBOLS.cross)} ${gap.outcome_id} [${colorPriority(gap.priority)}]: ${gap.text} ${SYMBOLS.dash} no plans`);
        }
      }
      lines.push("");
      const om = data.signals.objective_mismatch;
      lines.push(sectionHeader(`Objective Mismatch (${om.score} pts)`));
      if (om.plans.length === 0) {
        lines.push(`  ${color.green(SYMBOLS.check)} All plans have intent sections`);
      } else {
        for (const planId of om.plans) {
          lines.push(`  ${color.red(SYMBOLS.cross)} ${planId}: no intent section in frontmatter`);
        }
      }
      lines.push("");
      const fc = data.signals.feature_creep;
      lines.push(sectionHeader(`Feature Creep (${fc.score} pts)`));
      if (fc.invalid_refs.length === 0) {
        lines.push(`  ${color.green(SYMBOLS.check)} No invalid outcome references`);
      } else {
        for (const ref of fc.invalid_refs) {
          lines.push(`  ${color.red(SYMBOLS.cross)} ${ref.plan_id}: references non-existent ${ref.invalid_id}`);
        }
      }
      lines.push("");
      const pi = data.signals.priority_inversion;
      lines.push(sectionHeader(`Priority Inversion (${pi.score} pts)`));
      if (pi.inversions.length === 0) {
        lines.push(`  ${color.green(SYMBOLS.check)} No priority inversions`);
      } else {
        for (const inv of pi.inversions) {
          lines.push(`  ${color.yellow(SYMBOLS.warning)} ${inv.uncovered_id} [${inv.uncovered_priority}] uncovered, but ${inv.covered_id} [${inv.covered_priority}] has ${inv.covered_plan_count} plan${inv.covered_plan_count !== 1 ? "s" : ""}`);
        }
      }
      lines.push("");
      lines.push(summaryLine(`${data.covered_outcomes}/${data.total_outcomes} outcomes covered, ${data.traced_plans}/${data.total_plans} plans traced`));
      return lines.join("\n");
    }
    function cmdIntentDrift(cwd, args, raw) {
      const planningDir = path.join(cwd, ".planning");
      const intentPath = path.join(planningDir, "INTENT.md");
      if (!fs.existsSync(intentPath)) {
        error("No INTENT.md found. Run `intent create` first.");
      }
      const data = getIntentDriftData(cwd);
      if (!data) {
        error("INTENT.md has no desired outcomes defined.");
      }
      output(data, { formatter: formatIntentDrift });
    }
    function getIntentSummary(cwd) {
      const intentPath = path.join(cwd, ".planning", "INTENT.md");
      if (!fs.existsSync(intentPath)) return null;
      const content = fs.readFileSync(intentPath, "utf-8");
      const data = parseIntentMd(content);
      if (!data.objective || !data.objective.statement) return null;
      return {
        objective: data.objective.statement,
        outcome_count: (data.outcomes || []).length,
        top_outcomes: (data.outcomes || []).filter((o) => o.priority === "P1").slice(0, 3).map((o) => ({ id: o.id, text: o.text })),
        users: (data.users || []).slice(0, 3).map((u) => u.text),
        has_criteria: (data.criteria || []).length > 0
      };
    }
    module2.exports = {
      cmdIntentCreate,
      cmdIntentShow,
      cmdIntentUpdate,
      cmdIntentValidate,
      cmdIntentTrace,
      cmdIntentDrift,
      getIntentDriftData,
      getIntentSummary
    };
  }
});

// src/commands/env.js
var require_env = __commonJS({
  "src/commands/env.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var { execFileSync } = require("child_process");
    var { output, error, debugLog } = require_output();
    var LANG_MANIFESTS = [
      { file: "package.json", language: "node", binary: "node", versionFlag: "--version" },
      { file: "go.mod", language: "go", binary: "go", versionFlag: "version" },
      { file: "mix.exs", language: "elixir", binary: "elixir", versionFlag: "--version" },
      { file: "Cargo.toml", language: "rust", binary: "cargo", versionFlag: "--version" },
      { file: "pyproject.toml", language: "python", binary: "python3", versionFlag: "--version" },
      { file: "setup.py", language: "python", binary: "python3", versionFlag: "--version" },
      { file: "requirements.txt", language: "python", binary: "python3", versionFlag: "--version" },
      { file: "Gemfile", language: "ruby", binary: "ruby", versionFlag: "--version" },
      { file: "composer.json", language: "php", binary: "php", versionFlag: "--version" },
      { file: "build.gradle", language: "java", binary: "java", versionFlag: "--version" },
      { file: "build.gradle.kts", language: "kotlin", binary: "java", versionFlag: "--version" },
      { file: "pom.xml", language: "java", binary: "java", versionFlag: "--version" },
      { file: "Package.swift", language: "swift", binary: "swift", versionFlag: "--version" },
      { file: "CMakeLists.txt", language: "cpp", binary: "cc", versionFlag: "--version" },
      { file: "Makefile", language: "make", binary: "make", versionFlag: "--version" },
      { file: "Justfile", language: "just", binary: "just", versionFlag: "--version" },
      { file: "Dockerfile", language: "docker", binary: "docker", versionFlag: "--version" },
      { file: "docker-compose.yml", language: "docker", binary: "docker", versionFlag: "--version" },
      { file: "docker-compose.yaml", language: "docker", binary: "docker", versionFlag: "--version" },
      { file: "compose.yml", language: "docker", binary: "docker", versionFlag: "--version" },
      { file: "compose.yaml", language: "docker", binary: "docker", versionFlag: "--version" },
      { file: "flake.nix", language: "nix", binary: "nix", versionFlag: "--version" },
      { file: "deno.json", language: "deno", binary: "deno", versionFlag: "--version" },
      { file: "deno.jsonc", language: "deno", binary: "deno", versionFlag: "--version" },
      { file: "bun.lockb", language: "bun", binary: "bun", versionFlag: "--version" },
      { file: "bunfig.toml", language: "bun", binary: "bun", versionFlag: "--version" }
    ];
    var SKIP_DIRS = /* @__PURE__ */ new Set([
      "node_modules",
      "vendor",
      "deps",
      "_build",
      ".git",
      ".next",
      "target",
      "dist",
      "build",
      "__pycache__",
      ".elixir_ls",
      ".cache"
    ]);
    var PM_LOCKFILES = [
      { file: "bun.lock", pm: "bun" },
      { file: "bun.lockb", pm: "bun" },
      { file: "pnpm-lock.yaml", pm: "pnpm" },
      { file: "yarn.lock", pm: "yarn" },
      { file: "package-lock.json", pm: "npm" },
      // Non-Node lockfiles
      { file: "mix.lock", pm: "mix" },
      { file: "go.sum", pm: "go-modules" },
      { file: "Cargo.lock", pm: "cargo" },
      { file: "Gemfile.lock", pm: "bundler" },
      { file: "poetry.lock", pm: "poetry" },
      { file: "Pipfile.lock", pm: "pipenv" }
    ];
    var VERSION_MANAGERS = [
      { file: ".tool-versions", name: "asdf" },
      { file: "mise.toml", name: "mise" },
      { file: ".mise.toml", name: "mise" },
      { file: ".nvmrc", name: "nvm" },
      { file: ".node-version", name: "node-version" },
      { file: ".python-version", name: "pyenv" },
      { file: ".ruby-version", name: "rbenv" },
      { file: ".go-version", name: "goenv" }
    ];
    var CI_CONFIGS = [
      { check: "dir", path: ".github/workflows", platform: "github-actions" },
      { check: "file", path: ".gitlab-ci.yml", platform: "gitlab-ci" },
      { check: "dir", path: ".circleci", platform: "circleci" },
      { check: "file", path: "Jenkinsfile", platform: "jenkins" },
      { check: "file", path: ".travis.yml", platform: "travis" }
    ];
    var TEST_CONFIGS = [
      { pattern: "jest.config.*", name: "jest" },
      { pattern: "vitest.config.*", name: "vitest" },
      { pattern: ".mocharc.*", name: "mocha" },
      { pattern: "pytest.ini", name: "pytest" },
      { pattern: "setup.cfg", name: "pytest", check: "[tool:pytest]" },
      { pattern: "tox.ini", name: "tox" }
    ];
    var LINT_CONFIGS = [
      { pattern: ".eslintrc*", name: "eslint", type: "linter" },
      { pattern: "eslint.config.*", name: "eslint", type: "linter" },
      { pattern: ".prettierrc*", name: "prettier", type: "formatter" },
      { pattern: "prettier.config.*", name: "prettier", type: "formatter" },
      { pattern: "biome.json", name: "biome", type: "both" },
      { pattern: "biome.jsonc", name: "biome", type: "both" },
      { pattern: ".credo.exs", name: "credo", type: "linter" },
      { pattern: ".golangci.yml", name: "golangci-lint", type: "linter" },
      { pattern: ".golangci.yaml", name: "golangci-lint", type: "linter" },
      { pattern: "rustfmt.toml", name: "rustfmt", type: "formatter" },
      { pattern: ".rubocop.yml", name: "rubocop", type: "both" }
    ];
    var WELL_KNOWN_SCRIPTS = ["test", "build", "lint", "start", "deploy", "format", "check"];
    function scanManifests(rootDir, maxDepth) {
      const results = [];
      function walk(dir, depth) {
        if (depth > maxDepth) return;
        let entries;
        try {
          entries = fs.readdirSync(dir, { withFileTypes: true });
        } catch {
          return;
        }
        for (const entry of entries) {
          if (entry.isDirectory()) {
            if (!SKIP_DIRS.has(entry.name)) {
              walk(path.join(dir, entry.name), depth + 1);
            }
          } else if (entry.isFile()) {
            for (const manifest of LANG_MANIFESTS) {
              if (entry.name === manifest.file) {
                results.push({
                  language: manifest.language,
                  file: manifest.file,
                  path: path.relative(rootDir, path.join(dir, entry.name)),
                  depth,
                  binary: manifest.binary,
                  versionFlag: manifest.versionFlag
                });
              }
            }
          }
        }
      }
      walk(rootDir, 0);
      return results;
    }
    function determinePrimaryLanguage(manifests) {
      if (manifests.length === 0) return null;
      const langStats = {};
      for (const m of manifests) {
        if (!langStats[m.language]) {
          langStats[m.language] = { rootCount: 0, totalCount: 0 };
        }
        langStats[m.language].totalCount++;
        if (m.depth === 0) langStats[m.language].rootCount++;
      }
      const sorted = Object.entries(langStats).sort((a, b) => {
        if (b[1].rootCount !== a[1].rootCount) return b[1].rootCount - a[1].rootCount;
        return b[1].totalCount - a[1].totalCount;
      });
      return sorted[0][0];
    }
    function buildLanguageEntries(manifests, primaryLang) {
      const byLang = {};
      for (const m of manifests) {
        if (!byLang[m.language]) {
          byLang[m.language] = {
            name: m.language,
            primary: m.language === primaryLang,
            manifests: [],
            binary: { name: m.binary, versionFlag: m.versionFlag, available: false, version: null, path: null }
          };
        }
        byLang[m.language].manifests.push({ file: m.file, path: m.path, depth: m.depth });
      }
      return Object.values(byLang);
    }
    function checkBinary(binaryName, versionFlag) {
      const result = { available: false, version: null, path: null };
      const timeout = 3e3;
      try {
        const whichResult = execFileSync("which", [binaryName], {
          encoding: "utf-8",
          timeout,
          stdio: "pipe"
        }).trim();
        if (whichResult) {
          result.available = true;
          result.path = whichResult;
          try {
            const flagArgs = versionFlag.split(/\s+/);
            const versionOut = execFileSync(binaryName, flagArgs, {
              encoding: "utf-8",
              timeout,
              stdio: "pipe"
            }).trim();
            const versionMatch = versionOut.match(/(\d+\.\d+[\.\d]*)/);
            if (versionMatch) {
              result.version = versionMatch[1];
            }
          } catch {
            debugLog("env.binary", `version check failed for ${binaryName}`);
          }
        }
      } catch {
        debugLog("env.binary", `${binaryName} not found on PATH`);
      }
      return result;
    }
    function detectPackageManager(rootDir) {
      const result = { name: null, version: null, source: null, detected_from: null };
      const pkgJsonPath = path.join(rootDir, "package.json");
      try {
        if (fs.existsSync(pkgJsonPath)) {
          const pkg = JSON.parse(fs.readFileSync(pkgJsonPath, "utf-8"));
          if (pkg.packageManager) {
            const match = pkg.packageManager.match(/^([^@]+)(?:@(.+))?$/);
            if (match) {
              result.name = match[1];
              result.version = match[2] || null;
              result.source = "packageManager-field";
              result.detected_from = "package.json";
              return result;
            }
          }
        }
      } catch {
        debugLog("env.pm", "package.json parse failed");
      }
      for (const lockfile of PM_LOCKFILES) {
        if (fs.existsSync(path.join(rootDir, lockfile.file))) {
          result.name = lockfile.pm;
          result.source = "lockfile";
          result.detected_from = lockfile.file;
          return result;
        }
      }
      return result;
    }
    function detectVersionManagers(rootDir) {
      const results = [];
      for (const vm of VERSION_MANAGERS) {
        const filePath = path.join(rootDir, vm.file);
        if (fs.existsSync(filePath)) {
          const entry = { name: vm.name, file: vm.file, configured_versions: {} };
          try {
            const content = fs.readFileSync(filePath, "utf-8").trim();
            if (vm.file === ".nvmrc" || vm.file === ".node-version") {
              entry.configured_versions.node = content.replace(/^v/, "");
            } else if (vm.file === ".python-version") {
              entry.configured_versions.python = content;
            } else if (vm.file === ".ruby-version") {
              entry.configured_versions.ruby = content;
            } else if (vm.file === ".go-version") {
              entry.configured_versions.go = content;
            } else if (vm.file === ".tool-versions") {
              for (const line of content.split("\n")) {
                const parts = line.trim().split(/\s+/);
                if (parts.length >= 2 && !parts[0].startsWith("#")) {
                  entry.configured_versions[parts[0]] = parts[1];
                }
              }
            } else if (vm.file === "mise.toml" || vm.file === ".mise.toml") {
              const toolsMatch = content.match(/\[tools\]\s*\n((?:.*\n?)*?)(?:\n\[|$)/);
              if (toolsMatch) {
                for (const line of toolsMatch[1].split("\n")) {
                  const kvMatch = line.match(/^\s*(\w+)\s*=\s*["']?([^"'\s]+)["']?/);
                  if (kvMatch) {
                    entry.configured_versions[kvMatch[1]] = kvMatch[2];
                  }
                }
              }
            }
          } catch {
            debugLog("env.vm", `failed to parse ${vm.file}`);
          }
          results.push(entry);
        }
      }
      return results;
    }
    function detectCI(rootDir) {
      for (const ci of CI_CONFIGS) {
        const fullPath = path.join(rootDir, ci.path);
        try {
          if (ci.check === "dir") {
            if (fs.existsSync(fullPath) && fs.statSync(fullPath).isDirectory()) {
              return { platform: ci.platform, config_file: ci.path };
            }
          } else {
            if (fs.existsSync(fullPath)) {
              return { platform: ci.platform, config_file: ci.path };
            }
          }
        } catch {
        }
      }
      return null;
    }
    function detectTestFrameworks(rootDir) {
      const results = [];
      const seen = /* @__PURE__ */ new Set();
      for (const tc of TEST_CONFIGS) {
        try {
          const dir = fs.readdirSync(rootDir);
          for (const entry of dir) {
            if (matchSimpleGlob(entry, tc.pattern)) {
              if (tc.check) {
                const content = fs.readFileSync(path.join(rootDir, entry), "utf-8");
                if (!content.includes(tc.check)) continue;
              }
              if (!seen.has(tc.name)) {
                seen.add(tc.name);
                results.push({ name: tc.name, config_file: entry });
              }
            }
          }
        } catch {
        }
      }
      for (const testDir of ["test", "tests", "spec", "__tests__"]) {
        try {
          const fullPath = path.join(rootDir, testDir);
          if (fs.existsSync(fullPath) && fs.statSync(fullPath).isDirectory()) {
            results.push({ name: testDir, config_file: null });
          }
        } catch {
        }
      }
      return results;
    }
    function detectLintFormat(rootDir) {
      const linters = [];
      const formatters = [];
      const seen = /* @__PURE__ */ new Set();
      try {
        const dir = fs.readdirSync(rootDir);
        for (const entry of dir) {
          for (const lc of LINT_CONFIGS) {
            if (matchSimpleGlob(entry, lc.pattern) && !seen.has(lc.name)) {
              seen.add(lc.name);
              const item = { name: lc.name, config_file: entry };
              if (lc.type === "linter" || lc.type === "both") linters.push(item);
              if (lc.type === "formatter" || lc.type === "both") formatters.push(item);
            }
          }
        }
      } catch {
      }
      return { linters, formatters };
    }
    function matchSimpleGlob(name, pattern) {
      if (!pattern.includes("*")) return name === pattern;
      const starIdx = pattern.indexOf("*");
      const prefix = pattern.slice(0, starIdx);
      const suffix = pattern.slice(starIdx + 1);
      if (suffix) {
        return name.startsWith(prefix) && name.endsWith(suffix);
      }
      return name.startsWith(prefix);
    }
    function detectScripts(rootDir) {
      const scripts = {};
      try {
        const pkgPath = path.join(rootDir, "package.json");
        if (fs.existsSync(pkgPath)) {
          const pkg = JSON.parse(fs.readFileSync(pkgPath, "utf-8"));
          if (pkg.scripts) {
            for (const name of WELL_KNOWN_SCRIPTS) {
              if (pkg.scripts[name]) {
                scripts[name] = pkg.scripts[name];
              }
            }
          }
        }
      } catch {
        debugLog("env.scripts", "package.json parse failed");
      }
      try {
        const makefilePath = path.join(rootDir, "Makefile");
        if (fs.existsSync(makefilePath)) {
          const content = fs.readFileSync(makefilePath, "utf-8");
          const targets = [];
          for (const line of content.split("\n")) {
            const match = line.match(/^([a-zA-Z_][\w-]*):/);
            if (match && !match[1].startsWith(".")) {
              targets.push(match[1]);
            }
          }
          if (targets.length > 0) {
            scripts._makefile_targets = targets;
          }
        }
      } catch {
        debugLog("env.scripts", "Makefile parse failed");
      }
      try {
        const justfilePath = path.join(rootDir, "Justfile");
        if (fs.existsSync(justfilePath)) {
          const content = fs.readFileSync(justfilePath, "utf-8");
          const targets = [];
          for (const line of content.split("\n")) {
            const match = line.match(/^([a-zA-Z_][\w-]*)(?:\s.*)?:/);
            if (match) {
              targets.push(match[1]);
            }
          }
          if (targets.length > 0) {
            scripts._justfile_targets = targets;
          }
        }
      } catch {
        debugLog("env.scripts", "Justfile parse failed");
      }
      try {
        const mixPath = path.join(rootDir, "mix.exs");
        if (fs.existsSync(mixPath)) {
          const result = execFileSync("mix", ["help", "--names"], {
            cwd: rootDir,
            encoding: "utf-8",
            timeout: 3e3,
            stdio: "pipe"
          }).trim();
          if (result) {
            const aliases = result.split("\n").filter((l) => l.trim());
            if (aliases.length > 0) {
              scripts._mix_tasks = aliases.slice(0, 20);
            }
          }
        }
      } catch {
        debugLog("env.scripts", "mix help failed");
      }
      return scripts;
    }
    function detectInfraServices(rootDir) {
      const dockerServices = [];
      const composeFiles = ["docker-compose.yml", "docker-compose.yaml", "compose.yml", "compose.yaml"];
      for (const file of composeFiles) {
        const filePath = path.join(rootDir, file);
        try {
          if (fs.existsSync(filePath)) {
            const content = fs.readFileSync(filePath, "utf-8");
            const servicesMatch = content.match(/^services:\s*\n((?:[ \t]+\S.*\n?)*)/m);
            if (servicesMatch) {
              const serviceLines = servicesMatch[1].split("\n");
              for (const line of serviceLines) {
                const match = line.match(/^[ \t]{2}(\w[\w-]*):/);
                if (match) {
                  dockerServices.push(match[1]);
                }
              }
            }
          }
        } catch {
          debugLog("env.infra", `failed to parse ${file}`);
        }
      }
      return dockerServices;
    }
    function detectMcpServers(rootDir) {
      const servers = [];
      try {
        const mcpPath = path.join(rootDir, ".mcp.json");
        if (fs.existsSync(mcpPath)) {
          const content = JSON.parse(fs.readFileSync(mcpPath, "utf-8"));
          if (content.mcpServers && typeof content.mcpServers === "object") {
            for (const name of Object.keys(content.mcpServers)) {
              servers.push(name);
            }
          }
        }
      } catch {
        debugLog("env.mcp", ".mcp.json parse failed");
      }
      return servers;
    }
    function detectMonorepo(rootDir) {
      try {
        const pkgPath = path.join(rootDir, "package.json");
        if (fs.existsSync(pkgPath)) {
          const pkg = JSON.parse(fs.readFileSync(pkgPath, "utf-8"));
          if (pkg.workspaces) {
            const members = Array.isArray(pkg.workspaces) ? pkg.workspaces : pkg.workspaces.packages || [];
            return { type: "npm-workspaces", members };
          }
        }
      } catch {
      }
      try {
        const pnpmWsPath = path.join(rootDir, "pnpm-workspace.yaml");
        if (fs.existsSync(pnpmWsPath)) {
          const content = fs.readFileSync(pnpmWsPath, "utf-8");
          const members = [];
          const packagesMatch = content.match(/packages:\s*\n((?:\s*-\s*.+\n?)*)/);
          if (packagesMatch) {
            for (const line of packagesMatch[1].split("\n")) {
              const m = line.match(/^\s*-\s*['"]?(.+?)['"]?\s*$/);
              if (m) members.push(m[1]);
            }
          }
          return { type: "pnpm-workspaces", members };
        }
      } catch {
      }
      try {
        const goWorkPath = path.join(rootDir, "go.work");
        if (fs.existsSync(goWorkPath)) {
          const content = fs.readFileSync(goWorkPath, "utf-8");
          const members = [];
          const useMatch = content.match(/use\s*\(([\s\S]*?)\)/);
          if (useMatch) {
            for (const line of useMatch[1].split("\n")) {
              const trimmed = line.trim();
              if (trimmed && !trimmed.startsWith("//")) {
                members.push(trimmed);
              }
            }
          }
          return { type: "go-workspace", members };
        }
      } catch {
      }
      try {
        const mixPath = path.join(rootDir, "mix.exs");
        if (fs.existsSync(mixPath)) {
          const content = fs.readFileSync(mixPath, "utf-8");
          if (content.includes("apps_path")) {
            const appsDir = path.join(rootDir, "apps");
            if (fs.existsSync(appsDir) && fs.statSync(appsDir).isDirectory()) {
              const members = fs.readdirSync(appsDir).filter((d) => {
                try {
                  return fs.statSync(path.join(appsDir, d)).isDirectory();
                } catch {
                  return false;
                }
              });
              return { type: "elixir-umbrella", members };
            }
          }
        }
      } catch {
      }
      return null;
    }
    function getWatchedFiles(cwd, manifests) {
      const watched = /* @__PURE__ */ new Set();
      for (const m of manifests) {
        if (m.depth === 0) {
          watched.add(m.file);
        }
      }
      for (const lf of PM_LOCKFILES) {
        if (fs.existsSync(path.join(cwd, lf.file))) {
          watched.add(lf.file);
        }
      }
      for (const vm of VERSION_MANAGERS) {
        if (fs.existsSync(path.join(cwd, vm.file))) {
          watched.add(vm.file);
        }
      }
      for (const dcFile of ["docker-compose.yml", "docker-compose.yaml", "compose.yml", "compose.yaml"]) {
        if (fs.existsSync(path.join(cwd, dcFile))) {
          watched.add(dcFile);
        }
      }
      return Array.from(watched).sort();
    }
    function getWatchedFilesMtimes(cwd, watchedFiles) {
      const mtimes = {};
      for (const file of watchedFiles) {
        try {
          const stat = fs.statSync(path.join(cwd, file));
          mtimes[file] = stat.mtimeMs;
        } catch {
        }
      }
      return mtimes;
    }
    function ensureManifestGitignored(cwd) {
      const planningDir = path.join(cwd, ".planning");
      if (!fs.existsSync(planningDir)) return;
      const planningGitignore = path.join(planningDir, ".gitignore");
      if (fs.existsSync(planningGitignore)) {
        const content = fs.readFileSync(planningGitignore, "utf-8");
        if (content.includes("env-manifest.json")) return;
        const newContent = content.endsWith("\n") ? content + "env-manifest.json\n" : content + "\nenv-manifest.json\n";
        fs.writeFileSync(planningGitignore, newContent);
        return;
      }
      const rootGitignore = path.join(cwd, ".gitignore");
      if (fs.existsSync(rootGitignore)) {
        const content = fs.readFileSync(rootGitignore, "utf-8");
        if (content.includes("env-manifest.json")) return;
      }
      fs.writeFileSync(planningGitignore, "env-manifest.json\n");
    }
    function writeProjectProfile(cwd, result) {
      const planningDir = path.join(cwd, ".planning");
      if (!fs.existsSync(planningDir)) return;
      const ci = result.tools && result.tools.ci;
      const infraServices = result.infrastructure && result.infrastructure.docker_services ? result.infrastructure.docker_services : [];
      const profile = {
        "$schema_version": "1.0",
        generated_at: (/* @__PURE__ */ new Date()).toISOString(),
        languages: result.languages.map((l) => l.name),
        primary_language: (result.languages.find((l) => l.primary) || {}).name || null,
        package_manager: result.package_manager ? result.package_manager.name : null,
        monorepo: result.monorepo || null,
        ci_platform: ci ? ci.platform : null,
        infrastructure_services: infraServices
      };
      const profilePath = path.join(planningDir, "project-profile.json");
      fs.writeFileSync(profilePath, JSON.stringify(profile, null, 2) + "\n");
    }
    function checkEnvManifestStaleness(cwd) {
      const manifestPath = path.join(cwd, ".planning", "env-manifest.json");
      if (!fs.existsSync(manifestPath)) {
        return { stale: true, reason: "no_manifest" };
      }
      let manifest;
      try {
        manifest = JSON.parse(fs.readFileSync(manifestPath, "utf-8"));
      } catch {
        return { stale: true, reason: "corrupt_manifest" };
      }
      if (!manifest.watched_files_mtimes) {
        return { stale: true, reason: "no_mtime_data" };
      }
      const changedFiles = [];
      for (const file of manifest.watched_files || []) {
        const filePath = path.join(cwd, file);
        try {
          const currentMtime = fs.statSync(filePath).mtimeMs;
          const recordedMtime = manifest.watched_files_mtimes[file];
          if (recordedMtime === void 0 || currentMtime > recordedMtime) {
            changedFiles.push(file);
          }
        } catch {
          if (manifest.watched_files_mtimes[file] !== void 0) {
            changedFiles.push(file);
          }
        }
      }
      const knownFilesSet = /* @__PURE__ */ new Set([
        ...LANG_MANIFESTS.map((m) => m.file),
        ...PM_LOCKFILES.map((l) => l.file),
        ...VERSION_MANAGERS.map((v) => v.file)
      ]);
      const trackedSet = new Set(manifest.watched_files || []);
      for (const file of knownFilesSet) {
        if (!trackedSet.has(file) && fs.existsSync(path.join(cwd, file))) {
          changedFiles.push(file);
          break;
        }
      }
      if (changedFiles.length > 0) {
        return { stale: true, reason: "files_changed", changed_files: [...new Set(changedFiles)] };
      }
      return { stale: false };
    }
    function performEnvScan(cwd, options = {}) {
      const { skipBinaryVersions = false } = options;
      const startMs = Date.now();
      const manifests = scanManifests(cwd, 3);
      const primaryLang = determinePrimaryLanguage(manifests);
      const languages = buildLanguageEntries(manifests, primaryLang);
      if (!skipBinaryVersions) {
        for (const lang of languages) {
          const binaryResult = checkBinary(lang.binary.name, lang.binary.versionFlag);
          lang.binary.available = binaryResult.available;
          lang.binary.version = binaryResult.version;
          lang.binary.path = binaryResult.path;
        }
        const elixirLang = languages.find((l) => l.name === "elixir");
        if (elixirLang) {
          const mixResult = checkBinary("mix", "--version");
          elixirLang.binary.extra = { name: "mix", ...mixResult };
        }
      }
      const packageManager = detectPackageManager(cwd);
      const versionManagers = detectVersionManagers(cwd);
      const ci = detectCI(cwd);
      const testFrameworks = detectTestFrameworks(cwd);
      const { linters, formatters } = detectLintFormat(cwd);
      const scripts = detectScripts(cwd);
      const dockerServices = detectInfraServices(cwd);
      const mcpServers = detectMcpServers(cwd);
      const monorepo = detectMonorepo(cwd);
      const detectionMs = Date.now() - startMs;
      const watchedFiles = getWatchedFiles(cwd, manifests);
      const watchedFilesMtimes = getWatchedFilesMtimes(cwd, watchedFiles);
      return {
        "$schema_version": "1.0",
        scanned_at: (/* @__PURE__ */ new Date()).toISOString(),
        detection_ms: detectionMs,
        languages,
        package_manager: packageManager,
        version_managers: versionManagers,
        tools: {
          ci,
          test_frameworks: testFrameworks,
          linters,
          formatters
        },
        scripts,
        infrastructure: {
          docker_services: dockerServices,
          mcp_servers: mcpServers
        },
        monorepo,
        watched_files: watchedFiles,
        watched_files_mtimes: watchedFilesMtimes
      };
    }
    function writeManifest(cwd, result) {
      const planningDir = path.join(cwd, ".planning");
      if (!fs.existsSync(planningDir)) return false;
      const manifestPath = path.join(planningDir, "env-manifest.json");
      fs.writeFileSync(manifestPath, JSON.stringify(result, null, 2) + "\n");
      return true;
    }
    function cmdEnvScan(cwd, args, raw) {
      const force = args.includes("--force");
      const verbose = global._gsdCompactMode === false;
      if (!force) {
        const staleness = checkEnvManifestStaleness(cwd);
        if (!staleness.stale) {
          const manifestPath = path.join(cwd, ".planning", "env-manifest.json");
          const existing = JSON.parse(fs.readFileSync(manifestPath, "utf-8"));
          if (verbose) {
            process.stderr.write("Environment manifest is current\n");
          }
          if (raw) {
            output(existing, raw);
          }
          process.exit(0);
        }
        if (staleness.reason === "files_changed" && verbose) {
          const changed = staleness.changed_files || [];
          process.stderr.write(`Environment changed (${changed.join(", ")} modified), rescanning...
`);
        }
      }
      const result = performEnvScan(cwd);
      writeManifest(cwd, result);
      ensureManifestGitignored(cwd);
      writeProjectProfile(cwd, result);
      if (verbose) {
        const langNames = result.languages.map((l) => l.name).join(", ");
        const pm = result.package_manager ? result.package_manager.name : "none";
        process.stderr.write(`Scanned in ${result.detection_ms}ms: languages=[${langNames}], pm=${pm}, watched=${result.watched_files.length} files
`);
      }
      if (raw) {
        output(result, raw);
      }
      process.exit(0);
    }
    function cmdEnvStatus(cwd, args, raw) {
      const manifestPath = path.join(cwd, ".planning", "env-manifest.json");
      const exists = fs.existsSync(manifestPath);
      let manifest = null;
      if (exists) {
        try {
          manifest = JSON.parse(fs.readFileSync(manifestPath, "utf-8"));
        } catch {
        }
      }
      const staleness = checkEnvManifestStaleness(cwd);
      const result = {
        exists,
        stale: staleness.stale,
        reason: staleness.reason || null,
        scanned_at: manifest ? manifest.scanned_at : null,
        age_minutes: manifest ? Math.round((Date.now() - new Date(manifest.scanned_at).getTime()) / 6e4) : null,
        languages_count: manifest ? (manifest.languages || []).length : 0,
        changed_files: staleness.changed_files || []
      };
      output(result, raw);
    }
    function readEnvManifest(cwd) {
      const manifestPath = path.join(cwd, ".planning", "env-manifest.json");
      try {
        if (!fs.existsSync(manifestPath)) return null;
        return JSON.parse(fs.readFileSync(manifestPath, "utf-8"));
      } catch {
        return null;
      }
    }
    function formatEnvSummary(manifest) {
      if (!manifest || !manifest.languages || manifest.languages.length === 0) return null;
      const langPmMap = {
        npm: "node",
        pnpm: "node",
        yarn: "node",
        bun: "node",
        mix: "elixir",
        cargo: "rust",
        bundler: "ruby",
        poetry: "python",
        pipenv: "python",
        "go-modules": "go"
      };
      const pm = manifest.package_manager;
      const pmName = pm && pm.name ? pm.name : null;
      const pmLang = pmName ? langPmMap[pmName] || null : null;
      const parts = [];
      for (const lang of manifest.languages) {
        let entry;
        if (lang.binary && lang.binary.available && lang.binary.version) {
          entry = `${lang.name}@${lang.binary.version}`;
        } else if (lang.binary && lang.binary.available) {
          entry = lang.name;
        } else {
          entry = `${lang.name} (no binary)`;
        }
        if (pmLang === lang.name && pmName) {
          const pmDisplay = pmName === "go-modules" ? "go modules" : pmName;
          entry += ` (${pmDisplay})`;
        }
        parts.push(entry);
      }
      if (manifest.infrastructure && manifest.infrastructure.docker_services && manifest.infrastructure.docker_services.length > 0) {
        if (!manifest.languages.some((l) => l.name === "docker")) {
          parts.push("docker");
        }
      }
      return `Tools: ${parts.join(", ")}`;
    }
    function autoTriggerEnvScan(cwd) {
      const planningDir = path.join(cwd, ".planning");
      if (!fs.existsSync(planningDir)) return null;
      const manifest = readEnvManifest(cwd);
      if (manifest) {
        const staleness = checkEnvManifestStaleness(cwd);
        if (!staleness.stale) {
          return manifest;
        }
        debugLog("env.autoTrigger", `rescan: ${staleness.reason}`);
      }
      try {
        const result = performEnvScan(cwd, { skipBinaryVersions: !!manifest });
        writeManifest(cwd, result);
        ensureManifestGitignored(cwd);
        writeProjectProfile(cwd, result);
        return result;
      } catch (e) {
        debugLog("env.autoTrigger", `scan failed: ${e.message}`);
        return manifest;
      }
    }
    module2.exports = {
      cmdEnvScan,
      cmdEnvStatus,
      checkEnvManifestStaleness,
      LANG_MANIFESTS,
      scanManifests,
      checkBinary,
      detectPackageManager,
      matchSimpleGlob,
      performEnvScan,
      writeManifest,
      ensureManifestGitignored,
      writeProjectProfile,
      getWatchedFiles,
      getWatchedFilesMtimes,
      readEnvManifest,
      formatEnvSummary,
      autoTriggerEnvScan
    };
  }
});

// src/lib/codebase-intel.js
var require_codebase_intel = __commonJS({
  "src/lib/codebase-intel.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var { debugLog } = require_output();
    var { execGit } = require_git();
    var { cachedReadFile } = require_helpers();
    function INTEL_PATH(cwd) {
      return path.join(cwd, ".planning", "codebase", "codebase-intel.json");
    }
    var LANGUAGE_MAP = {
      // JavaScript / TypeScript
      ".js": "javascript",
      ".cjs": "javascript",
      ".mjs": "javascript",
      ".ts": "typescript",
      ".tsx": "typescript",
      ".jsx": "javascript",
      // Python
      ".py": "python",
      ".pyw": "python",
      ".pyi": "python",
      // Go
      ".go": "go",
      // Elixir
      ".ex": "elixir",
      ".exs": "elixir",
      // Rust
      ".rs": "rust",
      // Ruby
      ".rb": "ruby",
      ".rake": "ruby",
      // Java / Kotlin
      ".java": "java",
      ".kt": "kotlin",
      ".kts": "kotlin",
      // C / C++
      ".c": "c",
      ".h": "c",
      ".cpp": "cpp",
      ".hpp": "cpp",
      ".cc": "cpp",
      ".hh": "cpp",
      // Shell
      ".sh": "shell",
      ".bash": "shell",
      ".zsh": "shell",
      // Markup / Config
      ".md": "markdown",
      ".mdx": "markdown",
      ".json": "json",
      ".jsonc": "json",
      ".yaml": "yaml",
      ".yml": "yaml",
      ".toml": "toml",
      ".xml": "xml",
      ".html": "html",
      ".htm": "html",
      ".css": "css",
      ".scss": "css",
      ".less": "css",
      ".sql": "sql",
      ".graphql": "graphql",
      ".gql": "graphql",
      ".proto": "protobuf",
      ".swift": "swift",
      ".dart": "dart",
      ".lua": "lua",
      ".r": "r",
      ".R": "r",
      ".php": "php",
      ".pl": "perl",
      ".pm": "perl",
      ".zig": "zig",
      ".nim": "nim",
      ".nix": "nix",
      ".tf": "terraform",
      ".hcl": "terraform",
      ".vue": "vue",
      ".svelte": "svelte"
    };
    var SKIP_DIRS = /* @__PURE__ */ new Set([
      "node_modules",
      "vendor",
      "deps",
      "_build",
      ".git",
      ".next",
      "target",
      "dist",
      "build",
      "__pycache__",
      ".elixir_ls",
      ".cache",
      ".planning"
    ]);
    var BINARY_EXTENSIONS = /* @__PURE__ */ new Set([
      ".png",
      ".jpg",
      ".jpeg",
      ".gif",
      ".bmp",
      ".ico",
      ".svg",
      ".webp",
      ".woff",
      ".woff2",
      ".ttf",
      ".eot",
      ".otf",
      ".exe",
      ".dll",
      ".so",
      ".dylib",
      ".a",
      ".o",
      ".zip",
      ".tar",
      ".gz",
      ".bz2",
      ".xz",
      ".7z",
      ".rar",
      ".pdf",
      ".doc",
      ".docx",
      ".xls",
      ".xlsx",
      ".ppt",
      ".pptx",
      ".mp3",
      ".mp4",
      ".wav",
      ".avi",
      ".mov",
      ".mkv",
      ".flac",
      ".wasm",
      ".pyc",
      ".pyo",
      ".class",
      ".beam",
      ".db",
      ".sqlite",
      ".sqlite3",
      ".lock"
    ]);
    function getSourceDirs(cwd) {
      const sourceDirs = [];
      const knownSourceDirs = /* @__PURE__ */ new Set(["src", "lib", "app", "apps", "pkg", "cmd", "internal", "test", "tests", "spec"]);
      let entries;
      try {
        entries = fs.readdirSync(cwd, { withFileTypes: true });
      } catch {
        return [];
      }
      for (const entry of entries) {
        if (!entry.isDirectory()) {
          const ext = path.extname(entry.name);
          if (LANGUAGE_MAP[ext]) {
            if (!sourceDirs.includes(".")) sourceDirs.push(".");
          }
          continue;
        }
        const name = entry.name;
        if (SKIP_DIRS.has(name)) continue;
        if (name.startsWith(".") && name !== ".") continue;
        const ignoreResult = execGit(cwd, ["check-ignore", "-q", name]);
        if (ignoreResult.exitCode === 0) {
          debugLog("codebase.sourceDirs", `skipping git-ignored: ${name}`);
          continue;
        }
        if (knownSourceDirs.has(name)) {
          sourceDirs.push(name);
        } else {
          try {
            const subEntries = fs.readdirSync(path.join(cwd, name), { withFileTypes: true });
            const hasSource = subEntries.some((e) => {
              if (e.isFile()) {
                const ext = path.extname(e.name);
                return LANGUAGE_MAP[ext] !== void 0;
              }
              return false;
            });
            if (hasSource) {
              sourceDirs.push(name);
            }
          } catch {
          }
        }
      }
      if (sourceDirs.length === 0) {
        sourceDirs.push(".");
      }
      return sourceDirs;
    }
    function walkSourceFiles(cwd, sourceDirs, skipDirs) {
      const files = [];
      const visited = /* @__PURE__ */ new Set();
      function walk(dir) {
        const absDir = path.join(cwd, dir);
        if (visited.has(absDir)) return;
        visited.add(absDir);
        let entries;
        try {
          entries = fs.readdirSync(absDir, { withFileTypes: true });
        } catch {
          return;
        }
        for (const entry of entries) {
          const relPath = path.join(dir, entry.name);
          if (entry.isDirectory()) {
            if (!skipDirs.has(entry.name) && !entry.name.startsWith(".")) {
              walk(relPath);
            }
          } else if (entry.isFile()) {
            const ext = path.extname(entry.name);
            if (!BINARY_EXTENSIONS.has(ext)) {
              files.push(relPath);
            }
          }
        }
      }
      for (const dir of sourceDirs) {
        walk(dir);
      }
      return files;
    }
    function analyzeFile(filePath) {
      const ext = path.extname(filePath);
      const language = LANGUAGE_MAP[ext] || null;
      let stat;
      try {
        stat = fs.statSync(filePath);
      } catch {
        return { language, size_bytes: 0, lines: 0, last_modified: null };
      }
      let lines = 0;
      try {
        const content = fs.readFileSync(filePath);
        for (let i = 0; i < content.length; i++) {
          if (content[i] === 10) lines++;
        }
        if (content.length > 0 && content[content.length - 1] !== 10) {
          lines++;
        }
      } catch {
      }
      return {
        language,
        size_bytes: stat.size,
        lines,
        last_modified: stat.mtime.toISOString()
      };
    }
    function getGitInfo(cwd) {
      const hashResult = execGit(cwd, ["rev-parse", "HEAD"]);
      const branchResult = execGit(cwd, ["rev-parse", "--abbrev-ref", "HEAD"]);
      return {
        commit_hash: hashResult.exitCode === 0 ? hashResult.stdout : null,
        branch: branchResult.exitCode === 0 ? branchResult.stdout : null
      };
    }
    function getChangedFilesSinceCommit(cwd, commitHash) {
      if (!commitHash) return null;
      const result = execGit(cwd, ["diff", "--name-only", commitHash, "HEAD"]);
      if (result.exitCode !== 0) {
        debugLog("codebase.changedFiles", `git diff failed for ${commitHash}`);
        return null;
      }
      const files = result.stdout.split("\n").filter((f) => f.trim().length > 0);
      return files;
    }
    function checkStaleness(cwd) {
      const intel = readIntel(cwd);
      if (!intel) {
        return { stale: true, reason: "no_intel" };
      }
      if (intel.git_commit_hash) {
        const gitInfo = getGitInfo(cwd);
        if (gitInfo.commit_hash && gitInfo.commit_hash === intel.git_commit_hash) {
          if (intel.generated_at) {
            const ageMs = Date.now() - new Date(intel.generated_at).getTime();
            const ONE_HOUR = 60 * 60 * 1e3;
            if (ageMs > ONE_HOUR) {
              return { stale: true, reason: "time_stale", changed_files: [] };
            }
          }
          return { stale: false };
        }
        const changedFiles = getChangedFilesSinceCommit(cwd, intel.git_commit_hash);
        if (changedFiles === null) {
          return { stale: true, reason: "commit_missing", changed_files: [] };
        }
        if (changedFiles.length > 0) {
          return { stale: true, reason: "files_changed", changed_files: changedFiles };
        }
        return { stale: false };
      }
      if (intel.generated_at) {
        const generatedTime = new Date(intel.generated_at).getTime();
        const sourceDirs = intel.source_dirs || getSourceDirs(cwd);
        const allFiles = walkSourceFiles(cwd, sourceDirs, SKIP_DIRS);
        const changedFiles = [];
        for (const file of allFiles) {
          try {
            const stat = fs.statSync(path.join(cwd, file));
            if (stat.mtimeMs > generatedTime) {
              changedFiles.push(file);
            }
          } catch {
            changedFiles.push(file);
          }
        }
        if (changedFiles.length > 0) {
          return { stale: true, reason: "mtime_newer", changed_files: changedFiles };
        }
        return { stale: false };
      }
      return { stale: true, reason: "no_watermark" };
    }
    function performAnalysis(cwd, options = {}) {
      const { incremental = false, previousIntel = null, changedFiles = null } = options;
      const startMs = Date.now();
      const gitInfo = getGitInfo(cwd);
      const sourceDirs = getSourceDirs(cwd);
      let fileEntries;
      if (incremental && previousIntel && changedFiles) {
        debugLog("codebase.analyze", `incremental: re-analyzing ${changedFiles.length} files`);
        fileEntries = { ...previousIntel.files };
        for (const filePath of Object.keys(fileEntries)) {
          try {
            fs.statSync(path.join(cwd, filePath));
          } catch {
            delete fileEntries[filePath];
          }
        }
        for (const filePath of changedFiles) {
          const absPath = path.join(cwd, filePath);
          try {
            fs.statSync(absPath);
            const ext = path.extname(filePath);
            if (!BINARY_EXTENSIONS.has(ext)) {
              const result = analyzeFile(absPath);
              fileEntries[filePath] = result;
            }
          } catch {
            delete fileEntries[filePath];
          }
        }
      } else {
        debugLog("codebase.analyze", "full analysis");
        const allFiles = walkSourceFiles(cwd, sourceDirs, SKIP_DIRS);
        fileEntries = {};
        for (const filePath of allFiles) {
          const absPath = path.join(cwd, filePath);
          const result = analyzeFile(absPath);
          fileEntries[filePath] = result;
        }
      }
      const languages = {};
      let totalLines = 0;
      let totalFiles = 0;
      for (const [filePath, info] of Object.entries(fileEntries)) {
        totalFiles++;
        totalLines += info.lines || 0;
        const lang = info.language;
        if (!lang) continue;
        if (!languages[lang]) {
          languages[lang] = { count: 0, extensions: /* @__PURE__ */ new Set(), lines: 0 };
        }
        languages[lang].count++;
        languages[lang].lines += info.lines || 0;
        const ext = path.extname(filePath);
        if (ext) languages[lang].extensions.add(ext);
      }
      for (const lang of Object.values(languages)) {
        lang.extensions = [...lang.extensions].sort();
      }
      const durationMs = Date.now() - startMs;
      return {
        version: 1,
        generated_at: (/* @__PURE__ */ new Date()).toISOString(),
        git_commit_hash: gitInfo.commit_hash,
        git_branch: gitInfo.branch,
        analysis_duration_ms: durationMs,
        source_dirs: sourceDirs,
        languages,
        files: fileEntries,
        stats: {
          total_files: totalFiles,
          total_lines: totalLines,
          languages_detected: Object.keys(languages).length
        }
      };
    }
    function readIntel(cwd) {
      const intelPath = INTEL_PATH(cwd);
      const content = cachedReadFile(intelPath);
      if (!content) return null;
      try {
        return JSON.parse(content);
      } catch (e) {
        debugLog("codebase.readIntel", "JSON parse failed", e);
        return null;
      }
    }
    function writeIntel(cwd, intel) {
      const intelPath = INTEL_PATH(cwd);
      const dir = path.dirname(intelPath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
      fs.writeFileSync(intelPath, JSON.stringify(intel, null, 2) + "\n");
      debugLog("codebase.writeIntel", `wrote ${intelPath}`);
    }
    function getStalenessAge(intel, cwd) {
      if (!intel || !intel.generated_at) return null;
      const ageMs = Date.now() - new Date(intel.generated_at).getTime();
      let commitsBehind = 0;
      if (cwd && intel.git_commit_hash) {
        try {
          const result = execGit(cwd, ["rev-list", "--count", `${intel.git_commit_hash}..HEAD`]);
          if (result.exitCode === 0 && result.stdout) {
            commitsBehind = parseInt(result.stdout, 10) || 0;
          }
        } catch (e) {
          debugLog("codebase.getStalenessAge", "git rev-list failed", e);
        }
      }
      return { age_ms: ageMs, commits_behind: commitsBehind };
    }
    module2.exports = {
      INTEL_PATH,
      LANGUAGE_MAP,
      SKIP_DIRS,
      BINARY_EXTENSIONS,
      getSourceDirs,
      walkSourceFiles,
      analyzeFile,
      getGitInfo,
      getChangedFilesSinceCommit,
      checkStaleness,
      getStalenessAge,
      performAnalysis,
      readIntel,
      writeIntel
    };
  }
});

// src/lib/conventions.js
var require_conventions = __commonJS({
  "src/lib/conventions.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var { LANGUAGE_MAP } = require_codebase_intel();
    var NAMING_PATTERNS = {
      camelCase: /^[a-z][a-z0-9]*[A-Z][a-zA-Z0-9]*$/,
      PascalCase: /^[A-Z][a-zA-Z0-9]*[a-z][a-zA-Z0-9]*$/,
      snake_case: /^[a-z][a-z0-9]*(_[a-z0-9]+)+$/,
      "kebab-case": /^[a-z][a-z0-9]*(-[a-z0-9]+)+$/,
      UPPER_SNAKE_CASE: /^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$/
    };
    function classifyName(name) {
      if (/^[a-z][a-z0-9]*$/.test(name)) return "single-word";
      if (/^[A-Z][A-Z0-9]*$/.test(name)) return "single-word";
      for (const [pattern, regex] of Object.entries(NAMING_PATTERNS)) {
        if (regex.test(name)) return pattern;
      }
      return "mixed";
    }
    var SOURCE_LANGUAGES = /* @__PURE__ */ new Set([
      "javascript",
      "typescript",
      "python",
      "go",
      "elixir",
      "rust",
      "ruby",
      "java",
      "kotlin",
      "c",
      "cpp",
      "shell",
      "swift",
      "dart",
      "lua",
      "r",
      "php",
      "perl",
      "zig",
      "nim",
      "vue",
      "svelte"
    ]);
    function isSourceFile(filePath, fileInfo) {
      if (!fileInfo || !fileInfo.language) return false;
      return SOURCE_LANGUAGES.has(fileInfo.language);
    }
    function detectNamingConventions(intel) {
      if (!intel || !intel.files) return { overall: {}, by_directory: {} };
      const byDir = {};
      const allNames = {};
      for (const [filePath, fileInfo] of Object.entries(intel.files)) {
        if (!isSourceFile(filePath, fileInfo)) continue;
        const dir = path.dirname(filePath);
        const basename = path.basename(filePath, path.extname(filePath));
        const pattern = classifyName(basename);
        if (pattern === "single-word") continue;
        if (!byDir[dir]) byDir[dir] = {};
        if (!byDir[dir][pattern]) byDir[dir][pattern] = [];
        byDir[dir][pattern].push(basename);
        if (!allNames[pattern]) allNames[pattern] = [];
        allNames[pattern].push(basename);
      }
      const totalMultiWord = Object.values(allNames).reduce((sum, arr) => sum + arr.length, 0);
      const overall = {};
      for (const [pattern, names] of Object.entries(allNames)) {
        overall[pattern] = {
          pattern,
          confidence: totalMultiWord > 0 ? Math.round(names.length / totalMultiWord * 100) : 0,
          file_count: names.length,
          examples: names.slice(0, 3)
        };
      }
      const byDirectory = {};
      for (const [dir, patterns] of Object.entries(byDir)) {
        const dirTotal = Object.values(patterns).reduce((sum, arr) => sum + arr.length, 0);
        if (dirTotal < 2) continue;
        let dominant = null;
        let maxCount = 0;
        for (const [pattern, names] of Object.entries(patterns)) {
          if (names.length > maxCount) {
            maxCount = names.length;
            dominant = pattern;
          }
        }
        byDirectory[dir] = {
          dominant_pattern: dominant,
          confidence: Math.round(maxCount / dirTotal * 100),
          file_count: dirTotal,
          patterns: {}
        };
        for (const [pattern, names] of Object.entries(patterns)) {
          byDirectory[dir].patterns[pattern] = {
            count: names.length,
            examples: names.slice(0, 3)
          };
        }
      }
      return { overall, by_directory: byDirectory };
    }
    function detectFileOrganization(intel) {
      if (!intel || !intel.files) {
        return { structure_type: "unknown", patterns: [] };
      }
      const filePaths = Object.keys(intel.files);
      const patterns = [];
      const depths = filePaths.map((f) => f.split(path.sep).length);
      const maxDepth = Math.max(...depths, 0);
      const avgDepth = depths.length > 0 ? Math.round(depths.reduce((a, b) => a + b, 0) / depths.length * 10) / 10 : 0;
      const structureType = maxDepth <= 2 ? "flat" : "nested";
      patterns.push({
        pattern: `${structureType} structure`,
        detail: `max depth ${maxDepth}, avg depth ${avgDepth}`,
        confidence: 100
      });
      const topDirs = /* @__PURE__ */ new Set();
      for (const fp of filePaths) {
        const parts = fp.split(path.sep);
        if (parts.length > 1) topDirs.add(parts[0]);
      }
      const knownGroupings = {
        "by-type": ["commands", "lib", "models", "controllers", "views", "services", "utils", "helpers"],
        "by-feature": ["features", "modules", "domains", "pages"]
      };
      let groupingType = "unknown";
      let groupingConfidence = 0;
      const topDirList = [...topDirs];
      const byTypeMatches = topDirList.filter((d) => knownGroupings["by-type"].includes(d));
      const byFeatureMatches = topDirList.filter((d) => knownGroupings["by-feature"].includes(d));
      if (byTypeMatches.length > byFeatureMatches.length) {
        groupingType = "by-type";
        groupingConfidence = Math.round(byTypeMatches.length / Math.max(topDirList.length, 1) * 100);
      } else if (byFeatureMatches.length > 0) {
        groupingType = "by-feature";
        groupingConfidence = Math.round(byFeatureMatches.length / Math.max(topDirList.length, 1) * 100);
      }
      if (groupingType !== "unknown") {
        patterns.push({
          pattern: `${groupingType} grouping`,
          detail: `detected from top-level directories: ${topDirList.join(", ")}`,
          confidence: groupingConfidence
        });
      }
      const testFiles = filePaths.filter((f) => {
        const base = path.basename(f);
        return base.includes(".test.") || base.includes(".spec.") || base.includes("_test.") || base.includes("_spec.");
      });
      const testDirFiles = filePaths.filter((f) => {
        const parts = f.split(path.sep);
        return parts.some((p) => p === "test" || p === "tests" || p === "spec" || p === "__tests__");
      });
      let testPlacement = "none";
      let testConfidence = 0;
      if (testFiles.length > 0 && testDirFiles.length > 0) {
        if (testFiles.length > testDirFiles.length) {
          testPlacement = "co-located";
          testConfidence = Math.round(testFiles.length / (testFiles.length + testDirFiles.length) * 100);
        } else {
          testPlacement = "separate-directory";
          testConfidence = Math.round(testDirFiles.length / (testFiles.length + testDirFiles.length) * 100);
        }
      } else if (testFiles.length > 0) {
        testPlacement = "co-located";
        testConfidence = 100;
      } else if (testDirFiles.length > 0) {
        testPlacement = "separate-directory";
        testConfidence = 100;
      }
      if (testPlacement !== "none") {
        patterns.push({
          pattern: `${testPlacement} tests`,
          detail: `${testFiles.length} co-located, ${testDirFiles.length} in test dirs`,
          confidence: testConfidence
        });
      }
      const configExtensions = /* @__PURE__ */ new Set([".json", ".yaml", ".yml", ".toml", ".env", ".ini", ".cfg"]);
      const configNames = /* @__PURE__ */ new Set(["config", "settings", "configuration", ".env", ".eslintrc", ".prettierrc", "tsconfig", "jest.config", "webpack.config", "vite.config"]);
      const configFiles = filePaths.filter((f) => {
        const base = path.basename(f);
        const ext = path.extname(f);
        const nameNoExt = path.basename(f, ext);
        return configExtensions.has(ext) && f.split(path.sep).length <= 2 || configNames.has(nameNoExt) || base.startsWith(".");
      });
      const rootConfigs = configFiles.filter((f) => f.split(path.sep).length === 1);
      if (configFiles.length > 0) {
        const configPlacement = rootConfigs.length > configFiles.length / 2 ? "root" : "config-directory";
        patterns.push({
          pattern: `${configPlacement} config placement`,
          detail: `${rootConfigs.length}/${configFiles.length} config files at root`,
          confidence: Math.round(rootConfigs.length / Math.max(configFiles.length, 1) * 100)
        });
      }
      const indexFiles = filePaths.filter((f) => {
        const base = path.basename(f);
        return base.startsWith("index.") || base.startsWith("mod.") || base.startsWith("__init__.");
      });
      if (indexFiles.length > 0) {
        const dirsWithSource = new Set(filePaths.filter((f) => {
          const info = intel.files[f];
          return isSourceFile(f, info);
        }).map((f) => path.dirname(f)));
        const barrelConfidence = Math.round(indexFiles.length / Math.max(dirsWithSource.size, 1) * 100);
        patterns.push({
          pattern: "barrel/index exports",
          detail: `${indexFiles.length} index files across ${dirsWithSource.size} source dirs`,
          confidence: Math.min(barrelConfidence, 100)
        });
      }
      return {
        structure_type: structureType,
        max_depth: maxDepth,
        avg_depth: avgDepth,
        test_placement: testPlacement,
        patterns
      };
    }
    function safeReadFile(filePath) {
      try {
        return fs.readFileSync(filePath, "utf-8");
      } catch (e) {
        return "";
      }
    }
    var FRAMEWORK_DETECTORS = [
      {
        name: "elixir-phoenix",
        /**
         * Detect if this project uses Elixir/Phoenix.
         * Checks for Elixir language presence and Phoenix indicators (router.ex, mix.exs).
         */
        detect(intel) {
          if (!intel || !intel.languages) return false;
          if (!intel.languages.elixir) return false;
          const filePaths = Object.keys(intel.files || {});
          const hasRouter = filePaths.some((f) => f.endsWith("router.ex"));
          const hasMixExs = filePaths.some((f) => f === "mix.exs" || f.endsWith("/mix.exs"));
          return hasRouter || hasMixExs;
        },
        /**
         * Extract Elixir/Phoenix-specific convention patterns.
         */
        extractPatterns(intel, cwd) {
          const patterns = [];
          const filePaths = Object.keys(intel.files || {});
          const routerFiles = filePaths.filter((f) => f.endsWith("router.ex"));
          if (routerFiles.length > 0) {
            let routeEvidence = [];
            let hasPipeThrough = false;
            for (const rf of routerFiles) {
              const content = safeReadFile(path.join(cwd, rf));
              if (/pipe_through/.test(content)) hasPipeThrough = true;
              if (/\b(get|post|put|delete|patch)\s/.test(content)) {
                routeEvidence.push(rf);
              }
            }
            if (routeEvidence.length > 0) {
              patterns.push({
                category: "framework",
                framework: "elixir-phoenix",
                pattern: hasPipeThrough ? "Routes defined in router.ex using pipe_through pipelines" : "Routes defined in router.ex",
                confidence: Math.round(routeEvidence.length / Math.max(routerFiles.length, 1) * 100),
                evidence: routeEvidence.slice(0, 5)
              });
            }
          }
          const schemaFiles = filePaths.filter((f) => f.endsWith(".ex") || f.endsWith(".exs"));
          const ectoSchemaFiles = [];
          for (const sf of schemaFiles) {
            const content = safeReadFile(path.join(cwd, sf));
            if (/use Ecto\.Schema/.test(content)) {
              ectoSchemaFiles.push(sf);
            }
          }
          if (ectoSchemaFiles.length > 0) {
            patterns.push({
              category: "framework",
              framework: "elixir-phoenix",
              pattern: "Ecto schemas use `schema` macro with `field` declarations",
              confidence: Math.round(ectoSchemaFiles.length / Math.max(schemaFiles.length, 1) * 100),
              evidence: ectoSchemaFiles.slice(0, 5)
            });
          }
          const plugFiles = [];
          for (const sf of schemaFiles) {
            const content = safeReadFile(path.join(cwd, sf));
            if (/use Plug\b/.test(content) || /import Plug\.Conn/.test(content)) {
              plugFiles.push(sf);
            }
          }
          if (plugFiles.length > 0) {
            patterns.push({
              category: "framework",
              framework: "elixir-phoenix",
              pattern: "Plugs follow init/call pattern",
              confidence: Math.round(plugFiles.length / Math.max(schemaFiles.length, 1) * 100),
              evidence: plugFiles.slice(0, 5)
            });
          }
          const libDirs = /* @__PURE__ */ new Set();
          for (const fp of filePaths) {
            const match = fp.match(/^lib\/([^/]+)\//);
            if (match) libDirs.add(match[1]);
          }
          if (libDirs.size > 1) {
            patterns.push({
              category: "framework",
              framework: "elixir-phoenix",
              pattern: "Business logic organized into context modules",
              confidence: Math.min(Math.round(libDirs.size / 3 * 100), 100),
              evidence: [...libDirs].slice(0, 5).map((d) => `lib/${d}/`)
            });
          }
          const migrationFiles = filePaths.filter(
            (f) => f.includes("priv/repo/migrations/") || f.match(/priv\/[^/]*\/migrations\//)
          );
          if (migrationFiles.length > 0) {
            const timestampMigrations = migrationFiles.filter(
              (f) => /\d{14}_/.test(path.basename(f))
            );
            patterns.push({
              category: "framework",
              framework: "elixir-phoenix",
              pattern: "Migrations use timestamp prefixes",
              confidence: Math.round(timestampMigrations.length / Math.max(migrationFiles.length, 1) * 100),
              evidence: migrationFiles.slice(0, 5)
            });
          }
          return patterns;
        }
      }
    ];
    function detectFrameworkConventions(intel, cwd) {
      const allPatterns = [];
      for (const detector of FRAMEWORK_DETECTORS) {
        try {
          if (detector.detect(intel)) {
            const patterns = detector.extractPatterns(intel, cwd);
            allPatterns.push(...patterns);
          }
        } catch (e) {
        }
      }
      return allPatterns;
    }
    function extractConventions(intel, options = {}) {
      const { threshold = 60, showAll = false, cwd = process.cwd() } = options;
      const naming = detectNamingConventions(intel);
      const fileOrganization = detectFileOrganization(intel);
      const frameworkPatterns = detectFrameworkConventions(intel, cwd);
      const filteredNaming = { ...naming };
      if (!showAll) {
        filteredNaming.overall = {};
        for (const [key, value] of Object.entries(naming.overall)) {
          if (value.confidence >= threshold) {
            filteredNaming.overall[key] = value;
          }
        }
        filteredNaming.by_directory = {};
        for (const [dir, value] of Object.entries(naming.by_directory)) {
          if (value.confidence >= threshold) {
            filteredNaming.by_directory[dir] = value;
          }
        }
      }
      const filteredFileOrg = { ...fileOrganization };
      if (!showAll) {
        filteredFileOrg.patterns = fileOrganization.patterns.filter((p) => p.confidence >= threshold);
      }
      const filteredFrameworks = showAll ? frameworkPatterns : frameworkPatterns.filter((p) => p.confidence >= threshold);
      return {
        naming: filteredNaming,
        file_organization: filteredFileOrg,
        frameworks: filteredFrameworks,
        extracted_at: (/* @__PURE__ */ new Date()).toISOString()
      };
    }
    function generateRules(conventions, options = {}) {
      const { threshold = 60, maxRules = 15 } = options;
      if (!conventions) {
        return { rules: [], rules_text: "", rule_count: 0, total_conventions: 0, filtered_count: 0 };
      }
      const allConventions = [];
      if (conventions.naming && conventions.naming.overall) {
        for (const [, value] of Object.entries(conventions.naming.overall)) {
          if (value.confidence > 0) {
            allConventions.push({
              text: `File names use ${value.pattern} (${value.confidence}% of ${value.file_count} multi-word files)`,
              confidence: value.confidence
            });
          }
        }
      }
      if (conventions.naming && conventions.naming.by_directory) {
        for (const [dir, value] of Object.entries(conventions.naming.by_directory)) {
          if (value.confidence > 0) {
            allConventions.push({
              text: `File names in \`${dir}/\` use ${value.dominant_pattern} (${value.confidence}% of ${value.file_count} files)`,
              confidence: value.confidence
            });
          }
        }
      }
      if (conventions.file_organization && conventions.file_organization.patterns) {
        for (const p of conventions.file_organization.patterns) {
          if (p.confidence > 0) {
            allConventions.push({
              text: `Project uses ${p.pattern} (${p.detail})`,
              confidence: p.confidence
            });
          }
        }
      }
      if (conventions.frameworks) {
        for (const p of conventions.frameworks) {
          if (p.confidence > 0) {
            allConventions.push({
              text: `${p.pattern} (${p.confidence}%)`,
              confidence: p.confidence
            });
          }
        }
      }
      const totalConventions = allConventions.length;
      const filtered = allConventions.filter((c) => c.confidence >= threshold);
      const filteredCount = totalConventions - filtered.length;
      filtered.sort((a, b) => {
        if (b.confidence !== a.confidence) return b.confidence - a.confidence;
        return a.text.localeCompare(b.text);
      });
      const capped = filtered.slice(0, maxRules);
      const rules = capped.map((c) => c.text);
      const rulesText = rules.map((r, i) => `${i + 1}. ${r}`).join("\n");
      return {
        rules,
        rules_text: rulesText,
        rule_count: rules.length,
        total_conventions: totalConventions,
        filtered_count: filteredCount
      };
    }
    module2.exports = {
      detectNamingConventions,
      detectFileOrganization,
      detectFrameworkConventions,
      extractConventions,
      generateRules,
      FRAMEWORK_DETECTORS
    };
  }
});

// src/lib/deps.js
var require_deps = __commonJS({
  "src/lib/deps.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var { debugLog } = require_output();
    var { readIntel } = require_codebase_intel();
    function parseJavaScript(content) {
      const imports = [];
      let stripped = content.replace(/\/\*[\s\S]*?\*\//g, "");
      stripped = stripped.replace(/\/\/[^\n]*/g, "");
      const requireRe = /\brequire\s*\(\s*['"]([^'"]+)['"]\s*\)/g;
      let m;
      while ((m = requireRe.exec(stripped)) !== null) {
        imports.push(m[1]);
      }
      const importFromRe = /\b(?:import|export)\s+[\s\S]*?\s+from\s+['"]([^'"]+)['"]/g;
      while ((m = importFromRe.exec(stripped)) !== null) {
        imports.push(m[1]);
      }
      const sideEffectRe = /\bimport\s+['"]([^'"]+)['"]/g;
      while ((m = sideEffectRe.exec(stripped)) !== null) {
        imports.push(m[1]);
      }
      const dynamicRe = /\bimport\s*\(\s*['"]([^'"]+)['"]\s*\)/g;
      while ((m = dynamicRe.exec(stripped)) !== null) {
        imports.push(m[1]);
      }
      return [...new Set(imports)];
    }
    function parsePython(content) {
      const imports = [];
      const stripped = content.replace(/#[^\n]*/g, "");
      const fromImportRe = /^\s*from\s+(\.{0,3}[\w.]*)\s+import\b/gm;
      let m;
      while ((m = fromImportRe.exec(stripped)) !== null) {
        imports.push(m[1]);
      }
      const importRe = /^\s*import\s+([\w.]+(?:\s*,\s*[\w.]+)*)/gm;
      while ((m = importRe.exec(stripped)) !== null) {
        const modules = m[1].split(",").map((s) => s.trim().split(/\s+as\s+/)[0].trim());
        for (const mod of modules) {
          if (mod) imports.push(mod);
        }
      }
      return [...new Set(imports)];
    }
    function parseGo(content) {
      const imports = [];
      let stripped = content.replace(/\/\*[\s\S]*?\*\//g, "");
      stripped = stripped.replace(/\/\/[^\n]*/g, "");
      const singleRe = /\bimport\s+"([^"]+)"/g;
      let m;
      while ((m = singleRe.exec(stripped)) !== null) {
        imports.push(m[1]);
      }
      const groupRe = /\bimport\s*\(([\s\S]*?)\)/g;
      while ((m = groupRe.exec(stripped)) !== null) {
        const block = m[1];
        const pathRe = /"([^"]+)"/g;
        let pm;
        while ((pm = pathRe.exec(block)) !== null) {
          imports.push(pm[1]);
        }
      }
      return [...new Set(imports)];
    }
    function parseElixir(content) {
      const imports = [];
      const stripped = content.replace(/#[^\n]*/g, "");
      const simpleRe = /^\s*(?:alias|import|use|require)\s+([A-Z][\w.]*)/gm;
      let m;
      while ((m = simpleRe.exec(stripped)) !== null) {
        imports.push(m[1]);
      }
      const multiRe = /^\s*alias\s+([A-Z][\w.]*)\.\{([^}]+)\}/gm;
      while ((m = multiRe.exec(stripped)) !== null) {
        const base = m[1];
        const parts = m[2].split(",").map((s) => s.trim());
        for (const part of parts) {
          if (part) imports.push(`${base}.${part}`);
        }
      }
      return [...new Set(imports)];
    }
    function parseRust(content) {
      const imports = [];
      let stripped = content.replace(/\/\*[\s\S]*?\*\//g, "");
      stripped = stripped.replace(/\/\/[^\n]*/g, "");
      const useRe = /\buse\s+([\w:]+(?:::[\w:{}*,\s]+)?)/g;
      let m;
      while ((m = useRe.exec(stripped)) !== null) {
        const fullPath = m[1].split("{")[0].replace(/::$/, "");
        imports.push(fullPath);
      }
      const modRe = /\bmod\s+(\w+)\s*;/g;
      while ((m = modRe.exec(stripped)) !== null) {
        imports.push(m[1]);
      }
      const externRe = /\bextern\s+crate\s+(\w+)/g;
      while ((m = externRe.exec(stripped)) !== null) {
        imports.push(m[1]);
      }
      return [...new Set(imports)];
    }
    var IMPORT_PARSERS = {
      javascript: parseJavaScript,
      typescript: parseJavaScript,
      // Same syntax
      python: parsePython,
      go: parseGo,
      elixir: parseElixir,
      rust: parseRust
    };
    function buildFileSet(intel) {
      return new Set(Object.keys(intel.files || {}));
    }
    function resolveJsImport(specifier, fromFile, fileSet) {
      if (!specifier.startsWith(".")) return null;
      const dir = path.dirname(fromFile);
      const base = path.join(dir, specifier);
      const normalized = base.split(path.sep).join("/");
      const candidates = [
        normalized,
        normalized + ".js",
        normalized + ".ts",
        normalized + ".tsx",
        normalized + ".jsx",
        normalized + ".cjs",
        normalized + ".mjs",
        normalized + "/index.js",
        normalized + "/index.ts",
        normalized + "/index.tsx"
      ];
      for (const candidate of candidates) {
        if (fileSet.has(candidate)) return candidate;
      }
      return null;
    }
    function resolvePythonImport(specifier, fromFile, fileSet) {
      let modulePath;
      if (specifier.startsWith(".")) {
        const dir = path.dirname(fromFile);
        const dots = specifier.match(/^(\.+)/)[1];
        const levels = dots.length - 1;
        let baseDir = dir;
        for (let i = 0; i < levels; i++) {
          baseDir = path.dirname(baseDir);
        }
        const rest = specifier.slice(dots.length).replace(/\./g, "/");
        modulePath = rest ? path.join(baseDir, rest) : baseDir;
      } else {
        modulePath = specifier.replace(/\./g, "/");
      }
      const normalized = modulePath.split(path.sep).join("/");
      const candidates = [
        normalized + ".py",
        normalized + "/__init__.py",
        normalized + ".pyi"
      ];
      for (const candidate of candidates) {
        if (fileSet.has(candidate)) return candidate;
      }
      return null;
    }
    function resolveElixirImport(specifier, fromFile, fileSet, intel) {
      const parts = specifier.split(".");
      const pathParts = parts.map(
        (p) => p.replace(
          /([A-Z])/g,
          (match, letter, offset) => (offset > 0 ? "_" : "") + letter.toLowerCase()
        )
      );
      const fullPath = pathParts.join("/");
      const withoutApp = pathParts.slice(1).join("/");
      const candidates = [];
      for (const base of [fullPath, withoutApp]) {
        if (!base) continue;
        candidates.push(`lib/${base}.ex`);
        candidates.push(`${base}.ex`);
        candidates.push(`lib/${base}/index.ex`);
      }
      for (const candidate of candidates) {
        if (fileSet.has(candidate)) return candidate;
      }
      return null;
    }
    function resolveGoImport(specifier, fromFile, fileSet) {
      const pkgName = specifier.split("/").pop();
      if (!pkgName) return null;
      for (const file of fileSet) {
        if (file.endsWith(".go")) {
          const dir = path.dirname(file);
          const dirName = path.basename(dir);
          if (dirName === pkgName) return file;
        }
      }
      return null;
    }
    function resolveRustImport(specifier, fromFile, fileSet) {
      let modulePath;
      if (specifier.startsWith("crate")) {
        const rest = specifier.replace(/^crate::?/, "").replace(/::/g, "/");
        modulePath = "src/" + rest;
      } else if (specifier.startsWith("super")) {
        const dir = path.dirname(fromFile);
        const supers = specifier.match(/^(super::)*/)[0];
        const levels = (supers.match(/super/g) || []).length;
        let baseDir = dir;
        for (let i = 0; i < levels; i++) {
          baseDir = path.dirname(baseDir);
        }
        const rest = specifier.replace(/^(super::)+/, "").replace(/::/g, "/");
        modulePath = rest ? path.join(baseDir, rest) : baseDir;
      } else {
        return null;
      }
      const normalized = modulePath.split(path.sep).join("/");
      const candidates = [
        normalized + ".rs",
        normalized + "/mod.rs"
      ];
      for (const candidate of candidates) {
        if (fileSet.has(candidate)) return candidate;
      }
      return null;
    }
    function parseImports(filePath, content, language, fileSet, intel) {
      const parser = IMPORT_PARSERS[language];
      if (!parser) return [];
      const rawImports = parser(content);
      return rawImports.map((raw) => {
        let resolved = null;
        switch (language) {
          case "javascript":
          case "typescript":
            resolved = resolveJsImport(raw, filePath, fileSet);
            break;
          case "python":
            resolved = resolvePythonImport(raw, filePath, fileSet);
            break;
          case "go":
            resolved = resolveGoImport(raw, filePath, fileSet);
            break;
          case "elixir":
            resolved = resolveElixirImport(raw, filePath, fileSet, intel);
            break;
          case "rust":
            resolved = resolveRustImport(raw, filePath, fileSet);
            break;
        }
        return { raw, resolved };
      });
    }
    function buildDependencyGraph(intel) {
      const forward = {};
      const reverse = {};
      const languagesParsed = /* @__PURE__ */ new Set();
      let totalEdges = 0;
      let totalFilesParsed = 0;
      let parseErrors = 0;
      const fileSet = buildFileSet(intel);
      const files = intel.files || {};
      for (const [filePath, fileInfo] of Object.entries(files)) {
        const language = fileInfo.language;
        if (!language || !IMPORT_PARSERS[language]) continue;
        totalFilesParsed++;
        languagesParsed.add(language);
        let content;
        try {
          const absPath = path.resolve(filePath);
          content = fs.readFileSync(absPath, "utf8");
        } catch (e) {
          debugLog("deps.buildGraph", `read error: ${filePath}: ${e.message}`);
          parseErrors++;
          continue;
        }
        try {
          const imports = parseImports(filePath, content, language, fileSet, intel);
          const resolvedTargets = [];
          for (const imp of imports) {
            if (imp.resolved) {
              resolvedTargets.push(imp.resolved);
              if (!reverse[imp.resolved]) {
                reverse[imp.resolved] = [];
              }
              if (!reverse[imp.resolved].includes(filePath)) {
                reverse[imp.resolved].push(filePath);
              }
              totalEdges++;
            }
          }
          if (resolvedTargets.length > 0) {
            forward[filePath] = [...new Set(resolvedTargets)];
          }
        } catch (e) {
          debugLog("deps.buildGraph", `parse error: ${filePath}: ${e.message}`);
          parseErrors++;
        }
      }
      return {
        forward,
        reverse,
        stats: {
          total_files_parsed: totalFilesParsed,
          total_edges: totalEdges,
          languages_parsed: [...languagesParsed].sort(),
          parse_errors: parseErrors
        },
        built_at: (/* @__PURE__ */ new Date()).toISOString()
      };
    }
    function findCycles(graph) {
      const forward = graph.forward || {};
      let index = 0;
      const stack = [];
      const onStack = /* @__PURE__ */ new Set();
      const indices = {};
      const lowlinks = {};
      const sccs = [];
      function strongConnect(v) {
        indices[v] = index;
        lowlinks[v] = index;
        index++;
        stack.push(v);
        onStack.add(v);
        const neighbors = forward[v] || [];
        for (const w of neighbors) {
          if (indices[w] === void 0) {
            strongConnect(w);
            lowlinks[v] = Math.min(lowlinks[v], lowlinks[w]);
          } else if (onStack.has(w)) {
            lowlinks[v] = Math.min(lowlinks[v], indices[w]);
          }
        }
        if (lowlinks[v] === indices[v]) {
          const scc = [];
          let w;
          do {
            w = stack.pop();
            onStack.delete(w);
            scc.push(w);
          } while (w !== v);
          if (scc.length >= 2) {
            sccs.push(scc);
          }
        }
      }
      const allNodes = new Set(Object.keys(forward));
      for (const targets of Object.values(forward)) {
        for (const t of targets) allNodes.add(t);
      }
      for (const node of allNodes) {
        if (indices[node] === void 0) {
          strongConnect(node);
        }
      }
      sccs.sort((a, b) => b.length - a.length);
      const filesInCycles = /* @__PURE__ */ new Set();
      for (const scc of sccs) {
        for (const f of scc) filesInCycles.add(f);
      }
      return {
        cycles: sccs,
        cycle_count: sccs.length,
        files_in_cycles: filesInCycles.size
      };
    }
    function getTransitiveDependents(graph, filePath, maxDepth = 10) {
      const reverse = graph.reverse || {};
      const visited = /* @__PURE__ */ new Set();
      const directDependents = [];
      const transitiveDependents = [];
      let maxDepthReached = 0;
      const queue = [[filePath, 0]];
      visited.add(filePath);
      while (queue.length > 0) {
        const [current, depth] = queue.shift();
        if (depth > maxDepth) continue;
        const dependents = reverse[current] || [];
        for (const dep of dependents) {
          if (visited.has(dep)) continue;
          visited.add(dep);
          const depDepth = depth + 1;
          if (depDepth > maxDepthReached) maxDepthReached = depDepth;
          if (depDepth === 1) {
            directDependents.push(dep);
          } else {
            transitiveDependents.push({ file: dep, depth: depDepth });
          }
          if (depDepth < maxDepth) {
            queue.push([dep, depDepth]);
          }
        }
      }
      transitiveDependents.sort((a, b) => a.depth - b.depth);
      return {
        file: filePath,
        direct_dependents: directDependents,
        transitive_dependents: transitiveDependents,
        fan_in: directDependents.length + transitiveDependents.length,
        max_depth_reached: maxDepthReached
      };
    }
    module2.exports = {
      IMPORT_PARSERS,
      parseImports,
      buildDependencyGraph,
      findCycles,
      getTransitiveDependents,
      // Expose individual parsers for testing
      parseJavaScript,
      parsePython,
      parseGo,
      parseElixir,
      parseRust
    };
  }
});

// src/lib/lifecycle.js
var require_lifecycle = __commonJS({
  "src/lib/lifecycle.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var { debugLog } = require_output();
    var { findCycles } = require_deps();
    var MIGRATION_DIR_RE = /(?:^|\/)(migrations|db\/migrate|priv\/[^/]*\/migrations)\//;
    var MAX_MIGRATION_NODES = 20;
    function classifyMigrationPrefix(basename) {
      if (/^\d{14}[_-]/.test(basename)) return 95;
      if (/^\d{8}[_-]/.test(basename)) return 85;
      if (/^\d{1,4}[_-]/.test(basename)) return 90;
      return 70;
    }
    var LIFECYCLE_DETECTORS = [
      // â”€â”€â”€ Generic Migration Detector â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      {
        name: "generic-migrations",
        /**
         * Detect if this codebase has migration directories.
         */
        detect(intel) {
          var filePaths = Object.keys(intel.files || {});
          return filePaths.some(function(f) {
            return MIGRATION_DIR_RE.test(f);
          });
        },
        /**
         * Extract lifecycle nodes from migration directories.
         * Builds sequential chains: each migration depends on the previous one.
         */
        extractLifecycle(intel, cwd) {
          var filePaths = Object.keys(intel.files || {});
          var migrationDirs = /* @__PURE__ */ new Set();
          for (var i = 0; i < filePaths.length; i++) {
            var f = filePaths[i];
            if (MIGRATION_DIR_RE.test(f)) {
              var dir = f.replace(/\/[^/]+$/, "");
              migrationDirs.add(dir);
            }
          }
          var nodes = [];
          migrationDirs.forEach(function(dir2) {
            var dirFiles = filePaths.filter(function(fp) {
              if (!fp.startsWith(dir2 + "/")) return false;
              var rest = fp.slice(dir2.length + 1);
              return !rest.includes("/");
            }).sort();
            var capped = false;
            var cappedCount = 0;
            if (dirFiles.length > MAX_MIGRATION_NODES) {
              cappedCount = dirFiles.length - MAX_MIGRATION_NODES;
              dirFiles = dirFiles.slice(dirFiles.length - MAX_MIGRATION_NODES);
              capped = true;
            }
            var prevId = null;
            for (var j = 0; j < dirFiles.length; j++) {
              var file = dirFiles[j];
              var basename = path.basename(file);
              var nameNoExt = basename.replace(/\.[^.]+$/, "");
              var confidence = classifyMigrationPrefix(basename);
              var id = "migration:" + nameNoExt;
              var node = {
                id,
                file_or_step: file,
                type: "migration",
                must_run_before: [],
                must_run_after: prevId ? [prevId] : [],
                framework: "generic",
                confidence
              };
              if (prevId) {
                var prevNode = nodes.find(function(n) {
                  return n.id === prevId;
                });
                if (prevNode) prevNode.must_run_before.push(id);
              }
              nodes.push(node);
              prevId = id;
            }
            if (capped && nodes.length > 0) {
              var firstKeptId = nodes[nodes.length - dirFiles.length].id;
              var summaryNode = {
                id: "migration:earlier-" + cappedCount,
                file_or_step: "... and " + cappedCount + " earlier migrations",
                type: "migration",
                must_run_before: [firstKeptId],
                must_run_after: [],
                framework: "generic",
                confidence: 0
              };
              nodes.unshift(summaryNode);
            }
          });
          return nodes;
        }
      },
      // â”€â”€â”€ Elixir/Phoenix Detector â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      {
        name: "elixir-phoenix",
        /**
         * Detect if this codebase uses Elixir/Phoenix.
         * Gates on framework detection from Phase 24 conventions.
         */
        detect(intel) {
          if (!intel.conventions || !intel.conventions.frameworks) return false;
          return intel.conventions.frameworks.some(function(f) {
            return f.framework === "elixir-phoenix";
          });
        },
        /**
         * Extract Elixir/Phoenix lifecycle nodes.
         * Detects: config ordering, application boot, seedâ†’migration dependency, router compilation.
         */
        extractLifecycle(intel, cwd) {
          var filePaths = Object.keys(intel.files || {});
          var nodes = [];
          var configExs = filePaths.find(function(f) {
            return f === "config/config.exs";
          });
          var runtimeExs = filePaths.find(function(f) {
            return f === "config/runtime.exs";
          });
          if (configExs) {
            nodes.push({
              id: "config:compile-time",
              file_or_step: configExs,
              type: "config",
              must_run_before: [],
              must_run_after: [],
              framework: "elixir-phoenix",
              confidence: 95
            });
          }
          if (runtimeExs) {
            nodes.push({
              id: "config:runtime",
              file_or_step: runtimeExs,
              type: "config",
              must_run_before: [],
              must_run_after: configExs ? ["config:compile-time"] : [],
              framework: "elixir-phoenix",
              confidence: 90
            });
          }
          var appFile = filePaths.find(function(f) {
            return /lib\/[^/]+\/application\.ex$/.test(f);
          });
          if (appFile) {
            var bootAfter = [];
            if (configExs) bootAfter.push("config:compile-time");
            if (runtimeExs) bootAfter.push("config:runtime");
            nodes.push({
              id: "boot:application",
              file_or_step: appFile,
              type: "boot",
              must_run_before: [],
              must_run_after: bootAfter,
              framework: "elixir-phoenix",
              confidence: 95
            });
            if (configExs) {
              var configNode = nodes.find(function(n) {
                return n.id === "config:compile-time";
              });
              if (configNode) configNode.must_run_before.push("boot:application");
            }
            if (runtimeExs) {
              var runtimeNode = nodes.find(function(n) {
                return n.id === "config:runtime";
              });
              if (runtimeNode) runtimeNode.must_run_before.push("boot:application");
            }
          }
          var seedFile = filePaths.find(function(f) {
            return /seeds\.exs$/.test(f);
          });
          var migrationFiles = filePaths.filter(function(f) {
            return /priv\/[^/]*\/migrations\//.test(f);
          });
          if (seedFile && migrationFiles.length > 0) {
            var sortedMigrations = migrationFiles.slice().sort();
            var lastMigrationBasename = path.basename(sortedMigrations[sortedMigrations.length - 1]);
            var lastMigrationId = "migration:" + lastMigrationBasename.replace(/\.[^.]+$/, "");
            nodes.push({
              id: "seed:seeds",
              file_or_step: seedFile,
              type: "seed",
              must_run_before: [],
              must_run_after: [lastMigrationId],
              framework: "elixir-phoenix",
              confidence: 90
            });
          }
          var routerFile = filePaths.find(function(f) {
            return /router\.ex$/.test(f);
          });
          if (routerFile && appFile) {
            nodes.push({
              id: "compilation:router",
              file_or_step: routerFile,
              type: "compilation",
              must_run_before: [],
              must_run_after: ["boot:application"],
              framework: "elixir-phoenix",
              confidence: 85
            });
            var bootNode = nodes.find(function(n) {
              return n.id === "boot:application";
            });
            if (bootNode) bootNode.must_run_before.push("compilation:router");
          }
          return nodes;
        }
      }
    ];
    function mergeNodes(nodes) {
      var byFile = {};
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        var key = node.file_or_step;
        if (!byFile[key]) {
          byFile[key] = node;
        } else {
          if (node.confidence > byFile[key].confidence) {
            var old = byFile[key];
            for (var j = 0; j < old.must_run_before.length; j++) {
              if (node.must_run_before.indexOf(old.must_run_before[j]) === -1) {
                node.must_run_before.push(old.must_run_before[j]);
              }
            }
            for (var k = 0; k < old.must_run_after.length; k++) {
              if (node.must_run_after.indexOf(old.must_run_after[k]) === -1) {
                node.must_run_after.push(old.must_run_after[k]);
              }
            }
            byFile[key] = node;
          } else {
            var existing = byFile[key];
            for (var j2 = 0; j2 < node.must_run_before.length; j2++) {
              if (existing.must_run_before.indexOf(node.must_run_before[j2]) === -1) {
                existing.must_run_before.push(node.must_run_before[j2]);
              }
            }
            for (var k2 = 0; k2 < node.must_run_after.length; k2++) {
              if (existing.must_run_after.indexOf(node.must_run_after[k2]) === -1) {
                existing.must_run_after.push(node.must_run_after[k2]);
              }
            }
          }
        }
      }
      return Object.values(byFile);
    }
    function enforceSymmetry(nodes) {
      var nodeMap = {};
      for (var i = 0; i < nodes.length; i++) {
        nodeMap[nodes[i].id] = nodes[i];
      }
      for (var j = 0; j < nodes.length; j++) {
        var node = nodes[j];
        for (var k = 0; k < node.must_run_after.length; k++) {
          var beforeId = node.must_run_after[k];
          var beforeNode = nodeMap[beforeId];
          if (beforeNode && beforeNode.must_run_before.indexOf(node.id) === -1) {
            beforeNode.must_run_before.push(node.id);
          }
        }
        for (var m = 0; m < node.must_run_before.length; m++) {
          var afterId = node.must_run_before[m];
          var afterNode = nodeMap[afterId];
          if (afterNode && afterNode.must_run_after.indexOf(node.id) === -1) {
            afterNode.must_run_after.push(node.id);
          }
        }
      }
    }
    function buildChains(nodes) {
      if (nodes.length === 0) return [];
      var nodeMap = {};
      for (var i = 0; i < nodes.length; i++) {
        nodeMap[nodes[i].id] = nodes[i];
      }
      var adjacency = {};
      var inDegree = {};
      for (var j = 0; j < nodes.length; j++) {
        var node = nodes[j];
        if (!adjacency[node.id]) adjacency[node.id] = [];
        if (inDegree[node.id] === void 0) inDegree[node.id] = 0;
        for (var k = 0; k < node.must_run_before.length; k++) {
          var target = node.must_run_before[k];
          adjacency[node.id].push(target);
          if (inDegree[target] === void 0) inDegree[target] = 0;
          inDegree[target]++;
          if (!adjacency[target]) adjacency[target] = [];
        }
      }
      var visited = /* @__PURE__ */ new Set();
      var components = [];
      function bfsComponent(start) {
        var comp2 = /* @__PURE__ */ new Set();
        var q = [start];
        comp2.add(start);
        while (q.length > 0) {
          var cur = q.shift();
          var fwd = adjacency[cur] || [];
          for (var fi = 0; fi < fwd.length; fi++) {
            if (!comp2.has(fwd[fi])) {
              comp2.add(fwd[fi]);
              q.push(fwd[fi]);
            }
          }
          var curNode = nodeMap[cur];
          if (curNode) {
            for (var ri = 0; ri < curNode.must_run_after.length; ri++) {
              var prev = curNode.must_run_after[ri];
              if (!comp2.has(prev)) {
                comp2.add(prev);
                q.push(prev);
              }
            }
          }
        }
        return comp2;
      }
      for (var ci = 0; ci < nodes.length; ci++) {
        if (!visited.has(nodes[ci].id)) {
          var comp = bfsComponent(nodes[ci].id);
          comp.forEach(function(id) {
            visited.add(id);
          });
          components.push(comp);
        }
      }
      var chains = [];
      for (var si = 0; si < components.length; si++) {
        var compSet = components[si];
        var localInDegree = {};
        compSet.forEach(function(id) {
          localInDegree[id] = 0;
        });
        compSet.forEach(function(id) {
          var edges2 = adjacency[id] || [];
          for (var ei = 0; ei < edges2.length; ei++) {
            if (compSet.has(edges2[ei])) {
              localInDegree[edges2[ei]]++;
            }
          }
        });
        var queue = [];
        compSet.forEach(function(id) {
          if (localInDegree[id] === 0) queue.push(id);
        });
        var sorted = [];
        while (queue.length > 0) {
          var current = queue.shift();
          sorted.push(current);
          var edges = adjacency[current] || [];
          for (var ei2 = 0; ei2 < edges.length; ei2++) {
            if (compSet.has(edges[ei2])) {
              localInDegree[edges[ei2]]--;
              if (localInDegree[edges[ei2]] === 0) {
                queue.push(edges[ei2]);
              }
            }
          }
        }
        if (sorted.length > 1) {
          chains.push(sorted);
        }
      }
      return chains;
    }
    function buildLifecycleGraph(intel, cwd) {
      var allNodes = [];
      var detectorsUsed = [];
      for (var i = 0; i < LIFECYCLE_DETECTORS.length; i++) {
        var detector = LIFECYCLE_DETECTORS[i];
        try {
          if (detector.detect(intel)) {
            debugLog("lifecycle", "detector activated: " + detector.name);
            var extracted = detector.extractLifecycle(intel, cwd);
            allNodes = allNodes.concat(extracted);
            detectorsUsed.push(detector.name);
          }
        } catch (e) {
          debugLog("lifecycle", "detector error: " + detector.name + ": " + e.message);
        }
      }
      var nodes = mergeNodes(allNodes);
      enforceSymmetry(nodes);
      var edgeCount = 0;
      for (var j = 0; j < nodes.length; j++) {
        edgeCount += nodes[j].must_run_before.length;
      }
      var forward = {};
      for (var k = 0; k < nodes.length; k++) {
        forward[nodes[k].id] = nodes[k].must_run_before.slice();
      }
      var cycleData = findCycles({ forward });
      var chains = buildChains(nodes);
      return {
        nodes,
        edges: edgeCount,
        chains,
        cycles: cycleData.cycles || [],
        detectors_used: detectorsUsed,
        stats: {
          node_count: nodes.length,
          edge_count: edgeCount,
          chain_count: chains.length,
          cycle_count: cycleData.cycle_count || 0
        },
        built_at: (/* @__PURE__ */ new Date()).toISOString()
      };
    }
    module2.exports = {
      LIFECYCLE_DETECTORS,
      buildLifecycleGraph
    };
  }
});

// node_modules/tokenx/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  approximateTokenSize: () => approximateTokenSize,
  estimateTokenCount: () => estimateTokenCount,
  isWithinTokenLimit: () => isWithinTokenLimit,
  sliceByTokens: () => sliceByTokens,
  splitByTokens: () => splitByTokens
});
function isWithinTokenLimit(text, tokenLimit, options) {
  return estimateTokenCount(text, options) <= tokenLimit;
}
function estimateTokenCount(text, options = {}) {
  if (!text) return 0;
  const { defaultCharsPerToken = DEFAULT_CHARS_PER_TOKEN, languageConfigs = DEFAULT_LANGUAGE_CONFIGS } = options;
  const segments = text.split(TOKEN_SPLIT_PATTERN).filter(Boolean);
  let tokenCount = 0;
  for (const segment of segments) tokenCount += estimateSegmentTokens(segment, languageConfigs, defaultCharsPerToken);
  return tokenCount;
}
function sliceByTokens(text, start = 0, end, options = {}) {
  if (!text) return "";
  const { defaultCharsPerToken = DEFAULT_CHARS_PER_TOKEN, languageConfigs = DEFAULT_LANGUAGE_CONFIGS } = options;
  let totalTokens = 0;
  if (start < 0 || end !== void 0 && end < 0) totalTokens = estimateTokenCount(text, options);
  const normalizedStart = start < 0 ? Math.max(0, totalTokens + start) : Math.max(0, start);
  const normalizedEnd = end === void 0 ? Infinity : end < 0 ? Math.max(0, totalTokens + end) : end;
  if (normalizedStart >= normalizedEnd) return "";
  const segments = text.split(TOKEN_SPLIT_PATTERN).filter(Boolean);
  const parts = [];
  let currentTokenPos = 0;
  for (const segment of segments) {
    if (currentTokenPos >= normalizedEnd) break;
    const tokenCount = estimateSegmentTokens(segment, languageConfigs, defaultCharsPerToken);
    const extracted = extractSegmentPart(segment, currentTokenPos, tokenCount, normalizedStart, normalizedEnd);
    if (extracted) parts.push(extracted);
    currentTokenPos += tokenCount;
  }
  return parts.join("");
}
function splitByTokens(text, tokensPerChunk, options = {}) {
  if (!text || tokensPerChunk <= 0) return [];
  const { defaultCharsPerToken = DEFAULT_CHARS_PER_TOKEN, languageConfigs = DEFAULT_LANGUAGE_CONFIGS, overlap = 0 } = options;
  const segments = text.split(TOKEN_SPLIT_PATTERN).filter(Boolean);
  const chunks = [];
  let currentChunk = [];
  let currentTokenCount = 0;
  for (const segment of segments) {
    const tokenCount = estimateSegmentTokens(segment, languageConfigs, defaultCharsPerToken);
    currentChunk.push(segment);
    currentTokenCount += tokenCount;
    if (currentTokenCount >= tokensPerChunk) {
      chunks.push(currentChunk.join(""));
      if (overlap > 0) {
        const overlapSegments = [];
        let overlapTokenCount = 0;
        for (let i = currentChunk.length - 1; i >= 0 && overlapTokenCount < overlap; i--) {
          const segmentValue = currentChunk[i];
          const tokCount = estimateSegmentTokens(segmentValue, languageConfigs, defaultCharsPerToken);
          overlapSegments.unshift(segmentValue);
          overlapTokenCount += tokCount;
        }
        currentChunk = overlapSegments;
        currentTokenCount = overlapTokenCount;
      } else {
        currentChunk = [];
        currentTokenCount = 0;
      }
    }
  }
  if (currentChunk.length > 0) chunks.push(currentChunk.join(""));
  return chunks;
}
function estimateSegmentTokens(segment, languageConfigs, defaultCharsPerToken) {
  if (PATTERNS.whitespace.test(segment)) return 0;
  if (PATTERNS.cjk.test(segment)) return getCharacterCount(segment);
  if (PATTERNS.numeric.test(segment)) return 1;
  if (segment.length <= SHORT_TOKEN_THRESHOLD) return 1;
  if (PATTERNS.punctuation.test(segment)) return segment.length > 1 ? Math.ceil(segment.length / 2) : 1;
  if (PATTERNS.alphanumeric.test(segment)) {
    const charsPerToken$1 = getLanguageSpecificCharsPerToken(segment, languageConfigs) ?? defaultCharsPerToken;
    return Math.ceil(segment.length / charsPerToken$1);
  }
  const charsPerToken = getLanguageSpecificCharsPerToken(segment, languageConfigs) ?? defaultCharsPerToken;
  return Math.ceil(segment.length / charsPerToken);
}
function getLanguageSpecificCharsPerToken(segment, languageConfigs) {
  for (const config of languageConfigs) if (config.pattern.test(segment)) return config.averageCharsPerToken;
}
function getCharacterCount(text) {
  return Array.from(text).length;
}
function extractSegmentPart(segment, segmentTokenStart, segmentTokenCount, targetStart, targetEnd) {
  if (segmentTokenCount === 0) return segmentTokenStart >= targetStart && segmentTokenStart < targetEnd ? segment : "";
  const segmentTokenEnd = segmentTokenStart + segmentTokenCount;
  if (segmentTokenStart >= targetEnd || segmentTokenEnd <= targetStart) return "";
  const overlapStart = Math.max(0, targetStart - segmentTokenStart);
  const overlapEnd = Math.min(segmentTokenCount, targetEnd - segmentTokenStart);
  if (overlapStart === 0 && overlapEnd === segmentTokenCount) return segment;
  const charStart = Math.floor(overlapStart / segmentTokenCount * segment.length);
  const charEnd = Math.ceil(overlapEnd / segmentTokenCount * segment.length);
  return segment.slice(charStart, charEnd);
}
var PATTERNS, TOKEN_SPLIT_PATTERN, DEFAULT_CHARS_PER_TOKEN, SHORT_TOKEN_THRESHOLD, DEFAULT_LANGUAGE_CONFIGS, approximateTokenSize;
var init_dist = __esm({
  "node_modules/tokenx/dist/index.mjs"() {
    PATTERNS = {
      whitespace: /^\s+$/,
      cjk: /[\u4E00-\u9FFF\u3400-\u4DBF\u3000-\u303F\uFF00-\uFFEF\u30A0-\u30FF\u2E80-\u2EFF\u31C0-\u31EF\u3200-\u32FF\u3300-\u33FF\uAC00-\uD7AF\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF]/,
      numeric: /^\d+(?:[.,]\d+)*$/,
      punctuation: /[.,!?;(){}[\]<>:/\\|@#$%^&*+=`~_-]/,
      alphanumeric: /^[a-zA-Z0-9\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]+$/
    };
    TOKEN_SPLIT_PATTERN = /* @__PURE__ */ new RegExp(`(\\s+|${PATTERNS.punctuation.source}+)`);
    DEFAULT_CHARS_PER_TOKEN = 6;
    SHORT_TOKEN_THRESHOLD = 3;
    DEFAULT_LANGUAGE_CONFIGS = [
      {
        pattern: /[Ã¤Ã¶Ã¼ÃŸáºž]/i,
        averageCharsPerToken: 3
      },
      {
        pattern: /[Ã©Ã¨ÃªÃ«Ã Ã¢Ã®Ã¯Ã´Ã»Ã¹Ã¼Ã¿Ã§Å“Ã¦Ã¡Ã­Ã³ÃºÃ±]/i,
        averageCharsPerToken: 3
      },
      {
        pattern: /[Ä…Ä‡Ä™Å‚Å„Ã³Å›ÅºÅ¼Ä›Å¡ÄÅ™Å¾Ã½Å¯ÃºÄÅ¥Åˆ]/i,
        averageCharsPerToken: 3.5
      }
    ];
    approximateTokenSize = estimateTokenCount;
  }
});

// node_modules/acorn/dist/acorn.js
var require_acorn = __commonJS({
  "node_modules/acorn/dist/acorn.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.acorn = {}));
    })(exports2, (function(exports3) {
      "use strict";
      var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 78, 5, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 199, 7, 137, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 55, 9, 266, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 233, 0, 3, 0, 8, 1, 6, 0, 475, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 7, 25, 39, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 5, 57, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 24, 43, 261, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 33, 24, 3, 24, 45, 74, 6, 0, 67, 12, 65, 1, 2, 0, 15, 4, 10, 7381, 42, 31, 98, 114, 8702, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 208, 30, 2, 2, 2, 1, 2, 6, 3, 4, 10, 1, 225, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4381, 3, 5773, 3, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 8489];
      var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ADD\u1AE0-\u1AEB\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
      var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088F\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5C\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDC-\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7DC\uA7F1-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
      var reservedWords = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
      };
      var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
      var keywords$1 = {
        5: ecma5AndLessKeywords,
        "5module": ecma5AndLessKeywords + " export import",
        6: ecma5AndLessKeywords + " const class extends export import super"
      };
      var keywordRelationalOperator = /^in(stanceof)?$/;
      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
      function isInAstralSet(code, set) {
        var pos = 65536;
        for (var i2 = 0; i2 < set.length; i2 += 2) {
          pos += set[i2];
          if (pos > code) {
            return false;
          }
          pos += set[i2 + 1];
          if (pos >= code) {
            return true;
          }
        }
        return false;
      }
      function isIdentifierStart(code, astral) {
        if (code < 65) {
          return code === 36;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code, astralIdentifierStartCodes);
      }
      function isIdentifierChar(code, astral) {
        if (code < 48) {
          return code === 36;
        }
        if (code < 58) {
          return true;
        }
        if (code < 65) {
          return false;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
      }
      var TokenType = function TokenType2(label, conf) {
        if (conf === void 0) conf = {};
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop || null;
        this.updateContext = null;
      };
      function binop(name, prec) {
        return new TokenType(name, { beforeExpr: true, binop: prec });
      }
      var beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true };
      var keywords = {};
      function kw(name, options) {
        if (options === void 0) options = {};
        options.keyword = name;
        return keywords[name] = new TokenType(name, options);
      }
      var types$1 = {
        num: new TokenType("num", startsExpr),
        regexp: new TokenType("regexp", startsExpr),
        string: new TokenType("string", startsExpr),
        name: new TokenType("name", startsExpr),
        privateId: new TokenType("privateId", startsExpr),
        eof: new TokenType("eof"),
        // Punctuation token types.
        bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
        bracketR: new TokenType("]"),
        braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
        braceR: new TokenType("}"),
        parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
        parenR: new TokenType(")"),
        comma: new TokenType(",", beforeExpr),
        semi: new TokenType(";", beforeExpr),
        colon: new TokenType(":", beforeExpr),
        dot: new TokenType("."),
        question: new TokenType("?", beforeExpr),
        questionDot: new TokenType("?."),
        arrow: new TokenType("=>", beforeExpr),
        template: new TokenType("template"),
        invalidTemplate: new TokenType("invalidTemplate"),
        ellipsis: new TokenType("...", beforeExpr),
        backQuote: new TokenType("`", startsExpr),
        dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
        // Operators. These carry several kinds of properties to help the
        // parser use them properly (the presence of these properties is
        // what categorizes them as operators).
        //
        // `binop`, when present, specifies that this operator is a binary
        // operator, and will refer to its precedence.
        //
        // `prefix` and `postfix` mark the operator as a prefix or postfix
        // unary operator.
        //
        // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
        // binary operators with a very low precedence, that should result
        // in AssignmentExpression nodes.
        eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
        assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
        incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
        prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
        logicalOR: binop("||", 1),
        logicalAND: binop("&&", 2),
        bitwiseOR: binop("|", 3),
        bitwiseXOR: binop("^", 4),
        bitwiseAND: binop("&", 5),
        equality: binop("==/!=/===/!==", 6),
        relational: binop("</>/<=/>=", 7),
        bitShift: binop("<</>>/>>>", 8),
        plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
        modulo: binop("%", 10),
        star: binop("*", 10),
        slash: binop("/", 10),
        starstar: new TokenType("**", { beforeExpr: true }),
        coalesce: binop("??", 1),
        // Keyword token types.
        _break: kw("break"),
        _case: kw("case", beforeExpr),
        _catch: kw("catch"),
        _continue: kw("continue"),
        _debugger: kw("debugger"),
        _default: kw("default", beforeExpr),
        _do: kw("do", { isLoop: true, beforeExpr: true }),
        _else: kw("else", beforeExpr),
        _finally: kw("finally"),
        _for: kw("for", { isLoop: true }),
        _function: kw("function", startsExpr),
        _if: kw("if"),
        _return: kw("return", beforeExpr),
        _switch: kw("switch"),
        _throw: kw("throw", beforeExpr),
        _try: kw("try"),
        _var: kw("var"),
        _const: kw("const"),
        _while: kw("while", { isLoop: true }),
        _with: kw("with"),
        _new: kw("new", { beforeExpr: true, startsExpr: true }),
        _this: kw("this", startsExpr),
        _super: kw("super", startsExpr),
        _class: kw("class", startsExpr),
        _extends: kw("extends", beforeExpr),
        _export: kw("export"),
        _import: kw("import", startsExpr),
        _null: kw("null", startsExpr),
        _true: kw("true", startsExpr),
        _false: kw("false", startsExpr),
        _in: kw("in", { beforeExpr: true, binop: 7 }),
        _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
        _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
        _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
        _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
      };
      var lineBreak = /\r\n?|\n|\u2028|\u2029/;
      var lineBreakG = new RegExp(lineBreak.source, "g");
      function isNewLine(code) {
        return code === 10 || code === 13 || code === 8232 || code === 8233;
      }
      function nextLineBreak(code, from, end) {
        if (end === void 0) end = code.length;
        for (var i2 = from; i2 < end; i2++) {
          var next = code.charCodeAt(i2);
          if (isNewLine(next)) {
            return i2 < end - 1 && next === 13 && code.charCodeAt(i2 + 1) === 10 ? i2 + 2 : i2 + 1;
          }
        }
        return -1;
      }
      var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
      var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      var ref = Object.prototype;
      var hasOwnProperty = ref.hasOwnProperty;
      var toString = ref.toString;
      var hasOwn = Object.hasOwn || (function(obj, propName) {
        return hasOwnProperty.call(obj, propName);
      });
      var isArray = Array.isArray || (function(obj) {
        return toString.call(obj) === "[object Array]";
      });
      var regexpCache = /* @__PURE__ */ Object.create(null);
      function wordsRegexp(words) {
        return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
      }
      function codePointToString(code) {
        if (code <= 65535) {
          return String.fromCharCode(code);
        }
        code -= 65536;
        return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
      }
      var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
      var Position = function Position2(line, col) {
        this.line = line;
        this.column = col;
      };
      Position.prototype.offset = function offset(n) {
        return new Position(this.line, this.column + n);
      };
      var SourceLocation = function SourceLocation2(p, start, end) {
        this.start = start;
        this.end = end;
        if (p.sourceFile !== null) {
          this.source = p.sourceFile;
        }
      };
      function getLineInfo(input, offset) {
        for (var line = 1, cur = 0; ; ) {
          var nextBreak = nextLineBreak(input, cur, offset);
          if (nextBreak < 0) {
            return new Position(line, offset - cur);
          }
          ++line;
          cur = nextBreak;
        }
      }
      var defaultOptions = {
        // `ecmaVersion` indicates the ECMAScript version to parse. Must be
        // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
        // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
        // (the latest version the library supports). This influences
        // support for strict mode, the set of reserved words, and support
        // for new syntax features.
        ecmaVersion: null,
        // `sourceType` indicates the mode the code should be parsed in.
        // Can be either `"script"`, `"module"` or `"commonjs"`. This influences global
        // strict mode and parsing of `import` and `export` declarations.
        sourceType: "script",
        // `onInsertedSemicolon` can be a callback that will be called when
        // a semicolon is automatically inserted. It will be passed the
        // position of the inserted semicolon as an offset, and if
        // `locations` is enabled, it is given the location as a `{line,
        // column}` object as second argument.
        onInsertedSemicolon: null,
        // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
        // trailing commas.
        onTrailingComma: null,
        // By default, reserved words are only enforced if ecmaVersion >= 5.
        // Set `allowReserved` to a boolean value to explicitly turn this on
        // an off. When this option has the value "never", reserved words
        // and keywords can also not be used as property names.
        allowReserved: null,
        // When enabled, a return at the top level is not considered an
        // error.
        allowReturnOutsideFunction: false,
        // When enabled, import/export statements are not constrained to
        // appearing at the top of the program, and an import.meta expression
        // in a script isn't considered an error.
        allowImportExportEverywhere: false,
        // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
        // When enabled, await identifiers are allowed to appear at the top-level scope,
        // but they are still not allowed in non-async functions.
        allowAwaitOutsideFunction: null,
        // When enabled, super identifiers are not constrained to
        // appearing in methods and do not raise an error when they appear elsewhere.
        allowSuperOutsideMethod: null,
        // When enabled, hashbang directive in the beginning of file is
        // allowed and treated as a line comment. Enabled by default when
        // `ecmaVersion` >= 2023.
        allowHashBang: false,
        // By default, the parser will verify that private properties are
        // only used in places where they are valid and have been declared.
        // Set this to false to turn such checks off.
        checkPrivateFields: true,
        // When `locations` is on, `loc` properties holding objects with
        // `start` and `end` properties in `{line, column}` form (with
        // line being 1-based and column 0-based) will be attached to the
        // nodes.
        locations: false,
        // A function can be passed as `onToken` option, which will
        // cause Acorn to call that function with object in the same
        // format as tokens returned from `tokenizer().getToken()`. Note
        // that you are not allowed to call the parser from the
        // callbackâ€”that will corrupt its internal state.
        onToken: null,
        // A function can be passed as `onComment` option, which will
        // cause Acorn to call that function with `(block, text, start,
        // end)` parameters whenever a comment is skipped. `block` is a
        // boolean indicating whether this is a block (`/* */`) comment,
        // `text` is the content of the comment, and `start` and `end` are
        // character offsets that denote the start and end of the comment.
        // When the `locations` option is on, two more parameters are
        // passed, the full `{line, column}` locations of the start and
        // end of the comments. Note that you are not allowed to call the
        // parser from the callbackâ€”that will corrupt its internal state.
        // When this option has an array as value, objects representing the
        // comments are pushed to it.
        onComment: null,
        // Nodes have their start and end characters offsets recorded in
        // `start` and `end` properties (directly on the node, rather than
        // the `loc` object, which holds line/column data. To also add a
        // [semi-standardized][range] `range` property holding a `[start,
        // end]` array with the same numbers, set the `ranges` option to
        // `true`.
        //
        // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
        ranges: false,
        // It is possible to parse multiple files into a single AST by
        // passing the tree produced by parsing the first file as
        // `program` option in subsequent parses. This will add the
        // toplevel forms of the parsed file to the `Program` (top) node
        // of an existing parse tree.
        program: null,
        // When `locations` is on, you can pass this to record the source
        // file in every node's `loc` object.
        sourceFile: null,
        // This value, if given, is stored in every node, whether
        // `locations` is on or off.
        directSourceFile: null,
        // When enabled, parenthesized expressions are represented by
        // (non-standard) ParenthesizedExpression nodes
        preserveParens: false
      };
      var warnedAboutEcmaVersion = false;
      function getOptions(opts) {
        var options = {};
        for (var opt in defaultOptions) {
          options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
        }
        if (options.ecmaVersion === "latest") {
          options.ecmaVersion = 1e8;
        } else if (options.ecmaVersion == null) {
          if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
            warnedAboutEcmaVersion = true;
            console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
          }
          options.ecmaVersion = 11;
        } else if (options.ecmaVersion >= 2015) {
          options.ecmaVersion -= 2009;
        }
        if (options.allowReserved == null) {
          options.allowReserved = options.ecmaVersion < 5;
        }
        if (!opts || opts.allowHashBang == null) {
          options.allowHashBang = options.ecmaVersion >= 14;
        }
        if (isArray(options.onToken)) {
          var tokens = options.onToken;
          options.onToken = function(token) {
            return tokens.push(token);
          };
        }
        if (isArray(options.onComment)) {
          options.onComment = pushComment(options, options.onComment);
        }
        if (options.sourceType === "commonjs" && options.allowAwaitOutsideFunction) {
          throw new Error("Cannot use allowAwaitOutsideFunction with sourceType: commonjs");
        }
        return options;
      }
      function pushComment(options, array) {
        return function(block, text, start, end, startLoc, endLoc) {
          var comment = {
            type: block ? "Block" : "Line",
            value: text,
            start,
            end
          };
          if (options.locations) {
            comment.loc = new SourceLocation(this, startLoc, endLoc);
          }
          if (options.ranges) {
            comment.range = [start, end];
          }
          array.push(comment);
        };
      }
      var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_CLASS_FIELD_INIT = 512, SCOPE_SWITCH = 1024, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
      function functionFlags(async, generator) {
        return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
      }
      var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
      var Parser = function Parser2(options, input, startPos) {
        this.options = options = getOptions(options);
        this.sourceFile = options.sourceFile;
        this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
        var reserved = "";
        if (options.allowReserved !== true) {
          reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
          if (options.sourceType === "module") {
            reserved += " await";
          }
        }
        this.reservedWords = wordsRegexp(reserved);
        var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
        this.reservedWordsStrict = wordsRegexp(reservedStrict);
        this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
        this.input = String(input);
        this.containsEsc = false;
        if (startPos) {
          this.pos = startPos;
          this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
          this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
        } else {
          this.pos = this.lineStart = 0;
          this.curLine = 1;
        }
        this.type = types$1.eof;
        this.value = null;
        this.start = this.end = this.pos;
        this.startLoc = this.endLoc = this.curPosition();
        this.lastTokEndLoc = this.lastTokStartLoc = null;
        this.lastTokStart = this.lastTokEnd = this.pos;
        this.context = this.initialContext();
        this.exprAllowed = true;
        this.inModule = options.sourceType === "module";
        this.strict = this.inModule || this.strictDirective(this.pos);
        this.potentialArrowAt = -1;
        this.potentialArrowInForAwait = false;
        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
        this.labels = [];
        this.undefinedExports = /* @__PURE__ */ Object.create(null);
        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
          this.skipLineComment(2);
        }
        this.scopeStack = [];
        this.enterScope(
          this.options.sourceType === "commonjs" ? SCOPE_FUNCTION : SCOPE_TOP
        );
        this.regexpState = null;
        this.privateNameStack = [];
      };
      var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowReturn: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, allowUsing: { configurable: true }, inClassStaticBlock: { configurable: true } };
      Parser.prototype.parse = function parse2() {
        var node = this.options.program || this.startNode();
        this.nextToken();
        return this.parseTopLevel(node);
      };
      prototypeAccessors.inFunction.get = function() {
        return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
      };
      prototypeAccessors.inGenerator.get = function() {
        return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
      };
      prototypeAccessors.inAsync.get = function() {
        return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
      };
      prototypeAccessors.canAwait.get = function() {
        for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
          var ref2 = this.scopeStack[i2];
          var flags = ref2.flags;
          if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) {
            return false;
          }
          if (flags & SCOPE_FUNCTION) {
            return (flags & SCOPE_ASYNC) > 0;
          }
        }
        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
      };
      prototypeAccessors.allowReturn.get = function() {
        if (this.inFunction) {
          return true;
        }
        if (this.options.allowReturnOutsideFunction && this.currentVarScope().flags & SCOPE_TOP) {
          return true;
        }
        return false;
      };
      prototypeAccessors.allowSuper.get = function() {
        var ref2 = this.currentThisScope();
        var flags = ref2.flags;
        return (flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod;
      };
      prototypeAccessors.allowDirectSuper.get = function() {
        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
      };
      prototypeAccessors.treatFunctionsAsVar.get = function() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      };
      prototypeAccessors.allowNewDotTarget.get = function() {
        for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
          var ref2 = this.scopeStack[i2];
          var flags = ref2.flags;
          if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) || flags & SCOPE_FUNCTION && !(flags & SCOPE_ARROW)) {
            return true;
          }
        }
        return false;
      };
      prototypeAccessors.allowUsing.get = function() {
        var ref2 = this.currentScope();
        var flags = ref2.flags;
        if (flags & SCOPE_SWITCH) {
          return false;
        }
        if (!this.inModule && flags & SCOPE_TOP) {
          return false;
        }
        return true;
      };
      prototypeAccessors.inClassStaticBlock.get = function() {
        return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
      };
      Parser.extend = function extend() {
        var plugins = [], len = arguments.length;
        while (len--) plugins[len] = arguments[len];
        var cls = this;
        for (var i2 = 0; i2 < plugins.length; i2++) {
          cls = plugins[i2](cls);
        }
        return cls;
      };
      Parser.parse = function parse2(input, options) {
        return new this(options, input).parse();
      };
      Parser.parseExpressionAt = function parseExpressionAt2(input, pos, options) {
        var parser = new this(options, input, pos);
        parser.nextToken();
        return parser.parseExpression();
      };
      Parser.tokenizer = function tokenizer2(input, options) {
        return new this(options, input);
      };
      Object.defineProperties(Parser.prototype, prototypeAccessors);
      var pp$9 = Parser.prototype;
      var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
      pp$9.strictDirective = function(start) {
        if (this.options.ecmaVersion < 5) {
          return false;
        }
        for (; ; ) {
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          var match = literal.exec(this.input.slice(start));
          if (!match) {
            return false;
          }
          if ((match[1] || match[2]) === "use strict") {
            skipWhiteSpace.lastIndex = start + match[0].length;
            var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
            var next = this.input.charAt(end);
            return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
          }
          start += match[0].length;
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          if (this.input[start] === ";") {
            start++;
          }
        }
      };
      pp$9.eat = function(type) {
        if (this.type === type) {
          this.next();
          return true;
        } else {
          return false;
        }
      };
      pp$9.isContextual = function(name) {
        return this.type === types$1.name && this.value === name && !this.containsEsc;
      };
      pp$9.eatContextual = function(name) {
        if (!this.isContextual(name)) {
          return false;
        }
        this.next();
        return true;
      };
      pp$9.expectContextual = function(name) {
        if (!this.eatContextual(name)) {
          this.unexpected();
        }
      };
      pp$9.canInsertSemicolon = function() {
        return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$9.insertSemicolon = function() {
        if (this.canInsertSemicolon()) {
          if (this.options.onInsertedSemicolon) {
            this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
          }
          return true;
        }
      };
      pp$9.semicolon = function() {
        if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
          this.unexpected();
        }
      };
      pp$9.afterTrailingComma = function(tokType, notNext) {
        if (this.type === tokType) {
          if (this.options.onTrailingComma) {
            this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
          }
          if (!notNext) {
            this.next();
          }
          return true;
        }
      };
      pp$9.expect = function(type) {
        this.eat(type) || this.unexpected();
      };
      pp$9.unexpected = function(pos) {
        this.raise(pos != null ? pos : this.start, "Unexpected token");
      };
      var DestructuringErrors = function DestructuringErrors2() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
      };
      pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
        if (!refDestructuringErrors) {
          return;
        }
        if (refDestructuringErrors.trailingComma > -1) {
          this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
        }
        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
        if (parens > -1) {
          this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
        }
      };
      pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
        if (!refDestructuringErrors) {
          return false;
        }
        var shorthandAssign = refDestructuringErrors.shorthandAssign;
        var doubleProto = refDestructuringErrors.doubleProto;
        if (!andThrow) {
          return shorthandAssign >= 0 || doubleProto >= 0;
        }
        if (shorthandAssign >= 0) {
          this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
        }
        if (doubleProto >= 0) {
          this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
        }
      };
      pp$9.checkYieldAwaitInDefaultParams = function() {
        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
          this.raise(this.yieldPos, "Yield expression cannot be a default value");
        }
        if (this.awaitPos) {
          this.raise(this.awaitPos, "Await expression cannot be a default value");
        }
      };
      pp$9.isSimpleAssignTarget = function(expr) {
        if (expr.type === "ParenthesizedExpression") {
          return this.isSimpleAssignTarget(expr.expression);
        }
        return expr.type === "Identifier" || expr.type === "MemberExpression";
      };
      var pp$8 = Parser.prototype;
      pp$8.parseTopLevel = function(node) {
        var exports4 = /* @__PURE__ */ Object.create(null);
        if (!node.body) {
          node.body = [];
        }
        while (this.type !== types$1.eof) {
          var stmt = this.parseStatement(null, true, exports4);
          node.body.push(stmt);
        }
        if (this.inModule) {
          for (var i2 = 0, list2 = Object.keys(this.undefinedExports); i2 < list2.length; i2 += 1) {
            var name = list2[i2];
            this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
          }
        }
        this.adaptDirectivePrologue(node.body);
        this.next();
        node.sourceType = this.options.sourceType === "commonjs" ? "script" : this.options.sourceType;
        return this.finishNode(node, "Program");
      };
      var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
      pp$8.isLet = function(context) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.fullCharCodeAt(next);
        if (nextCh === 91 || nextCh === 92) {
          return true;
        }
        if (context) {
          return false;
        }
        if (nextCh === 123) {
          return true;
        }
        if (isIdentifierStart(nextCh)) {
          var start = next;
          do {
            next += nextCh <= 65535 ? 1 : 2;
          } while (isIdentifierChar(nextCh = this.fullCharCodeAt(next)));
          if (nextCh === 92) {
            return true;
          }
          var ident = this.input.slice(start, next);
          if (!keywordRelationalOperator.test(ident)) {
            return true;
          }
        }
        return false;
      };
      pp$8.isAsyncFunction = function() {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, after;
        return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.fullCharCodeAt(next + 8)) || after === 92));
      };
      pp$8.isUsingKeyword = function(isAwaitUsing, isFor) {
        if (this.options.ecmaVersion < 17 || !this.isContextual(isAwaitUsing ? "await" : "using")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length;
        if (lineBreak.test(this.input.slice(this.pos, next))) {
          return false;
        }
        if (isAwaitUsing) {
          var usingEndPos = next + 5, after;
          if (this.input.slice(next, usingEndPos) !== "using" || usingEndPos === this.input.length || isIdentifierChar(after = this.fullCharCodeAt(usingEndPos)) || after === 92) {
            return false;
          }
          skipWhiteSpace.lastIndex = usingEndPos;
          var skipAfterUsing = skipWhiteSpace.exec(this.input);
          next = usingEndPos + skipAfterUsing[0].length;
          if (skipAfterUsing && lineBreak.test(this.input.slice(usingEndPos, next))) {
            return false;
          }
        }
        var ch = this.fullCharCodeAt(next);
        if (!isIdentifierStart(ch) && ch !== 92) {
          return false;
        }
        var idStart = next;
        do {
          next += ch <= 65535 ? 1 : 2;
        } while (isIdentifierChar(ch = this.fullCharCodeAt(next)));
        if (ch === 92) {
          return true;
        }
        var id = this.input.slice(idStart, next);
        if (keywordRelationalOperator.test(id) || isFor && id === "of") {
          return false;
        }
        return true;
      };
      pp$8.isAwaitUsing = function(isFor) {
        return this.isUsingKeyword(true, isFor);
      };
      pp$8.isUsing = function(isFor) {
        return this.isUsingKeyword(false, isFor);
      };
      pp$8.parseStatement = function(context, topLevel, exports4) {
        var starttype = this.type, node = this.startNode(), kind;
        if (this.isLet(context)) {
          starttype = types$1._var;
          kind = "let";
        }
        switch (starttype) {
          case types$1._break:
          case types$1._continue:
            return this.parseBreakContinueStatement(node, starttype.keyword);
          case types$1._debugger:
            return this.parseDebuggerStatement(node);
          case types$1._do:
            return this.parseDoStatement(node);
          case types$1._for:
            return this.parseForStatement(node);
          case types$1._function:
            if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
              this.unexpected();
            }
            return this.parseFunctionStatement(node, false, !context);
          case types$1._class:
            if (context) {
              this.unexpected();
            }
            return this.parseClass(node, true);
          case types$1._if:
            return this.parseIfStatement(node);
          case types$1._return:
            return this.parseReturnStatement(node);
          case types$1._switch:
            return this.parseSwitchStatement(node);
          case types$1._throw:
            return this.parseThrowStatement(node);
          case types$1._try:
            return this.parseTryStatement(node);
          case types$1._const:
          case types$1._var:
            kind = kind || this.value;
            if (context && kind !== "var") {
              this.unexpected();
            }
            return this.parseVarStatement(node, kind);
          case types$1._while:
            return this.parseWhileStatement(node);
          case types$1._with:
            return this.parseWithStatement(node);
          case types$1.braceL:
            return this.parseBlock(true, node);
          case types$1.semi:
            return this.parseEmptyStatement(node);
          case types$1._export:
          case types$1._import:
            if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
              skipWhiteSpace.lastIndex = this.pos;
              var skip = skipWhiteSpace.exec(this.input);
              var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
              if (nextCh === 40 || nextCh === 46) {
                return this.parseExpressionStatement(node, this.parseExpression());
              }
            }
            if (!this.options.allowImportExportEverywhere) {
              if (!topLevel) {
                this.raise(this.start, "'import' and 'export' may only appear at the top level");
              }
              if (!this.inModule) {
                this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
              }
            }
            return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports4);
          // If the statement does not start with a statement keyword or a
          // brace, it's an ExpressionStatement or LabeledStatement. We
          // simply start parsing an expression, and afterwards, if the
          // next token is a colon and the expression was a simple
          // Identifier node, we switch to interpreting it as a label.
          default:
            if (this.isAsyncFunction()) {
              if (context) {
                this.unexpected();
              }
              this.next();
              return this.parseFunctionStatement(node, true, !context);
            }
            var usingKind = this.isAwaitUsing(false) ? "await using" : this.isUsing(false) ? "using" : null;
            if (usingKind) {
              if (!this.allowUsing) {
                this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script` or in the bare case statement");
              }
              if (usingKind === "await using") {
                if (!this.canAwait) {
                  this.raise(this.start, "Await using cannot appear outside of async function");
                }
                this.next();
              }
              this.next();
              this.parseVar(node, false, usingKind);
              this.semicolon();
              return this.finishNode(node, "VariableDeclaration");
            }
            var maybeName = this.value, expr = this.parseExpression();
            if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
              return this.parseLabeledStatement(node, maybeName, expr, context);
            } else {
              return this.parseExpressionStatement(node, expr);
            }
        }
      };
      pp$8.parseBreakContinueStatement = function(node, keyword) {
        var isBreak = keyword === "break";
        this.next();
        if (this.eat(types$1.semi) || this.insertSemicolon()) {
          node.label = null;
        } else if (this.type !== types$1.name) {
          this.unexpected();
        } else {
          node.label = this.parseIdent();
          this.semicolon();
        }
        var i2 = 0;
        for (; i2 < this.labels.length; ++i2) {
          var lab = this.labels[i2];
          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop")) {
              break;
            }
            if (node.label && isBreak) {
              break;
            }
          }
        }
        if (i2 === this.labels.length) {
          this.raise(node.start, "Unsyntactic " + keyword);
        }
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      };
      pp$8.parseDebuggerStatement = function(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
      };
      pp$8.parseDoStatement = function(node) {
        this.next();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("do");
        this.labels.pop();
        this.expect(types$1._while);
        node.test = this.parseParenExpression();
        if (this.options.ecmaVersion >= 6) {
          this.eat(types$1.semi);
        } else {
          this.semicolon();
        }
        return this.finishNode(node, "DoWhileStatement");
      };
      pp$8.parseForStatement = function(node) {
        this.next();
        var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
        this.labels.push(loopLabel);
        this.enterScope(0);
        this.expect(types$1.parenL);
        if (this.type === types$1.semi) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, null);
        }
        var isLet = this.isLet();
        if (this.type === types$1._var || this.type === types$1._const || isLet) {
          var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
          this.next();
          this.parseVar(init$1, true, kind);
          this.finishNode(init$1, "VariableDeclaration");
          return this.parseForAfterInit(node, init$1, awaitAt);
        }
        var startsWithLet = this.isContextual("let"), isForOf = false;
        var usingKind = this.isUsing(true) ? "using" : this.isAwaitUsing(true) ? "await using" : null;
        if (usingKind) {
          var init$2 = this.startNode();
          this.next();
          if (usingKind === "await using") {
            if (!this.canAwait) {
              this.raise(this.start, "Await using cannot appear outside of async function");
            }
            this.next();
          }
          this.parseVar(init$2, true, usingKind);
          this.finishNode(init$2, "VariableDeclaration");
          return this.parseForAfterInit(node, init$2, awaitAt);
        }
        var containsEsc = this.containsEsc;
        var refDestructuringErrors = new DestructuringErrors();
        var initPos = this.start;
        var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
        if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          if (awaitAt > -1) {
            if (this.type === types$1._in) {
              this.unexpected(awaitAt);
            }
            node.await = true;
          } else if (isForOf && this.options.ecmaVersion >= 8) {
            if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") {
              this.unexpected();
            } else if (this.options.ecmaVersion >= 9) {
              node.await = false;
            }
          }
          if (startsWithLet && isForOf) {
            this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
          }
          this.toAssignable(init, false, refDestructuringErrors);
          this.checkLValPattern(init);
          return this.parseForIn(node, init);
        } else {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init);
      };
      pp$8.parseForAfterInit = function(node, init, awaitAt) {
        if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init.declarations.length === 1) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types$1._in) {
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
            } else {
              node.await = awaitAt > -1;
            }
          }
          return this.parseForIn(node, init);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init);
      };
      pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
        this.next();
        return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
      };
      pp$8.parseIfStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        node.consequent = this.parseStatement("if");
        node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
        return this.finishNode(node, "IfStatement");
      };
      pp$8.parseReturnStatement = function(node) {
        if (!this.allowReturn) {
          this.raise(this.start, "'return' outside of function");
        }
        this.next();
        if (this.eat(types$1.semi) || this.insertSemicolon()) {
          node.argument = null;
        } else {
          node.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
      };
      pp$8.parseSwitchStatement = function(node) {
        this.next();
        node.discriminant = this.parseParenExpression();
        node.cases = [];
        this.expect(types$1.braceL);
        this.labels.push(switchLabel);
        this.enterScope(SCOPE_SWITCH);
        var cur;
        for (var sawDefault = false; this.type !== types$1.braceR; ) {
          if (this.type === types$1._case || this.type === types$1._default) {
            var isCase = this.type === types$1._case;
            if (cur) {
              this.finishNode(cur, "SwitchCase");
            }
            node.cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(types$1.colon);
          } else {
            if (!cur) {
              this.unexpected();
            }
            cur.consequent.push(this.parseStatement(null));
          }
        }
        this.exitScope();
        if (cur) {
          this.finishNode(cur, "SwitchCase");
        }
        this.next();
        this.labels.pop();
        return this.finishNode(node, "SwitchStatement");
      };
      pp$8.parseThrowStatement = function(node) {
        this.next();
        if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
          this.raise(this.lastTokEnd, "Illegal newline after throw");
        }
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
      };
      var empty$1 = [];
      pp$8.parseCatchClauseParam = function() {
        var param = this.parseBindingAtom();
        var simple = param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
        this.expect(types$1.parenR);
        return param;
      };
      pp$8.parseTryStatement = function(node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.type === types$1._catch) {
          var clause = this.startNode();
          this.next();
          if (this.eat(types$1.parenL)) {
            clause.param = this.parseCatchClauseParam();
          } else {
            if (this.options.ecmaVersion < 10) {
              this.unexpected();
            }
            clause.param = null;
            this.enterScope(0);
          }
          clause.body = this.parseBlock(false);
          this.exitScope();
          node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) {
          this.raise(node.start, "Missing catch or finally clause");
        }
        return this.finishNode(node, "TryStatement");
      };
      pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
        this.next();
        this.parseVar(node, false, kind, allowMissingInitializer);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      };
      pp$8.parseWhileStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("while");
        this.labels.pop();
        return this.finishNode(node, "WhileStatement");
      };
      pp$8.parseWithStatement = function(node) {
        if (this.strict) {
          this.raise(this.start, "'with' in strict mode");
        }
        this.next();
        node.object = this.parseParenExpression();
        node.body = this.parseStatement("with");
        return this.finishNode(node, "WithStatement");
      };
      pp$8.parseEmptyStatement = function(node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
      };
      pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
        for (var i$1 = 0, list2 = this.labels; i$1 < list2.length; i$1 += 1) {
          var label = list2[i$1];
          if (label.name === maybeName) {
            this.raise(expr.start, "Label '" + maybeName + "' is already declared");
          }
        }
        var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
        for (var i2 = this.labels.length - 1; i2 >= 0; i2--) {
          var label$1 = this.labels[i2];
          if (label$1.statementStart === node.start) {
            label$1.statementStart = this.start;
            label$1.kind = kind;
          } else {
            break;
          }
        }
        this.labels.push({ name: maybeName, kind, statementStart: this.start });
        node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
        this.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      };
      pp$8.parseExpressionStatement = function(node, expr) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      };
      pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
        if (createNewLexicalScope === void 0) createNewLexicalScope = true;
        if (node === void 0) node = this.startNode();
        node.body = [];
        this.expect(types$1.braceL);
        if (createNewLexicalScope) {
          this.enterScope(0);
        }
        while (this.type !== types$1.braceR) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        if (exitStrict) {
          this.strict = false;
        }
        this.next();
        if (createNewLexicalScope) {
          this.exitScope();
        }
        return this.finishNode(node, "BlockStatement");
      };
      pp$8.parseFor = function(node, init) {
        node.init = init;
        this.expect(types$1.semi);
        node.test = this.type === types$1.semi ? null : this.parseExpression();
        this.expect(types$1.semi);
        node.update = this.type === types$1.parenR ? null : this.parseExpression();
        this.expect(types$1.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, "ForStatement");
      };
      pp$8.parseForIn = function(node, init) {
        var isForIn = this.type === types$1._in;
        this.next();
        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
          this.raise(
            init.start,
            (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
          );
        }
        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
        this.expect(types$1.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
      };
      pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
        node.declarations = [];
        node.kind = kind;
        for (; ; ) {
          var decl = this.startNode();
          this.parseVarId(decl, kind);
          if (this.eat(types$1.eq)) {
            decl.init = this.parseMaybeAssign(isFor);
          } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
            this.unexpected();
          } else if (!allowMissingInitializer && (kind === "using" || kind === "await using") && this.options.ecmaVersion >= 17 && this.type !== types$1._in && !this.isContextual("of")) {
            this.raise(this.lastTokEnd, "Missing initializer in " + kind + " declaration");
          } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
            this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
          } else {
            decl.init = null;
          }
          node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(types$1.comma)) {
            break;
          }
        }
        return node;
      };
      pp$8.parseVarId = function(decl, kind) {
        decl.id = kind === "using" || kind === "await using" ? this.parseIdent() : this.parseBindingAtom();
        this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
      };
      var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
      pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
        this.initFunction(node);
        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
          if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
            this.unexpected();
          }
          node.generator = this.eat(types$1.star);
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        if (statement & FUNC_STATEMENT) {
          node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
          if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
            this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
          }
        }
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(node.async, node.generator));
        if (!(statement & FUNC_STATEMENT)) {
          node.id = this.type === types$1.name ? this.parseIdent() : null;
        }
        this.parseFunctionParams(node);
        this.parseFunctionBody(node, allowExpressionBody, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
      };
      pp$8.parseFunctionParams = function(node) {
        this.expect(types$1.parenL);
        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
      };
      pp$8.parseClass = function(node, isStatement) {
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        this.parseClassId(node, isStatement);
        this.parseClassSuper(node);
        var privateNameMap = this.enterClassBody();
        var classBody = this.startNode();
        var hadConstructor = false;
        classBody.body = [];
        this.expect(types$1.braceL);
        while (this.type !== types$1.braceR) {
          var element = this.parseClassElement(node.superClass !== null);
          if (element) {
            classBody.body.push(element);
            if (element.type === "MethodDefinition" && element.kind === "constructor") {
              if (hadConstructor) {
                this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
              }
              hadConstructor = true;
            } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
              this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
            }
          }
        }
        this.strict = oldStrict;
        this.next();
        node.body = this.finishNode(classBody, "ClassBody");
        this.exitClassBody();
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      };
      pp$8.parseClassElement = function(constructorAllowsSuper) {
        if (this.eat(types$1.semi)) {
          return null;
        }
        var ecmaVersion2 = this.options.ecmaVersion;
        var node = this.startNode();
        var keyName = "";
        var isGenerator = false;
        var isAsync = false;
        var kind = "method";
        var isStatic = false;
        if (this.eatContextual("static")) {
          if (ecmaVersion2 >= 13 && this.eat(types$1.braceL)) {
            this.parseClassStaticBlock(node);
            return node;
          }
          if (this.isClassElementNameStart() || this.type === types$1.star) {
            isStatic = true;
          } else {
            keyName = "static";
          }
        }
        node.static = isStatic;
        if (!keyName && ecmaVersion2 >= 8 && this.eatContextual("async")) {
          if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
            isAsync = true;
          } else {
            keyName = "async";
          }
        }
        if (!keyName && (ecmaVersion2 >= 9 || !isAsync) && this.eat(types$1.star)) {
          isGenerator = true;
        }
        if (!keyName && !isAsync && !isGenerator) {
          var lastValue = this.value;
          if (this.eatContextual("get") || this.eatContextual("set")) {
            if (this.isClassElementNameStart()) {
              kind = lastValue;
            } else {
              keyName = lastValue;
            }
          }
        }
        if (keyName) {
          node.computed = false;
          node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
          node.key.name = keyName;
          this.finishNode(node.key, "Identifier");
        } else {
          this.parseClassElementName(node);
        }
        if (ecmaVersion2 < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
          var isConstructor = !node.static && checkKeyName(node, "constructor");
          var allowsDirectSuper = isConstructor && constructorAllowsSuper;
          if (isConstructor && kind !== "method") {
            this.raise(node.key.start, "Constructor can't have get/set modifier");
          }
          node.kind = isConstructor ? "constructor" : kind;
          this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
        } else {
          this.parseClassField(node);
        }
        return node;
      };
      pp$8.isClassElementNameStart = function() {
        return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
      };
      pp$8.parseClassElementName = function(element) {
        if (this.type === types$1.privateId) {
          if (this.value === "constructor") {
            this.raise(this.start, "Classes can't have an element named '#constructor'");
          }
          element.computed = false;
          element.key = this.parsePrivateIdent();
        } else {
          this.parsePropertyName(element);
        }
      };
      pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
        var key = method.key;
        if (method.kind === "constructor") {
          if (isGenerator) {
            this.raise(key.start, "Constructor can't be a generator");
          }
          if (isAsync) {
            this.raise(key.start, "Constructor can't be an async method");
          }
        } else if (method.static && checkKeyName(method, "prototype")) {
          this.raise(key.start, "Classes may not have a static property named prototype");
        }
        var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
        if (method.kind === "get" && value.params.length !== 0) {
          this.raiseRecoverable(value.start, "getter should have no params");
        }
        if (method.kind === "set" && value.params.length !== 1) {
          this.raiseRecoverable(value.start, "setter should have exactly one param");
        }
        if (method.kind === "set" && value.params[0].type === "RestElement") {
          this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
        }
        return this.finishNode(method, "MethodDefinition");
      };
      pp$8.parseClassField = function(field) {
        if (checkKeyName(field, "constructor")) {
          this.raise(field.key.start, "Classes can't have a field named 'constructor'");
        } else if (field.static && checkKeyName(field, "prototype")) {
          this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
        }
        if (this.eat(types$1.eq)) {
          this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);
          field.value = this.parseMaybeAssign();
          this.exitScope();
        } else {
          field.value = null;
        }
        this.semicolon();
        return this.finishNode(field, "PropertyDefinition");
      };
      pp$8.parseClassStaticBlock = function(node) {
        node.body = [];
        var oldLabels = this.labels;
        this.labels = [];
        this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
        while (this.type !== types$1.braceR) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        this.next();
        this.exitScope();
        this.labels = oldLabels;
        return this.finishNode(node, "StaticBlock");
      };
      pp$8.parseClassId = function(node, isStatement) {
        if (this.type === types$1.name) {
          node.id = this.parseIdent();
          if (isStatement) {
            this.checkLValSimple(node.id, BIND_LEXICAL, false);
          }
        } else {
          if (isStatement === true) {
            this.unexpected();
          }
          node.id = null;
        }
      };
      pp$8.parseClassSuper = function(node) {
        node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
      };
      pp$8.enterClassBody = function() {
        var element = { declared: /* @__PURE__ */ Object.create(null), used: [] };
        this.privateNameStack.push(element);
        return element.declared;
      };
      pp$8.exitClassBody = function() {
        var ref2 = this.privateNameStack.pop();
        var declared = ref2.declared;
        var used = ref2.used;
        if (!this.options.checkPrivateFields) {
          return;
        }
        var len = this.privateNameStack.length;
        var parent = len === 0 ? null : this.privateNameStack[len - 1];
        for (var i2 = 0; i2 < used.length; ++i2) {
          var id = used[i2];
          if (!hasOwn(declared, id.name)) {
            if (parent) {
              parent.used.push(id);
            } else {
              this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
            }
          }
        }
      };
      function isPrivateNameConflicted(privateNameMap, element) {
        var name = element.key.name;
        var curr = privateNameMap[name];
        var next = "true";
        if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
          next = (element.static ? "s" : "i") + element.kind;
        }
        if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
          privateNameMap[name] = "true";
          return false;
        } else if (!curr) {
          privateNameMap[name] = next;
          return false;
        } else {
          return true;
        }
      }
      function checkKeyName(node, name) {
        var computed = node.computed;
        var key = node.key;
        return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
      }
      pp$8.parseExportAllDeclaration = function(node, exports4) {
        if (this.options.ecmaVersion >= 11) {
          if (this.eatContextual("as")) {
            node.exported = this.parseModuleExportName();
            this.checkExport(exports4, node.exported, this.lastTokStart);
          } else {
            node.exported = null;
          }
        }
        this.expectContextual("from");
        if (this.type !== types$1.string) {
          this.unexpected();
        }
        node.source = this.parseExprAtom();
        if (this.options.ecmaVersion >= 16) {
          node.attributes = this.parseWithClause();
        }
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration");
      };
      pp$8.parseExport = function(node, exports4) {
        this.next();
        if (this.eat(types$1.star)) {
          return this.parseExportAllDeclaration(node, exports4);
        }
        if (this.eat(types$1._default)) {
          this.checkExport(exports4, "default", this.lastTokStart);
          node.declaration = this.parseExportDefaultDeclaration();
          return this.finishNode(node, "ExportDefaultDeclaration");
        }
        if (this.shouldParseExportStatement()) {
          node.declaration = this.parseExportDeclaration(node);
          if (node.declaration.type === "VariableDeclaration") {
            this.checkVariableExport(exports4, node.declaration.declarations);
          } else {
            this.checkExport(exports4, node.declaration.id, node.declaration.id.start);
          }
          node.specifiers = [];
          node.source = null;
          if (this.options.ecmaVersion >= 16) {
            node.attributes = [];
          }
        } else {
          node.declaration = null;
          node.specifiers = this.parseExportSpecifiers(exports4);
          if (this.eatContextual("from")) {
            if (this.type !== types$1.string) {
              this.unexpected();
            }
            node.source = this.parseExprAtom();
            if (this.options.ecmaVersion >= 16) {
              node.attributes = this.parseWithClause();
            }
          } else {
            for (var i2 = 0, list2 = node.specifiers; i2 < list2.length; i2 += 1) {
              var spec = list2[i2];
              this.checkUnreserved(spec.local);
              this.checkLocalExport(spec.local);
              if (spec.local.type === "Literal") {
                this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
              }
            }
            node.source = null;
            if (this.options.ecmaVersion >= 16) {
              node.attributes = [];
            }
          }
          this.semicolon();
        }
        return this.finishNode(node, "ExportNamedDeclaration");
      };
      pp$8.parseExportDeclaration = function(node) {
        return this.parseStatement(null);
      };
      pp$8.parseExportDefaultDeclaration = function() {
        var isAsync;
        if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
          var fNode = this.startNode();
          this.next();
          if (isAsync) {
            this.next();
          }
          return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
        } else if (this.type === types$1._class) {
          var cNode = this.startNode();
          return this.parseClass(cNode, "nullableID");
        } else {
          var declaration = this.parseMaybeAssign();
          this.semicolon();
          return declaration;
        }
      };
      pp$8.checkExport = function(exports4, name, pos) {
        if (!exports4) {
          return;
        }
        if (typeof name !== "string") {
          name = name.type === "Identifier" ? name.name : name.value;
        }
        if (hasOwn(exports4, name)) {
          this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
        }
        exports4[name] = true;
      };
      pp$8.checkPatternExport = function(exports4, pat) {
        var type = pat.type;
        if (type === "Identifier") {
          this.checkExport(exports4, pat, pat.start);
        } else if (type === "ObjectPattern") {
          for (var i2 = 0, list2 = pat.properties; i2 < list2.length; i2 += 1) {
            var prop = list2[i2];
            this.checkPatternExport(exports4, prop);
          }
        } else if (type === "ArrayPattern") {
          for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
            var elt = list$1[i$1];
            if (elt) {
              this.checkPatternExport(exports4, elt);
            }
          }
        } else if (type === "Property") {
          this.checkPatternExport(exports4, pat.value);
        } else if (type === "AssignmentPattern") {
          this.checkPatternExport(exports4, pat.left);
        } else if (type === "RestElement") {
          this.checkPatternExport(exports4, pat.argument);
        }
      };
      pp$8.checkVariableExport = function(exports4, decls) {
        if (!exports4) {
          return;
        }
        for (var i2 = 0, list2 = decls; i2 < list2.length; i2 += 1) {
          var decl = list2[i2];
          this.checkPatternExport(exports4, decl.id);
        }
      };
      pp$8.shouldParseExportStatement = function() {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
      };
      pp$8.parseExportSpecifier = function(exports4) {
        var node = this.startNode();
        node.local = this.parseModuleExportName();
        node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
        this.checkExport(
          exports4,
          node.exported,
          node.exported.start
        );
        return this.finishNode(node, "ExportSpecifier");
      };
      pp$8.parseExportSpecifiers = function(exports4) {
        var nodes = [], first = true;
        this.expect(types$1.braceL);
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          nodes.push(this.parseExportSpecifier(exports4));
        }
        return nodes;
      };
      pp$8.parseImport = function(node) {
        this.next();
        if (this.type === types$1.string) {
          node.specifiers = empty$1;
          node.source = this.parseExprAtom();
        } else {
          node.specifiers = this.parseImportSpecifiers();
          this.expectContextual("from");
          node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
        }
        if (this.options.ecmaVersion >= 16) {
          node.attributes = this.parseWithClause();
        }
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      };
      pp$8.parseImportSpecifier = function() {
        var node = this.startNode();
        node.imported = this.parseModuleExportName();
        if (this.eatContextual("as")) {
          node.local = this.parseIdent();
        } else {
          this.checkUnreserved(node.imported);
          node.local = node.imported;
        }
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportSpecifier");
      };
      pp$8.parseImportDefaultSpecifier = function() {
        var node = this.startNode();
        node.local = this.parseIdent();
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportDefaultSpecifier");
      };
      pp$8.parseImportNamespaceSpecifier = function() {
        var node = this.startNode();
        this.next();
        this.expectContextual("as");
        node.local = this.parseIdent();
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportNamespaceSpecifier");
      };
      pp$8.parseImportSpecifiers = function() {
        var nodes = [], first = true;
        if (this.type === types$1.name) {
          nodes.push(this.parseImportDefaultSpecifier());
          if (!this.eat(types$1.comma)) {
            return nodes;
          }
        }
        if (this.type === types$1.star) {
          nodes.push(this.parseImportNamespaceSpecifier());
          return nodes;
        }
        this.expect(types$1.braceL);
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          nodes.push(this.parseImportSpecifier());
        }
        return nodes;
      };
      pp$8.parseWithClause = function() {
        var nodes = [];
        if (!this.eat(types$1._with)) {
          return nodes;
        }
        this.expect(types$1.braceL);
        var attributeKeys = {};
        var first = true;
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var attr = this.parseImportAttribute();
          var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
          if (hasOwn(attributeKeys, keyName)) {
            this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'");
          }
          attributeKeys[keyName] = true;
          nodes.push(attr);
        }
        return nodes;
      };
      pp$8.parseImportAttribute = function() {
        var node = this.startNode();
        node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
        this.expect(types$1.colon);
        if (this.type !== types$1.string) {
          this.unexpected();
        }
        node.value = this.parseExprAtom();
        return this.finishNode(node, "ImportAttribute");
      };
      pp$8.parseModuleExportName = function() {
        if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
          var stringLiteral = this.parseLiteral(this.value);
          if (loneSurrogate.test(stringLiteral.value)) {
            this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
          }
          return stringLiteral;
        }
        return this.parseIdent(true);
      };
      pp$8.adaptDirectivePrologue = function(statements) {
        for (var i2 = 0; i2 < statements.length && this.isDirectiveCandidate(statements[i2]); ++i2) {
          statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
        }
      };
      pp$8.isDirectiveCandidate = function(statement) {
        return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
        (this.input[statement.start] === '"' || this.input[statement.start] === "'");
      };
      var pp$7 = Parser.prototype;
      pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 6 && node) {
          switch (node.type) {
            case "Identifier":
              if (this.inAsync && node.name === "await") {
                this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
              }
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              node.type = "ObjectPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              for (var i2 = 0, list2 = node.properties; i2 < list2.length; i2 += 1) {
                var prop = list2[i2];
                this.toAssignable(prop, isBinding);
                if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                  this.raise(prop.argument.start, "Unexpected token");
                }
              }
              break;
            case "Property":
              if (node.kind !== "init") {
                this.raise(node.key.start, "Object pattern can't contain getter or setter");
              }
              this.toAssignable(node.value, isBinding);
              break;
            case "ArrayExpression":
              node.type = "ArrayPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              this.toAssignableList(node.elements, isBinding);
              break;
            case "SpreadElement":
              node.type = "RestElement";
              this.toAssignable(node.argument, isBinding);
              if (node.argument.type === "AssignmentPattern") {
                this.raise(node.argument.start, "Rest elements cannot have a default value");
              }
              break;
            case "AssignmentExpression":
              if (node.operator !== "=") {
                this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
              }
              node.type = "AssignmentPattern";
              delete node.operator;
              this.toAssignable(node.left, isBinding);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(node.expression, isBinding, refDestructuringErrors);
              break;
            case "ChainExpression":
              this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!isBinding) {
                break;
              }
            default:
              this.raise(node.start, "Assigning to rvalue");
          }
        } else if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        return node;
      };
      pp$7.toAssignableList = function(exprList, isBinding) {
        var end = exprList.length;
        for (var i2 = 0; i2 < end; i2++) {
          var elt = exprList[i2];
          if (elt) {
            this.toAssignable(elt, isBinding);
          }
        }
        if (end) {
          var last = exprList[end - 1];
          if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
            this.unexpected(last.argument.start);
          }
        }
        return exprList;
      };
      pp$7.parseSpread = function(refDestructuringErrors) {
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        return this.finishNode(node, "SpreadElement");
      };
      pp$7.parseRestBinding = function() {
        var node = this.startNode();
        this.next();
        if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
          this.unexpected();
        }
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
      };
      pp$7.parseBindingAtom = function() {
        if (this.options.ecmaVersion >= 6) {
          switch (this.type) {
            case types$1.bracketL:
              var node = this.startNode();
              this.next();
              node.elements = this.parseBindingList(types$1.bracketR, true, true);
              return this.finishNode(node, "ArrayPattern");
            case types$1.braceL:
              return this.parseObj(true);
          }
        }
        return this.parseIdent();
      };
      pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(types$1.comma);
          }
          if (allowEmpty && this.type === types$1.comma) {
            elts.push(null);
          } else if (allowTrailingComma && this.afterTrailingComma(close)) {
            break;
          } else if (this.type === types$1.ellipsis) {
            var rest = this.parseRestBinding();
            this.parseBindingListItem(rest);
            elts.push(rest);
            if (this.type === types$1.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            this.expect(close);
            break;
          } else {
            elts.push(this.parseAssignableListItem(allowModifiers));
          }
        }
        return elts;
      };
      pp$7.parseAssignableListItem = function(allowModifiers) {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        return elem;
      };
      pp$7.parseBindingListItem = function(param) {
        return param;
      };
      pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
        left = left || this.parseBindingAtom();
        if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
          return left;
        }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, "AssignmentPattern");
      };
      pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE;
        var isBind = bindingType !== BIND_NONE;
        switch (expr.type) {
          case "Identifier":
            if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
              this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
            }
            if (isBind) {
              if (bindingType === BIND_LEXICAL && expr.name === "let") {
                this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
              }
              if (checkClashes) {
                if (hasOwn(checkClashes, expr.name)) {
                  this.raiseRecoverable(expr.start, "Argument name clash");
                }
                checkClashes[expr.name] = true;
              }
              if (bindingType !== BIND_OUTSIDE) {
                this.declareName(expr.name, bindingType, expr.start);
              }
            }
            break;
          case "ChainExpression":
            this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding member expression");
            }
            break;
          case "ParenthesizedExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding parenthesized expression");
            }
            return this.checkLValSimple(expr.expression, bindingType, checkClashes);
          default:
            this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
        }
      };
      pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE;
        switch (expr.type) {
          case "ObjectPattern":
            for (var i2 = 0, list2 = expr.properties; i2 < list2.length; i2 += 1) {
              var prop = list2[i2];
              this.checkLValInnerPattern(prop, bindingType, checkClashes);
            }
            break;
          case "ArrayPattern":
            for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
              var elem = list$1[i$1];
              if (elem) {
                this.checkLValInnerPattern(elem, bindingType, checkClashes);
              }
            }
            break;
          default:
            this.checkLValSimple(expr, bindingType, checkClashes);
        }
      };
      pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE;
        switch (expr.type) {
          case "Property":
            this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
            break;
          case "AssignmentPattern":
            this.checkLValPattern(expr.left, bindingType, checkClashes);
            break;
          case "RestElement":
            this.checkLValPattern(expr.argument, bindingType, checkClashes);
            break;
          default:
            this.checkLValPattern(expr, bindingType, checkClashes);
        }
      };
      var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
        this.token = token;
        this.isExpr = !!isExpr;
        this.preserveSpace = !!preserveSpace;
        this.override = override;
        this.generator = !!generator;
      };
      var types = {
        b_stat: new TokContext("{", false),
        b_expr: new TokContext("{", true),
        b_tmpl: new TokContext("${", false),
        p_stat: new TokContext("(", false),
        p_expr: new TokContext("(", true),
        q_tmpl: new TokContext("`", true, true, function(p) {
          return p.tryReadTemplateToken();
        }),
        f_stat: new TokContext("function", false),
        f_expr: new TokContext("function", true),
        f_expr_gen: new TokContext("function", true, false, null, true),
        f_gen: new TokContext("function", false, false, null, true)
      };
      var pp$6 = Parser.prototype;
      pp$6.initialContext = function() {
        return [types.b_stat];
      };
      pp$6.curContext = function() {
        return this.context[this.context.length - 1];
      };
      pp$6.braceIsBlock = function(prevType) {
        var parent = this.curContext();
        if (parent === types.f_expr || parent === types.f_stat) {
          return true;
        }
        if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
          return !parent.isExpr;
        }
        if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
          return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
        }
        if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
          return true;
        }
        if (prevType === types$1.braceL) {
          return parent === types.b_stat;
        }
        if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
          return false;
        }
        return !this.exprAllowed;
      };
      pp$6.inGeneratorContext = function() {
        for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
          var context = this.context[i2];
          if (context.token === "function") {
            return context.generator;
          }
        }
        return false;
      };
      pp$6.updateContext = function(prevType) {
        var update, type = this.type;
        if (type.keyword && prevType === types$1.dot) {
          this.exprAllowed = false;
        } else if (update = type.updateContext) {
          update.call(this, prevType);
        } else {
          this.exprAllowed = type.beforeExpr;
        }
      };
      pp$6.overrideContext = function(tokenCtx) {
        if (this.curContext() !== tokenCtx) {
          this.context[this.context.length - 1] = tokenCtx;
        }
      };
      types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
        if (this.context.length === 1) {
          this.exprAllowed = true;
          return;
        }
        var out = this.context.pop();
        if (out === types.b_stat && this.curContext().token === "function") {
          out = this.context.pop();
        }
        this.exprAllowed = !out.isExpr;
      };
      types$1.braceL.updateContext = function(prevType) {
        this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
        this.exprAllowed = true;
      };
      types$1.dollarBraceL.updateContext = function() {
        this.context.push(types.b_tmpl);
        this.exprAllowed = true;
      };
      types$1.parenL.updateContext = function(prevType) {
        var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
        this.context.push(statementParens ? types.p_stat : types.p_expr);
        this.exprAllowed = true;
      };
      types$1.incDec.updateContext = function() {
      };
      types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
        if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
          this.context.push(types.f_expr);
        } else {
          this.context.push(types.f_stat);
        }
        this.exprAllowed = false;
      };
      types$1.colon.updateContext = function() {
        if (this.curContext().token === "function") {
          this.context.pop();
        }
        this.exprAllowed = true;
      };
      types$1.backQuote.updateContext = function() {
        if (this.curContext() === types.q_tmpl) {
          this.context.pop();
        } else {
          this.context.push(types.q_tmpl);
        }
        this.exprAllowed = false;
      };
      types$1.star.updateContext = function(prevType) {
        if (prevType === types$1._function) {
          var index = this.context.length - 1;
          if (this.context[index] === types.f_expr) {
            this.context[index] = types.f_expr_gen;
          } else {
            this.context[index] = types.f_gen;
          }
        }
        this.exprAllowed = true;
      };
      types$1.name.updateContext = function(prevType) {
        var allowed = false;
        if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
          if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
            allowed = true;
          }
        }
        this.exprAllowed = allowed;
      };
      var pp$5 = Parser.prototype;
      pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
          return;
        }
        if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
          return;
        }
        var key = prop.key;
        var name;
        switch (key.type) {
          case "Identifier":
            name = key.name;
            break;
          case "Literal":
            name = String(key.value);
            break;
          default:
            return;
        }
        var kind = prop.kind;
        if (this.options.ecmaVersion >= 6) {
          if (name === "__proto__" && kind === "init") {
            if (propHash.proto) {
              if (refDestructuringErrors) {
                if (refDestructuringErrors.doubleProto < 0) {
                  refDestructuringErrors.doubleProto = key.start;
                }
              } else {
                this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
              }
            }
            propHash.proto = true;
          }
          return;
        }
        name = "$" + name;
        var other = propHash[name];
        if (other) {
          var redefinition;
          if (kind === "init") {
            redefinition = this.strict && other.init || other.get || other.set;
          } else {
            redefinition = other.init || other[kind];
          }
          if (redefinition) {
            this.raiseRecoverable(key.start, "Redefinition of property");
          }
        } else {
          other = propHash[name] = {
            init: false,
            get: false,
            set: false
          };
        }
        other[kind] = true;
      };
      pp$5.parseExpression = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
        if (this.type === types$1.comma) {
          var node = this.startNodeAt(startPos, startLoc);
          node.expressions = [expr];
          while (this.eat(types$1.comma)) {
            node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
          }
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      };
      pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
          if (this.inGenerator) {
            return this.parseYield(forInit);
          } else {
            this.exprAllowed = false;
          }
        }
        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
        if (refDestructuringErrors) {
          oldParenAssign = refDestructuringErrors.parenthesizedAssign;
          oldTrailingComma = refDestructuringErrors.trailingComma;
          oldDoubleProto = refDestructuringErrors.doubleProto;
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
          refDestructuringErrors = new DestructuringErrors();
          ownDestructuringErrors = true;
        }
        var startPos = this.start, startLoc = this.startLoc;
        if (this.type === types$1.parenL || this.type === types$1.name) {
          this.potentialArrowAt = this.start;
          this.potentialArrowInForAwait = forInit === "await";
        }
        var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startPos, startLoc);
        }
        if (this.type.isAssign) {
          var node = this.startNodeAt(startPos, startLoc);
          node.operator = this.value;
          if (this.type === types$1.eq) {
            left = this.toAssignable(left, false, refDestructuringErrors);
          }
          if (!ownDestructuringErrors) {
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
          }
          if (refDestructuringErrors.shorthandAssign >= left.start) {
            refDestructuringErrors.shorthandAssign = -1;
          }
          if (this.type === types$1.eq) {
            this.checkLValPattern(left);
          } else {
            this.checkLValSimple(left);
          }
          node.left = left;
          this.next();
          node.right = this.parseMaybeAssign(forInit);
          if (oldDoubleProto > -1) {
            refDestructuringErrors.doubleProto = oldDoubleProto;
          }
          return this.finishNode(node, "AssignmentExpression");
        } else {
          if (ownDestructuringErrors) {
            this.checkExpressionErrors(refDestructuringErrors, true);
          }
        }
        if (oldParenAssign > -1) {
          refDestructuringErrors.parenthesizedAssign = oldParenAssign;
        }
        if (oldTrailingComma > -1) {
          refDestructuringErrors.trailingComma = oldTrailingComma;
        }
        return left;
      };
      pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprOps(forInit, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        if (this.eat(types$1.question)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssign();
          this.expect(types$1.colon);
          node.alternate = this.parseMaybeAssign(forInit);
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      };
      pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
      };
      pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
        var prec = this.type.binop;
        if (prec != null && (!forInit || this.type !== types$1._in)) {
          if (prec > minPrec) {
            var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
            var coalesce = this.type === types$1.coalesce;
            if (coalesce) {
              prec = types$1.logicalAND.binop;
            }
            var op = this.value;
            this.next();
            var startPos = this.start, startLoc = this.startLoc;
            var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
            var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
            if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
              this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
            }
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
          }
        }
        return left;
      };
      pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
        if (right.type === "PrivateIdentifier") {
          this.raise(right.start, "Private identifier can only be left side of binary expression");
        }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.operator = op;
        node.right = right;
        return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
      };
      pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
        var startPos = this.start, startLoc = this.startLoc, expr;
        if (this.isContextual("await") && this.canAwait) {
          expr = this.parseAwait(forInit);
          sawUnary = true;
        } else if (this.type.prefix) {
          var node = this.startNode(), update = this.type === types$1.incDec;
          node.operator = this.value;
          node.prefix = true;
          this.next();
          node.argument = this.parseMaybeUnary(null, true, update, forInit);
          this.checkExpressionErrors(refDestructuringErrors, true);
          if (update) {
            this.checkLValSimple(node.argument);
          } else if (this.strict && node.operator === "delete" && isLocalVariableAccess(node.argument)) {
            this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
          } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
            this.raiseRecoverable(node.start, "Private fields can not be deleted");
          } else {
            sawUnary = true;
          }
          expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
        } else if (!sawUnary && this.type === types$1.privateId) {
          if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
            this.unexpected();
          }
          expr = this.parsePrivateIdent();
          if (this.type !== types$1._in) {
            this.unexpected();
          }
        } else {
          expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
          if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
          }
          while (this.type.postfix && !this.canInsertSemicolon()) {
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.operator = this.value;
            node$1.prefix = false;
            node$1.argument = expr;
            this.checkLValSimple(expr);
            this.next();
            expr = this.finishNode(node$1, "UpdateExpression");
          }
        }
        if (!incDec && this.eat(types$1.starstar)) {
          if (sawUnary) {
            this.unexpected(this.lastTokStart);
          } else {
            return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
          }
        } else {
          return expr;
        }
      };
      function isLocalVariableAccess(node) {
        return node.type === "Identifier" || node.type === "ParenthesizedExpression" && isLocalVariableAccess(node.expression);
      }
      function isPrivateFieldAccess(node) {
        return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression) || node.type === "ParenthesizedExpression" && isPrivateFieldAccess(node.expression);
      }
      pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprAtom(refDestructuringErrors, forInit);
        if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
          return expr;
        }
        var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
        if (refDestructuringErrors && result.type === "MemberExpression") {
          if (refDestructuringErrors.parenthesizedAssign >= result.start) {
            refDestructuringErrors.parenthesizedAssign = -1;
          }
          if (refDestructuringErrors.parenthesizedBind >= result.start) {
            refDestructuringErrors.parenthesizedBind = -1;
          }
          if (refDestructuringErrors.trailingComma >= result.start) {
            refDestructuringErrors.trailingComma = -1;
          }
        }
        return result;
      };
      pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
        var optionalChained = false;
        while (true) {
          var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
          if (element.optional) {
            optionalChained = true;
          }
          if (element === base || element.type === "ArrowFunctionExpression") {
            if (optionalChained) {
              var chainNode = this.startNodeAt(startPos, startLoc);
              chainNode.expression = element;
              element = this.finishNode(chainNode, "ChainExpression");
            }
            return element;
          }
          base = element;
        }
      };
      pp$5.shouldParseAsyncArrow = function() {
        return !this.canInsertSemicolon() && this.eat(types$1.arrow);
      };
      pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
      };
      pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
        var optionalSupported = this.options.ecmaVersion >= 11;
        var optional = optionalSupported && this.eat(types$1.questionDot);
        if (noCalls && optional) {
          this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        }
        var computed = this.eat(types$1.bracketL);
        if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          if (computed) {
            node.property = this.parseExpression();
            this.expect(types$1.bracketR);
          } else if (this.type === types$1.privateId && base.type !== "Super") {
            node.property = this.parsePrivateIdent();
          } else {
            node.property = this.parseIdent(this.options.allowReserved !== "never");
          }
          node.computed = !!computed;
          if (optionalSupported) {
            node.optional = optional;
          }
          base = this.finishNode(node, "MemberExpression");
        } else if (!noCalls && this.eat(types$1.parenL)) {
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
          if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            if (this.awaitIdentPos > 0) {
              this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
            }
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            this.awaitIdentPos = oldAwaitIdentPos;
            return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.callee = base;
          node$1.arguments = exprList;
          if (optionalSupported) {
            node$1.optional = optional;
          }
          base = this.finishNode(node$1, "CallExpression");
        } else if (this.type === types$1.backQuote) {
          if (optional || optionalChained) {
            this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
          }
          var node$2 = this.startNodeAt(startPos, startLoc);
          node$2.tag = base;
          node$2.quasi = this.parseTemplate({ isTagged: true });
          base = this.finishNode(node$2, "TaggedTemplateExpression");
        }
        return base;
      };
      pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
        if (this.type === types$1.slash) {
          this.readRegexp();
        }
        var node, canBeArrow = this.potentialArrowAt === this.start;
        switch (this.type) {
          case types$1._super:
            if (!this.allowSuper) {
              this.raise(this.start, "'super' keyword outside a method");
            }
            node = this.startNode();
            this.next();
            if (this.type === types$1.parenL && !this.allowDirectSuper) {
              this.raise(node.start, "super() call outside constructor of a subclass");
            }
            if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
              this.unexpected();
            }
            return this.finishNode(node, "Super");
          case types$1._this:
            node = this.startNode();
            this.next();
            return this.finishNode(node, "ThisExpression");
          case types$1.name:
            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
            var id = this.parseIdent(false);
            if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
              this.overrideContext(types.f_expr);
              return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
            }
            if (canBeArrow && !this.canInsertSemicolon()) {
              if (this.eat(types$1.arrow)) {
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
              }
              if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
                id = this.parseIdent(false);
                if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
                  this.unexpected();
                }
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
              }
            }
            return id;
          case types$1.regexp:
            var value = this.value;
            node = this.parseLiteral(value.value);
            node.regex = { pattern: value.pattern, flags: value.flags };
            return node;
          case types$1.num:
          case types$1.string:
            return this.parseLiteral(this.value);
          case types$1._null:
          case types$1._true:
          case types$1._false:
            node = this.startNode();
            node.value = this.type === types$1._null ? null : this.type === types$1._true;
            node.raw = this.type.keyword;
            this.next();
            return this.finishNode(node, "Literal");
          case types$1.parenL:
            var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
            if (refDestructuringErrors) {
              if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
                refDestructuringErrors.parenthesizedAssign = start;
              }
              if (refDestructuringErrors.parenthesizedBind < 0) {
                refDestructuringErrors.parenthesizedBind = start;
              }
            }
            return expr;
          case types$1.bracketL:
            node = this.startNode();
            this.next();
            node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
            return this.finishNode(node, "ArrayExpression");
          case types$1.braceL:
            this.overrideContext(types.b_expr);
            return this.parseObj(false, refDestructuringErrors);
          case types$1._function:
            node = this.startNode();
            this.next();
            return this.parseFunction(node, 0);
          case types$1._class:
            return this.parseClass(this.startNode(), false);
          case types$1._new:
            return this.parseNew();
          case types$1.backQuote:
            return this.parseTemplate();
          case types$1._import:
            if (this.options.ecmaVersion >= 11) {
              return this.parseExprImport(forNew);
            } else {
              return this.unexpected();
            }
          default:
            return this.parseExprAtomDefault();
        }
      };
      pp$5.parseExprAtomDefault = function() {
        this.unexpected();
      };
      pp$5.parseExprImport = function(forNew) {
        var node = this.startNode();
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword import");
        }
        this.next();
        if (this.type === types$1.parenL && !forNew) {
          return this.parseDynamicImport(node);
        } else if (this.type === types$1.dot) {
          var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
          meta.name = "import";
          node.meta = this.finishNode(meta, "Identifier");
          return this.parseImportMeta(node);
        } else {
          this.unexpected();
        }
      };
      pp$5.parseDynamicImport = function(node) {
        this.next();
        node.source = this.parseMaybeAssign();
        if (this.options.ecmaVersion >= 16) {
          if (!this.eat(types$1.parenR)) {
            this.expect(types$1.comma);
            if (!this.afterTrailingComma(types$1.parenR)) {
              node.options = this.parseMaybeAssign();
              if (!this.eat(types$1.parenR)) {
                this.expect(types$1.comma);
                if (!this.afterTrailingComma(types$1.parenR)) {
                  this.unexpected();
                }
              }
            } else {
              node.options = null;
            }
          } else {
            node.options = null;
          }
        } else {
          if (!this.eat(types$1.parenR)) {
            var errorPos = this.start;
            if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
              this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
            } else {
              this.unexpected(errorPos);
            }
          }
        }
        return this.finishNode(node, "ImportExpression");
      };
      pp$5.parseImportMeta = function(node) {
        this.next();
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "meta") {
          this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
        }
        if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
          this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
        }
        return this.finishNode(node, "MetaProperty");
      };
      pp$5.parseLiteral = function(value) {
        var node = this.startNode();
        node.value = value;
        node.raw = this.input.slice(this.start, this.end);
        if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
          node.bigint = node.value != null ? node.value.toString() : node.raw.slice(0, -1).replace(/_/g, "");
        }
        this.next();
        return this.finishNode(node, "Literal");
      };
      pp$5.parseParenExpression = function() {
        this.expect(types$1.parenL);
        var val = this.parseExpression();
        this.expect(types$1.parenR);
        return val;
      };
      pp$5.shouldParseArrow = function(exprList) {
        return !this.canInsertSemicolon();
      };
      pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var innerStartPos = this.start, innerStartLoc = this.startLoc;
          var exprList = [], first = true, lastIsComma = false;
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          this.yieldPos = 0;
          this.awaitPos = 0;
          while (this.type !== types$1.parenR) {
            first ? first = false : this.expect(types$1.comma);
            if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
              lastIsComma = true;
              break;
            } else if (this.type === types$1.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseParenItem(this.parseRestBinding()));
              if (this.type === types$1.comma) {
                this.raiseRecoverable(
                  this.start,
                  "Comma is not permitted after the rest element"
                );
              }
              break;
            } else {
              exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
            }
          }
          var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
          this.expect(types$1.parenR);
          if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
          }
          if (!exprList.length || lastIsComma) {
            this.unexpected(this.lastTokStart);
          }
          if (spreadStart) {
            this.unexpected(spreadStart);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }
        if (this.options.preserveParens) {
          var par = this.startNodeAt(startPos, startLoc);
          par.expression = val;
          return this.finishNode(par, "ParenthesizedExpression");
        } else {
          return val;
        }
      };
      pp$5.parseParenItem = function(item) {
        return item;
      };
      pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
      };
      var empty = [];
      pp$5.parseNew = function() {
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        }
        var node = this.startNode();
        this.next();
        if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
          var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
          meta.name = "new";
          node.meta = this.finishNode(meta, "Identifier");
          this.next();
          var containsEsc = this.containsEsc;
          node.property = this.parseIdent(true);
          if (node.property.name !== "target") {
            this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
          }
          if (containsEsc) {
            this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
          }
          if (!this.allowNewDotTarget) {
            this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
          }
          return this.finishNode(node, "MetaProperty");
        }
        var startPos = this.start, startLoc = this.startLoc;
        node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
        if (this.eat(types$1.parenL)) {
          node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
        } else {
          node.arguments = empty;
        }
        return this.finishNode(node, "NewExpression");
      };
      pp$5.parseTemplateElement = function(ref2) {
        var isTagged = ref2.isTagged;
        var elem = this.startNode();
        if (this.type === types$1.invalidTemplate) {
          if (!isTagged) {
            this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
          }
          elem.value = {
            raw: this.value.replace(/\r\n?/g, "\n"),
            cooked: null
          };
        } else {
          elem.value = {
            raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
            cooked: this.value
          };
        }
        this.next();
        elem.tail = this.type === types$1.backQuote;
        return this.finishNode(elem, "TemplateElement");
      };
      pp$5.parseTemplate = function(ref2) {
        if (ref2 === void 0) ref2 = {};
        var isTagged = ref2.isTagged;
        if (isTagged === void 0) isTagged = false;
        var node = this.startNode();
        this.next();
        node.expressions = [];
        var curElt = this.parseTemplateElement({ isTagged });
        node.quasis = [curElt];
        while (!curElt.tail) {
          if (this.type === types$1.eof) {
            this.raise(this.pos, "Unterminated template literal");
          }
          this.expect(types$1.dollarBraceL);
          node.expressions.push(this.parseExpression());
          this.expect(types$1.braceR);
          node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
        }
        this.next();
        return this.finishNode(node, "TemplateLiteral");
      };
      pp$5.isAsyncProp = function(prop) {
        return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$5.parseObj = function(isPattern, refDestructuringErrors) {
        var node = this.startNode(), first = true, propHash = {};
        node.properties = [];
        this.next();
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var prop = this.parseProperty(isPattern, refDestructuringErrors);
          if (!isPattern) {
            this.checkPropClash(prop, propHash, refDestructuringErrors);
          }
          node.properties.push(prop);
        }
        return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
      };
      pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
        var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
        if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
          if (isPattern) {
            prop.argument = this.parseIdent(false);
            if (this.type === types$1.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            return this.finishNode(prop, "RestElement");
          }
          prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
          if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
          return this.finishNode(prop, "SpreadElement");
        }
        if (this.options.ecmaVersion >= 6) {
          prop.method = false;
          prop.shorthand = false;
          if (isPattern || refDestructuringErrors) {
            startPos = this.start;
            startLoc = this.startLoc;
          }
          if (!isPattern) {
            isGenerator = this.eat(types$1.star);
          }
        }
        var containsEsc = this.containsEsc;
        this.parsePropertyName(prop);
        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
          isAsync = true;
          isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
          this.parsePropertyName(prop);
        } else {
          isAsync = false;
        }
        this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
        return this.finishNode(prop, "Property");
      };
      pp$5.parseGetterSetter = function(prop) {
        var kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        prop.kind = kind;
        var paramCount = prop.kind === "get" ? 0 : 1;
        if (prop.value.params.length !== paramCount) {
          var start = prop.value.start;
          if (prop.kind === "get") {
            this.raiseRecoverable(start, "getter should have no params");
          } else {
            this.raiseRecoverable(start, "setter should have exactly one param");
          }
        } else {
          if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
            this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
          }
        }
      };
      pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
        if ((isGenerator || isAsync) && this.type === types$1.colon) {
          this.unexpected();
        }
        if (this.eat(types$1.colon)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
          prop.kind = "init";
        } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
          if (isPattern) {
            this.unexpected();
          }
          prop.method = true;
          prop.value = this.parseMethod(isGenerator, isAsync);
          prop.kind = "init";
        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.parseGetterSetter(prop);
        } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.checkUnreserved(prop.key);
          if (prop.key.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = startPos;
          }
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else if (this.type === types$1.eq && refDestructuringErrors) {
            if (refDestructuringErrors.shorthandAssign < 0) {
              refDestructuringErrors.shorthandAssign = this.start;
            }
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else {
            prop.value = this.copyNode(prop.key);
          }
          prop.kind = "init";
          prop.shorthand = true;
        } else {
          this.unexpected();
        }
      };
      pp$5.parsePropertyName = function(prop) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(types$1.bracketL)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssign();
            this.expect(types$1.bracketR);
            return prop.key;
          } else {
            prop.computed = false;
          }
        }
        return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      };
      pp$5.initFunction = function(node) {
        node.id = null;
        if (this.options.ecmaVersion >= 6) {
          node.generator = node.expression = false;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = false;
        }
      };
      pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
        var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.initFunction(node);
        if (this.options.ecmaVersion >= 6) {
          node.generator = isGenerator;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
        this.expect(types$1.parenL);
        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node, false, true, false);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "FunctionExpression");
      };
      pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
        this.initFunction(node);
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        node.params = this.toAssignableList(params, true);
        this.parseFunctionBody(node, true, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "ArrowFunctionExpression");
      };
      pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
        var isExpression = isArrowFunction && this.type !== types$1.braceL;
        var oldStrict = this.strict, useStrict = false;
        if (isExpression) {
          node.body = this.parseMaybeAssign(forInit);
          node.expression = true;
          this.checkParams(node, false);
        } else {
          var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
          if (!oldStrict || nonSimple) {
            useStrict = this.strictDirective(this.end);
            if (useStrict && nonSimple) {
              this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            }
          }
          var oldLabels = this.labels;
          this.labels = [];
          if (useStrict) {
            this.strict = true;
          }
          this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
          if (this.strict && node.id) {
            this.checkLValSimple(node.id, BIND_OUTSIDE);
          }
          node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
          node.expression = false;
          this.adaptDirectivePrologue(node.body.body);
          this.labels = oldLabels;
        }
        this.exitScope();
      };
      pp$5.isSimpleParamList = function(params) {
        for (var i2 = 0, list2 = params; i2 < list2.length; i2 += 1) {
          var param = list2[i2];
          if (param.type !== "Identifier") {
            return false;
          }
        }
        return true;
      };
      pp$5.checkParams = function(node, allowDuplicates) {
        var nameHash = /* @__PURE__ */ Object.create(null);
        for (var i2 = 0, list2 = node.params; i2 < list2.length; i2 += 1) {
          var param = list2[i2];
          this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
        }
      };
      pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (!first) {
            this.expect(types$1.comma);
            if (allowTrailingComma && this.afterTrailingComma(close)) {
              break;
            }
          } else {
            first = false;
          }
          var elt = void 0;
          if (allowEmpty && this.type === types$1.comma) {
            elt = null;
          } else if (this.type === types$1.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
              refDestructuringErrors.trailingComma = this.start;
            }
          } else {
            elt = this.parseMaybeAssign(false, refDestructuringErrors);
          }
          elts.push(elt);
        }
        return elts;
      };
      pp$5.checkUnreserved = function(ref2) {
        var start = ref2.start;
        var end = ref2.end;
        var name = ref2.name;
        if (this.inGenerator && name === "yield") {
          this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
        }
        if (this.inAsync && name === "await") {
          this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
        }
        if (!(this.currentThisScope().flags & SCOPE_VAR) && name === "arguments") {
          this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
        }
        if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
          this.raise(start, "Cannot use " + name + " in class static initialization block");
        }
        if (this.keywords.test(name)) {
          this.raise(start, "Unexpected keyword '" + name + "'");
        }
        if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
          return;
        }
        var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
        if (re.test(name)) {
          if (!this.inAsync && name === "await") {
            this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
          }
          this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
        }
      };
      pp$5.parseIdent = function(liberal) {
        var node = this.parseIdentNode();
        this.next(!!liberal);
        this.finishNode(node, "Identifier");
        if (!liberal) {
          this.checkUnreserved(node);
          if (node.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = node.start;
          }
        }
        return node;
      };
      pp$5.parseIdentNode = function() {
        var node = this.startNode();
        if (this.type === types$1.name) {
          node.name = this.value;
        } else if (this.type.keyword) {
          node.name = this.type.keyword;
          if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
            this.context.pop();
          }
          this.type = types$1.name;
        } else {
          this.unexpected();
        }
        return node;
      };
      pp$5.parsePrivateIdent = function() {
        var node = this.startNode();
        if (this.type === types$1.privateId) {
          node.name = this.value;
        } else {
          this.unexpected();
        }
        this.next();
        this.finishNode(node, "PrivateIdentifier");
        if (this.options.checkPrivateFields) {
          if (this.privateNameStack.length === 0) {
            this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
          } else {
            this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
          }
        }
        return node;
      };
      pp$5.parseYield = function(forInit) {
        if (!this.yieldPos) {
          this.yieldPos = this.start;
        }
        var node = this.startNode();
        this.next();
        if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
          node.delegate = false;
          node.argument = null;
        } else {
          node.delegate = this.eat(types$1.star);
          node.argument = this.parseMaybeAssign(forInit);
        }
        return this.finishNode(node, "YieldExpression");
      };
      pp$5.parseAwait = function(forInit) {
        if (!this.awaitPos) {
          this.awaitPos = this.start;
        }
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeUnary(null, true, false, forInit);
        return this.finishNode(node, "AwaitExpression");
      };
      var pp$4 = Parser.prototype;
      pp$4.raise = function(pos, message) {
        var loc = getLineInfo(this.input, pos);
        message += " (" + loc.line + ":" + loc.column + ")";
        if (this.sourceFile) {
          message += " in " + this.sourceFile;
        }
        var err = new SyntaxError(message);
        err.pos = pos;
        err.loc = loc;
        err.raisedAt = this.pos;
        throw err;
      };
      pp$4.raiseRecoverable = pp$4.raise;
      pp$4.curPosition = function() {
        if (this.options.locations) {
          return new Position(this.curLine, this.pos - this.lineStart);
        }
      };
      var pp$3 = Parser.prototype;
      var Scope = function Scope2(flags) {
        this.flags = flags;
        this.var = [];
        this.lexical = [];
        this.functions = [];
      };
      pp$3.enterScope = function(flags) {
        this.scopeStack.push(new Scope(flags));
      };
      pp$3.exitScope = function() {
        this.scopeStack.pop();
      };
      pp$3.treatFunctionsAsVarInScope = function(scope) {
        return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
      };
      pp$3.declareName = function(name, bindingType, pos) {
        var redeclared = false;
        if (bindingType === BIND_LEXICAL) {
          var scope = this.currentScope();
          redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
          scope.lexical.push(name);
          if (this.inModule && scope.flags & SCOPE_TOP) {
            delete this.undefinedExports[name];
          }
        } else if (bindingType === BIND_SIMPLE_CATCH) {
          var scope$1 = this.currentScope();
          scope$1.lexical.push(name);
        } else if (bindingType === BIND_FUNCTION) {
          var scope$2 = this.currentScope();
          if (this.treatFunctionsAsVar) {
            redeclared = scope$2.lexical.indexOf(name) > -1;
          } else {
            redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
          }
          scope$2.functions.push(name);
        } else {
          for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
            var scope$3 = this.scopeStack[i2];
            if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
              redeclared = true;
              break;
            }
            scope$3.var.push(name);
            if (this.inModule && scope$3.flags & SCOPE_TOP) {
              delete this.undefinedExports[name];
            }
            if (scope$3.flags & SCOPE_VAR) {
              break;
            }
          }
        }
        if (redeclared) {
          this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
        }
      };
      pp$3.checkLocalExport = function(id) {
        if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
          this.undefinedExports[id.name] = id;
        }
      };
      pp$3.currentScope = function() {
        return this.scopeStack[this.scopeStack.length - 1];
      };
      pp$3.currentVarScope = function() {
        for (var i2 = this.scopeStack.length - 1; ; i2--) {
          var scope = this.scopeStack[i2];
          if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) {
            return scope;
          }
        }
      };
      pp$3.currentThisScope = function() {
        for (var i2 = this.scopeStack.length - 1; ; i2--) {
          var scope = this.scopeStack[i2];
          if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) && !(scope.flags & SCOPE_ARROW)) {
            return scope;
          }
        }
      };
      var Node = function Node2(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        if (parser.options.locations) {
          this.loc = new SourceLocation(parser, loc);
        }
        if (parser.options.directSourceFile) {
          this.sourceFile = parser.options.directSourceFile;
        }
        if (parser.options.ranges) {
          this.range = [pos, 0];
        }
      };
      var pp$2 = Parser.prototype;
      pp$2.startNode = function() {
        return new Node(this, this.start, this.startLoc);
      };
      pp$2.startNodeAt = function(pos, loc) {
        return new Node(this, pos, loc);
      };
      function finishNodeAt(node, type, pos, loc) {
        node.type = type;
        node.end = pos;
        if (this.options.locations) {
          node.loc.end = loc;
        }
        if (this.options.ranges) {
          node.range[1] = pos;
        }
        return node;
      }
      pp$2.finishNode = function(node, type) {
        return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
      };
      pp$2.finishNodeAt = function(node, type, pos, loc) {
        return finishNodeAt.call(this, node, type, pos, loc);
      };
      pp$2.copyNode = function(node) {
        var newNode = new Node(this, node.start, this.startLoc);
        for (var prop in node) {
          newNode[prop] = node[prop];
        }
        return newNode;
      };
      var scriptValuesAddedInUnicode = "Berf Beria_Erfe Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sidetic Sidt Sunu Sunuwar Tai_Yo Tayo Todhri Todr Tolong_Siki Tols Tulu_Tigalari Tutg Unknown Zzzz";
      var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
      var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
      var ecma11BinaryProperties = ecma10BinaryProperties;
      var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
      var ecma13BinaryProperties = ecma12BinaryProperties;
      var ecma14BinaryProperties = ecma13BinaryProperties;
      var unicodeBinaryProperties = {
        9: ecma9BinaryProperties,
        10: ecma10BinaryProperties,
        11: ecma11BinaryProperties,
        12: ecma12BinaryProperties,
        13: ecma13BinaryProperties,
        14: ecma14BinaryProperties
      };
      var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
      var unicodeBinaryPropertiesOfStrings = {
        9: "",
        10: "",
        11: "",
        12: "",
        13: "",
        14: ecma14BinaryPropertiesOfStrings
      };
      var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
      var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
      var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
      var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
      var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
      var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
      var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
      var unicodeScriptValues = {
        9: ecma9ScriptValues,
        10: ecma10ScriptValues,
        11: ecma11ScriptValues,
        12: ecma12ScriptValues,
        13: ecma13ScriptValues,
        14: ecma14ScriptValues
      };
      var data = {};
      function buildUnicodeData(ecmaVersion2) {
        var d = data[ecmaVersion2] = {
          binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion2] + " " + unicodeGeneralCategoryValues),
          binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion2]),
          nonBinary: {
            General_Category: wordsRegexp(unicodeGeneralCategoryValues),
            Script: wordsRegexp(unicodeScriptValues[ecmaVersion2])
          }
        };
        d.nonBinary.Script_Extensions = d.nonBinary.Script;
        d.nonBinary.gc = d.nonBinary.General_Category;
        d.nonBinary.sc = d.nonBinary.Script;
        d.nonBinary.scx = d.nonBinary.Script_Extensions;
      }
      for (var i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {
        var ecmaVersion = list[i];
        buildUnicodeData(ecmaVersion);
      }
      var pp$1 = Parser.prototype;
      var BranchID = function BranchID2(parent, base) {
        this.parent = parent;
        this.base = base || this;
      };
      BranchID.prototype.separatedFrom = function separatedFrom(alt) {
        for (var self2 = this; self2; self2 = self2.parent) {
          for (var other = alt; other; other = other.parent) {
            if (self2.base === other.base && self2 !== other) {
              return true;
            }
          }
        }
        return false;
      };
      BranchID.prototype.sibling = function sibling() {
        return new BranchID(this.parent, this.base);
      };
      var RegExpValidationState = function RegExpValidationState2(parser) {
        this.parser = parser;
        this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
        this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
        this.source = "";
        this.flags = "";
        this.start = 0;
        this.switchU = false;
        this.switchV = false;
        this.switchN = false;
        this.pos = 0;
        this.lastIntValue = 0;
        this.lastStringValue = "";
        this.lastAssertionIsQuantifiable = false;
        this.numCapturingParens = 0;
        this.maxBackReference = 0;
        this.groupNames = /* @__PURE__ */ Object.create(null);
        this.backReferenceNames = [];
        this.branchID = null;
      };
      RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
        var unicodeSets = flags.indexOf("v") !== -1;
        var unicode = flags.indexOf("u") !== -1;
        this.start = start | 0;
        this.source = pattern + "";
        this.flags = flags;
        if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
          this.switchU = true;
          this.switchV = true;
          this.switchN = true;
        } else {
          this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
          this.switchV = false;
          this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
        }
      };
      RegExpValidationState.prototype.raise = function raise(message) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
      };
      RegExpValidationState.prototype.at = function at(i2, forceU) {
        if (forceU === void 0) forceU = false;
        var s = this.source;
        var l = s.length;
        if (i2 >= l) {
          return -1;
        }
        var c = s.charCodeAt(i2);
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l) {
          return c;
        }
        var next = s.charCodeAt(i2 + 1);
        return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
      };
      RegExpValidationState.prototype.nextIndex = function nextIndex(i2, forceU) {
        if (forceU === void 0) forceU = false;
        var s = this.source;
        var l = s.length;
        if (i2 >= l) {
          return l;
        }
        var c = s.charCodeAt(i2), next;
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l || (next = s.charCodeAt(i2 + 1)) < 56320 || next > 57343) {
          return i2 + 1;
        }
        return i2 + 2;
      };
      RegExpValidationState.prototype.current = function current(forceU) {
        if (forceU === void 0) forceU = false;
        return this.at(this.pos, forceU);
      };
      RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
        if (forceU === void 0) forceU = false;
        return this.at(this.nextIndex(this.pos, forceU), forceU);
      };
      RegExpValidationState.prototype.advance = function advance(forceU) {
        if (forceU === void 0) forceU = false;
        this.pos = this.nextIndex(this.pos, forceU);
      };
      RegExpValidationState.prototype.eat = function eat(ch, forceU) {
        if (forceU === void 0) forceU = false;
        if (this.current(forceU) === ch) {
          this.advance(forceU);
          return true;
        }
        return false;
      };
      RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
        if (forceU === void 0) forceU = false;
        var pos = this.pos;
        for (var i2 = 0, list2 = chs; i2 < list2.length; i2 += 1) {
          var ch = list2[i2];
          var current = this.at(pos, forceU);
          if (current === -1 || current !== ch) {
            return false;
          }
          pos = this.nextIndex(pos, forceU);
        }
        this.pos = pos;
        return true;
      };
      pp$1.validateRegExpFlags = function(state) {
        var validFlags = state.validFlags;
        var flags = state.flags;
        var u = false;
        var v = false;
        for (var i2 = 0; i2 < flags.length; i2++) {
          var flag = flags.charAt(i2);
          if (validFlags.indexOf(flag) === -1) {
            this.raise(state.start, "Invalid regular expression flag");
          }
          if (flags.indexOf(flag, i2 + 1) > -1) {
            this.raise(state.start, "Duplicate regular expression flag");
          }
          if (flag === "u") {
            u = true;
          }
          if (flag === "v") {
            v = true;
          }
        }
        if (this.options.ecmaVersion >= 15 && u && v) {
          this.raise(state.start, "Invalid regular expression flag");
        }
      };
      function hasProp(obj) {
        for (var _ in obj) {
          return true;
        }
        return false;
      }
      pp$1.validateRegExpPattern = function(state) {
        this.regexp_pattern(state);
        if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
          state.switchN = true;
          this.regexp_pattern(state);
        }
      };
      pp$1.regexp_pattern = function(state) {
        state.pos = 0;
        state.lastIntValue = 0;
        state.lastStringValue = "";
        state.lastAssertionIsQuantifiable = false;
        state.numCapturingParens = 0;
        state.maxBackReference = 0;
        state.groupNames = /* @__PURE__ */ Object.create(null);
        state.backReferenceNames.length = 0;
        state.branchID = null;
        this.regexp_disjunction(state);
        if (state.pos !== state.source.length) {
          if (state.eat(
            41
            /* ) */
          )) {
            state.raise("Unmatched ')'");
          }
          if (state.eat(
            93
            /* ] */
          ) || state.eat(
            125
            /* } */
          )) {
            state.raise("Lone quantifier brackets");
          }
        }
        if (state.maxBackReference > state.numCapturingParens) {
          state.raise("Invalid escape");
        }
        for (var i2 = 0, list2 = state.backReferenceNames; i2 < list2.length; i2 += 1) {
          var name = list2[i2];
          if (!state.groupNames[name]) {
            state.raise("Invalid named capture referenced");
          }
        }
      };
      pp$1.regexp_disjunction = function(state) {
        var trackDisjunction = this.options.ecmaVersion >= 16;
        if (trackDisjunction) {
          state.branchID = new BranchID(state.branchID, null);
        }
        this.regexp_alternative(state);
        while (state.eat(
          124
          /* | */
        )) {
          if (trackDisjunction) {
            state.branchID = state.branchID.sibling();
          }
          this.regexp_alternative(state);
        }
        if (trackDisjunction) {
          state.branchID = state.branchID.parent;
        }
        if (this.regexp_eatQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        if (state.eat(
          123
          /* { */
        )) {
          state.raise("Lone quantifier brackets");
        }
      };
      pp$1.regexp_alternative = function(state) {
        while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
        }
      };
      pp$1.regexp_eatTerm = function(state) {
        if (this.regexp_eatAssertion(state)) {
          if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
            if (state.switchU) {
              state.raise("Invalid quantifier");
            }
          }
          return true;
        }
        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
          this.regexp_eatQuantifier(state);
          return true;
        }
        return false;
      };
      pp$1.regexp_eatAssertion = function(state) {
        var start = state.pos;
        state.lastAssertionIsQuantifiable = false;
        if (state.eat(
          94
          /* ^ */
        ) || state.eat(
          36
          /* $ */
        )) {
          return true;
        }
        if (state.eat(
          92
          /* \ */
        )) {
          if (state.eat(
            66
            /* B */
          ) || state.eat(
            98
            /* b */
          )) {
            return true;
          }
          state.pos = start;
        }
        if (state.eat(
          40
          /* ( */
        ) && state.eat(
          63
          /* ? */
        )) {
          var lookbehind = false;
          if (this.options.ecmaVersion >= 9) {
            lookbehind = state.eat(
              60
              /* < */
            );
          }
          if (state.eat(
            61
            /* = */
          ) || state.eat(
            33
            /* ! */
          )) {
            this.regexp_disjunction(state);
            if (!state.eat(
              41
              /* ) */
            )) {
              state.raise("Unterminated group");
            }
            state.lastAssertionIsQuantifiable = !lookbehind;
            return true;
          }
        }
        state.pos = start;
        return false;
      };
      pp$1.regexp_eatQuantifier = function(state, noError) {
        if (noError === void 0) noError = false;
        if (this.regexp_eatQuantifierPrefix(state, noError)) {
          state.eat(
            63
            /* ? */
          );
          return true;
        }
        return false;
      };
      pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
        return state.eat(
          42
          /* * */
        ) || state.eat(
          43
          /* + */
        ) || state.eat(
          63
          /* ? */
        ) || this.regexp_eatBracedQuantifier(state, noError);
      };
      pp$1.regexp_eatBracedQuantifier = function(state, noError) {
        var start = state.pos;
        if (state.eat(
          123
          /* { */
        )) {
          var min = 0, max = -1;
          if (this.regexp_eatDecimalDigits(state)) {
            min = state.lastIntValue;
            if (state.eat(
              44
              /* , */
            ) && this.regexp_eatDecimalDigits(state)) {
              max = state.lastIntValue;
            }
            if (state.eat(
              125
              /* } */
            )) {
              if (max !== -1 && max < min && !noError) {
                state.raise("numbers out of order in {} quantifier");
              }
              return true;
            }
          }
          if (state.switchU && !noError) {
            state.raise("Incomplete quantifier");
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatAtom = function(state) {
        return this.regexp_eatPatternCharacters(state) || state.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
      };
      pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
        var start = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatAtomEscape(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatUncapturingGroup = function(state) {
        var start = state.pos;
        if (state.eat(
          40
          /* ( */
        )) {
          if (state.eat(
            63
            /* ? */
          )) {
            if (this.options.ecmaVersion >= 16) {
              var addModifiers = this.regexp_eatModifiers(state);
              var hasHyphen = state.eat(
                45
                /* - */
              );
              if (addModifiers || hasHyphen) {
                for (var i2 = 0; i2 < addModifiers.length; i2++) {
                  var modifier = addModifiers.charAt(i2);
                  if (addModifiers.indexOf(modifier, i2 + 1) > -1) {
                    state.raise("Duplicate regular expression modifiers");
                  }
                }
                if (hasHyphen) {
                  var removeModifiers = this.regexp_eatModifiers(state);
                  if (!addModifiers && !removeModifiers && state.current() === 58) {
                    state.raise("Invalid regular expression modifiers");
                  }
                  for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {
                    var modifier$1 = removeModifiers.charAt(i$1);
                    if (removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) {
                      state.raise("Duplicate regular expression modifiers");
                    }
                  }
                }
              }
            }
            if (state.eat(
              58
              /* : */
            )) {
              this.regexp_disjunction(state);
              if (state.eat(
                41
                /* ) */
              )) {
                return true;
              }
              state.raise("Unterminated group");
            }
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatCapturingGroup = function(state) {
        if (state.eat(
          40
          /* ( */
        )) {
          if (this.options.ecmaVersion >= 9) {
            this.regexp_groupSpecifier(state);
          } else if (state.current() === 63) {
            state.raise("Invalid group");
          }
          this.regexp_disjunction(state);
          if (state.eat(
            41
            /* ) */
          )) {
            state.numCapturingParens += 1;
            return true;
          }
          state.raise("Unterminated group");
        }
        return false;
      };
      pp$1.regexp_eatModifiers = function(state) {
        var modifiers = "";
        var ch = 0;
        while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
          modifiers += codePointToString(ch);
          state.advance();
        }
        return modifiers;
      };
      function isRegularExpressionModifier(ch) {
        return ch === 105 || ch === 109 || ch === 115;
      }
      pp$1.regexp_eatExtendedAtom = function(state) {
        return state.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
      };
      pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
        if (this.regexp_eatBracedQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        return false;
      };
      pp$1.regexp_eatSyntaxCharacter = function(state) {
        var ch = state.current();
        if (isSyntaxCharacter(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isSyntaxCharacter(ch) {
        return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
      }
      pp$1.regexp_eatPatternCharacters = function(state) {
        var start = state.pos;
        var ch = 0;
        while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
          state.advance();
        }
        return state.pos !== start;
      };
      pp$1.regexp_eatExtendedPatternCharacter = function(state) {
        var ch = state.current();
        if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_groupSpecifier = function(state) {
        if (state.eat(
          63
          /* ? */
        )) {
          if (!this.regexp_eatGroupName(state)) {
            state.raise("Invalid group");
          }
          var trackDisjunction = this.options.ecmaVersion >= 16;
          var known = state.groupNames[state.lastStringValue];
          if (known) {
            if (trackDisjunction) {
              for (var i2 = 0, list2 = known; i2 < list2.length; i2 += 1) {
                var altID = list2[i2];
                if (!altID.separatedFrom(state.branchID)) {
                  state.raise("Duplicate capture group name");
                }
              }
            } else {
              state.raise("Duplicate capture group name");
            }
          }
          if (trackDisjunction) {
            (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
          } else {
            state.groupNames[state.lastStringValue] = true;
          }
        }
      };
      pp$1.regexp_eatGroupName = function(state) {
        state.lastStringValue = "";
        if (state.eat(
          60
          /* < */
        )) {
          if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
            62
            /* > */
          )) {
            return true;
          }
          state.raise("Invalid capture group name");
        }
        return false;
      };
      pp$1.regexp_eatRegExpIdentifierName = function(state) {
        state.lastStringValue = "";
        if (this.regexp_eatRegExpIdentifierStart(state)) {
          state.lastStringValue += codePointToString(state.lastIntValue);
          while (this.regexp_eatRegExpIdentifierPart(state)) {
            state.lastStringValue += codePointToString(state.lastIntValue);
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_eatRegExpIdentifierStart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierStart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierStart(ch) {
        return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
      }
      pp$1.regexp_eatRegExpIdentifierPart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierPart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierPart(ch) {
        return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
      }
      pp$1.regexp_eatAtomEscape = function(state) {
        if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
          return true;
        }
        if (state.switchU) {
          if (state.current() === 99) {
            state.raise("Invalid unicode escape");
          }
          state.raise("Invalid escape");
        }
        return false;
      };
      pp$1.regexp_eatBackReference = function(state) {
        var start = state.pos;
        if (this.regexp_eatDecimalEscape(state)) {
          var n = state.lastIntValue;
          if (state.switchU) {
            if (n > state.maxBackReference) {
              state.maxBackReference = n;
            }
            return true;
          }
          if (n <= state.numCapturingParens) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatKGroupName = function(state) {
        if (state.eat(
          107
          /* k */
        )) {
          if (this.regexp_eatGroupName(state)) {
            state.backReferenceNames.push(state.lastStringValue);
            return true;
          }
          state.raise("Invalid named reference");
        }
        return false;
      };
      pp$1.regexp_eatCharacterEscape = function(state) {
        return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
      };
      pp$1.regexp_eatCControlLetter = function(state) {
        var start = state.pos;
        if (state.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatZero = function(state) {
        if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
          state.lastIntValue = 0;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatControlEscape = function(state) {
        var ch = state.current();
        if (ch === 116) {
          state.lastIntValue = 9;
          state.advance();
          return true;
        }
        if (ch === 110) {
          state.lastIntValue = 10;
          state.advance();
          return true;
        }
        if (ch === 118) {
          state.lastIntValue = 11;
          state.advance();
          return true;
        }
        if (ch === 102) {
          state.lastIntValue = 12;
          state.advance();
          return true;
        }
        if (ch === 114) {
          state.lastIntValue = 13;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatControlLetter = function(state) {
        var ch = state.current();
        if (isControlLetter(ch)) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      function isControlLetter(ch) {
        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
      }
      pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
        if (forceU === void 0) forceU = false;
        var start = state.pos;
        var switchU = forceU || state.switchU;
        if (state.eat(
          117
          /* u */
        )) {
          if (this.regexp_eatFixedHexDigits(state, 4)) {
            var lead = state.lastIntValue;
            if (switchU && lead >= 55296 && lead <= 56319) {
              var leadSurrogateEnd = state.pos;
              if (state.eat(
                92
                /* \ */
              ) && state.eat(
                117
                /* u */
              ) && this.regexp_eatFixedHexDigits(state, 4)) {
                var trail = state.lastIntValue;
                if (trail >= 56320 && trail <= 57343) {
                  state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                  return true;
                }
              }
              state.pos = leadSurrogateEnd;
              state.lastIntValue = lead;
            }
            return true;
          }
          if (switchU && state.eat(
            123
            /* { */
          ) && this.regexp_eatHexDigits(state) && state.eat(
            125
            /* } */
          ) && isValidUnicode(state.lastIntValue)) {
            return true;
          }
          if (switchU) {
            state.raise("Invalid unicode escape");
          }
          state.pos = start;
        }
        return false;
      };
      function isValidUnicode(ch) {
        return ch >= 0 && ch <= 1114111;
      }
      pp$1.regexp_eatIdentityEscape = function(state) {
        if (state.switchU) {
          if (this.regexp_eatSyntaxCharacter(state)) {
            return true;
          }
          if (state.eat(
            47
            /* / */
          )) {
            state.lastIntValue = 47;
            return true;
          }
          return false;
        }
        var ch = state.current();
        if (ch !== 99 && (!state.switchN || ch !== 107)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatDecimalEscape = function(state) {
        state.lastIntValue = 0;
        var ch = state.current();
        if (ch >= 49 && ch <= 57) {
          do {
            state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
            state.advance();
          } while ((ch = state.current()) >= 48 && ch <= 57);
          return true;
        }
        return false;
      };
      var CharSetNone = 0;
      var CharSetOk = 1;
      var CharSetString = 2;
      pp$1.regexp_eatCharacterClassEscape = function(state) {
        var ch = state.current();
        if (isCharacterClassEscape(ch)) {
          state.lastIntValue = -1;
          state.advance();
          return CharSetOk;
        }
        var negate = false;
        if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
          state.lastIntValue = -1;
          state.advance();
          var result;
          if (state.eat(
            123
            /* { */
          ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(
            125
            /* } */
          )) {
            if (negate && result === CharSetString) {
              state.raise("Invalid property name");
            }
            return result;
          }
          state.raise("Invalid property name");
        }
        return CharSetNone;
      };
      function isCharacterClassEscape(ch) {
        return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
      }
      pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
        var start = state.pos;
        if (this.regexp_eatUnicodePropertyName(state) && state.eat(
          61
          /* = */
        )) {
          var name = state.lastStringValue;
          if (this.regexp_eatUnicodePropertyValue(state)) {
            var value = state.lastStringValue;
            this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
            return CharSetOk;
          }
        }
        state.pos = start;
        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
          var nameOrValue = state.lastStringValue;
          return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
        }
        return CharSetNone;
      };
      pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
        if (!hasOwn(state.unicodeProperties.nonBinary, name)) {
          state.raise("Invalid property name");
        }
        if (!state.unicodeProperties.nonBinary[name].test(value)) {
          state.raise("Invalid property value");
        }
      };
      pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
        if (state.unicodeProperties.binary.test(nameOrValue)) {
          return CharSetOk;
        }
        if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
          return CharSetString;
        }
        state.raise("Invalid property name");
      };
      pp$1.regexp_eatUnicodePropertyName = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyNameCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyNameCharacter(ch) {
        return isControlLetter(ch) || ch === 95;
      }
      pp$1.regexp_eatUnicodePropertyValue = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyValueCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyValueCharacter(ch) {
        return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
      }
      pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
        return this.regexp_eatUnicodePropertyValue(state);
      };
      pp$1.regexp_eatCharacterClass = function(state) {
        if (state.eat(
          91
          /* [ */
        )) {
          var negate = state.eat(
            94
            /* ^ */
          );
          var result = this.regexp_classContents(state);
          if (!state.eat(
            93
            /* ] */
          )) {
            state.raise("Unterminated character class");
          }
          if (negate && result === CharSetString) {
            state.raise("Negated character class may contain strings");
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_classContents = function(state) {
        if (state.current() === 93) {
          return CharSetOk;
        }
        if (state.switchV) {
          return this.regexp_classSetExpression(state);
        }
        this.regexp_nonEmptyClassRanges(state);
        return CharSetOk;
      };
      pp$1.regexp_nonEmptyClassRanges = function(state) {
        while (this.regexp_eatClassAtom(state)) {
          var left = state.lastIntValue;
          if (state.eat(
            45
            /* - */
          ) && this.regexp_eatClassAtom(state)) {
            var right = state.lastIntValue;
            if (state.switchU && (left === -1 || right === -1)) {
              state.raise("Invalid character class");
            }
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
          }
        }
      };
      pp$1.regexp_eatClassAtom = function(state) {
        var start = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatClassEscape(state)) {
            return true;
          }
          if (state.switchU) {
            var ch$1 = state.current();
            if (ch$1 === 99 || isOctalDigit(ch$1)) {
              state.raise("Invalid class escape");
            }
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        var ch = state.current();
        if (ch !== 93) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatClassEscape = function(state) {
        var start = state.pos;
        if (state.eat(
          98
          /* b */
        )) {
          state.lastIntValue = 8;
          return true;
        }
        if (state.switchU && state.eat(
          45
          /* - */
        )) {
          state.lastIntValue = 45;
          return true;
        }
        if (!state.switchU && state.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatClassControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
      };
      pp$1.regexp_classSetExpression = function(state) {
        var result = CharSetOk, subResult;
        if (this.regexp_eatClassSetRange(state)) ;
        else if (subResult = this.regexp_eatClassSetOperand(state)) {
          if (subResult === CharSetString) {
            result = CharSetString;
          }
          var start = state.pos;
          while (state.eatChars(
            [38, 38]
            /* && */
          )) {
            if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
              if (subResult !== CharSetString) {
                result = CharSetOk;
              }
              continue;
            }
            state.raise("Invalid character in character class");
          }
          if (start !== state.pos) {
            return result;
          }
          while (state.eatChars(
            [45, 45]
            /* -- */
          )) {
            if (this.regexp_eatClassSetOperand(state)) {
              continue;
            }
            state.raise("Invalid character in character class");
          }
          if (start !== state.pos) {
            return result;
          }
        } else {
          state.raise("Invalid character in character class");
        }
        for (; ; ) {
          if (this.regexp_eatClassSetRange(state)) {
            continue;
          }
          subResult = this.regexp_eatClassSetOperand(state);
          if (!subResult) {
            return result;
          }
          if (subResult === CharSetString) {
            result = CharSetString;
          }
        }
      };
      pp$1.regexp_eatClassSetRange = function(state) {
        var start = state.pos;
        if (this.regexp_eatClassSetCharacter(state)) {
          var left = state.lastIntValue;
          if (state.eat(
            45
            /* - */
          ) && this.regexp_eatClassSetCharacter(state)) {
            var right = state.lastIntValue;
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatClassSetOperand = function(state) {
        if (this.regexp_eatClassSetCharacter(state)) {
          return CharSetOk;
        }
        return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
      };
      pp$1.regexp_eatNestedClass = function(state) {
        var start = state.pos;
        if (state.eat(
          91
          /* [ */
        )) {
          var negate = state.eat(
            94
            /* ^ */
          );
          var result = this.regexp_classContents(state);
          if (state.eat(
            93
            /* ] */
          )) {
            if (negate && result === CharSetString) {
              state.raise("Negated character class may contain strings");
            }
            return result;
          }
          state.pos = start;
        }
        if (state.eat(
          92
          /* \ */
        )) {
          var result$1 = this.regexp_eatCharacterClassEscape(state);
          if (result$1) {
            return result$1;
          }
          state.pos = start;
        }
        return null;
      };
      pp$1.regexp_eatClassStringDisjunction = function(state) {
        var start = state.pos;
        if (state.eatChars(
          [92, 113]
          /* \q */
        )) {
          if (state.eat(
            123
            /* { */
          )) {
            var result = this.regexp_classStringDisjunctionContents(state);
            if (state.eat(
              125
              /* } */
            )) {
              return result;
            }
          } else {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return null;
      };
      pp$1.regexp_classStringDisjunctionContents = function(state) {
        var result = this.regexp_classString(state);
        while (state.eat(
          124
          /* | */
        )) {
          if (this.regexp_classString(state) === CharSetString) {
            result = CharSetString;
          }
        }
        return result;
      };
      pp$1.regexp_classString = function(state) {
        var count = 0;
        while (this.regexp_eatClassSetCharacter(state)) {
          count++;
        }
        return count === 1 ? CharSetOk : CharSetString;
      };
      pp$1.regexp_eatClassSetCharacter = function(state) {
        var start = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
            return true;
          }
          if (state.eat(
            98
            /* b */
          )) {
            state.lastIntValue = 8;
            return true;
          }
          state.pos = start;
          return false;
        }
        var ch = state.current();
        if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
          return false;
        }
        if (isClassSetSyntaxCharacter(ch)) {
          return false;
        }
        state.advance();
        state.lastIntValue = ch;
        return true;
      };
      function isClassSetReservedDoublePunctuatorCharacter(ch) {
        return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
      }
      function isClassSetSyntaxCharacter(ch) {
        return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
      }
      pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
        var ch = state.current();
        if (isClassSetReservedPunctuator(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isClassSetReservedPunctuator(ch) {
        return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
      }
      pp$1.regexp_eatClassControlLetter = function(state) {
        var ch = state.current();
        if (isDecimalDigit(ch) || ch === 95) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatHexEscapeSequence = function(state) {
        var start = state.pos;
        if (state.eat(
          120
          /* x */
        )) {
          if (this.regexp_eatFixedHexDigits(state, 2)) {
            return true;
          }
          if (state.switchU) {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatDecimalDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isDecimalDigit(ch = state.current())) {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
          state.advance();
        }
        return state.pos !== start;
      };
      function isDecimalDigit(ch) {
        return ch >= 48 && ch <= 57;
      }
      pp$1.regexp_eatHexDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isHexDigit(ch = state.current())) {
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return state.pos !== start;
      };
      function isHexDigit(ch) {
        return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
      }
      function hexToInt(ch) {
        if (ch >= 65 && ch <= 70) {
          return 10 + (ch - 65);
        }
        if (ch >= 97 && ch <= 102) {
          return 10 + (ch - 97);
        }
        return ch - 48;
      }
      pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
        if (this.regexp_eatOctalDigit(state)) {
          var n1 = state.lastIntValue;
          if (this.regexp_eatOctalDigit(state)) {
            var n2 = state.lastIntValue;
            if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
              state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
            } else {
              state.lastIntValue = n1 * 8 + n2;
            }
          } else {
            state.lastIntValue = n1;
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_eatOctalDigit = function(state) {
        var ch = state.current();
        if (isOctalDigit(ch)) {
          state.lastIntValue = ch - 48;
          state.advance();
          return true;
        }
        state.lastIntValue = 0;
        return false;
      };
      function isOctalDigit(ch) {
        return ch >= 48 && ch <= 55;
      }
      pp$1.regexp_eatFixedHexDigits = function(state, length) {
        var start = state.pos;
        state.lastIntValue = 0;
        for (var i2 = 0; i2 < length; ++i2) {
          var ch = state.current();
          if (!isHexDigit(ch)) {
            state.pos = start;
            return false;
          }
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return true;
      };
      var Token = function Token2(p) {
        this.type = p.type;
        this.value = p.value;
        this.start = p.start;
        this.end = p.end;
        if (p.options.locations) {
          this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
        }
        if (p.options.ranges) {
          this.range = [p.start, p.end];
        }
      };
      var pp = Parser.prototype;
      pp.next = function(ignoreEscapeSequenceInKeyword) {
        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
        }
        if (this.options.onToken) {
          this.options.onToken(new Token(this));
        }
        this.lastTokEnd = this.end;
        this.lastTokStart = this.start;
        this.lastTokEndLoc = this.endLoc;
        this.lastTokStartLoc = this.startLoc;
        this.nextToken();
      };
      pp.getToken = function() {
        this.next();
        return new Token(this);
      };
      if (typeof Symbol !== "undefined") {
        pp[Symbol.iterator] = function() {
          var this$1$1 = this;
          return {
            next: function() {
              var token = this$1$1.getToken();
              return {
                done: token.type === types$1.eof,
                value: token
              };
            }
          };
        };
      }
      pp.nextToken = function() {
        var curContext = this.curContext();
        if (!curContext || !curContext.preserveSpace) {
          this.skipSpace();
        }
        this.start = this.pos;
        if (this.options.locations) {
          this.startLoc = this.curPosition();
        }
        if (this.pos >= this.input.length) {
          return this.finishToken(types$1.eof);
        }
        if (curContext.override) {
          return curContext.override(this);
        } else {
          this.readToken(this.fullCharCodeAtPos());
        }
      };
      pp.readToken = function(code) {
        if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
          return this.readWord();
        }
        return this.getTokenFromCode(code);
      };
      pp.fullCharCodeAt = function(pos) {
        var code = this.input.charCodeAt(pos);
        if (code <= 55295 || code >= 56320) {
          return code;
        }
        var next = this.input.charCodeAt(pos + 1);
        return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
      };
      pp.fullCharCodeAtPos = function() {
        return this.fullCharCodeAt(this.pos);
      };
      pp.skipBlockComment = function() {
        var startLoc = this.options.onComment && this.curPosition();
        var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) {
          this.raise(this.pos - 2, "Unterminated comment");
        }
        this.pos = end + 2;
        if (this.options.locations) {
          for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
            ++this.curLine;
            pos = this.lineStart = nextBreak;
          }
        }
        if (this.options.onComment) {
          this.options.onComment(
            true,
            this.input.slice(start + 2, end),
            start,
            this.pos,
            startLoc,
            this.curPosition()
          );
        }
      };
      pp.skipLineComment = function(startSkip) {
        var start = this.pos;
        var startLoc = this.options.onComment && this.curPosition();
        var ch = this.input.charCodeAt(this.pos += startSkip);
        while (this.pos < this.input.length && !isNewLine(ch)) {
          ch = this.input.charCodeAt(++this.pos);
        }
        if (this.options.onComment) {
          this.options.onComment(
            false,
            this.input.slice(start + startSkip, this.pos),
            start,
            this.pos,
            startLoc,
            this.curPosition()
          );
        }
      };
      pp.skipSpace = function() {
        loop: while (this.pos < this.input.length) {
          var ch = this.input.charCodeAt(this.pos);
          switch (ch) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.pos + 1) === 10) {
                ++this.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.pos;
              if (this.options.locations) {
                ++this.curLine;
                this.lineStart = this.pos;
              }
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break loop;
              }
              break;
            default:
              if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                ++this.pos;
              } else {
                break loop;
              }
          }
        }
      };
      pp.finishToken = function(type, val) {
        this.end = this.pos;
        if (this.options.locations) {
          this.endLoc = this.curPosition();
        }
        var prevType = this.type;
        this.type = type;
        this.value = val;
        this.updateContext(prevType);
      };
      pp.readToken_dot = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next >= 48 && next <= 57) {
          return this.readNumber(true);
        }
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
          this.pos += 3;
          return this.finishToken(types$1.ellipsis);
        } else {
          ++this.pos;
          return this.finishToken(types$1.dot);
        }
      };
      pp.readToken_slash = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (this.exprAllowed) {
          ++this.pos;
          return this.readRegexp();
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.slash, 1);
      };
      pp.readToken_mult_modulo_exp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        var tokentype = code === 42 ? types$1.star : types$1.modulo;
        if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
          ++size;
          tokentype = types$1.starstar;
          next = this.input.charCodeAt(this.pos + 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, size + 1);
        }
        return this.finishOp(tokentype, size);
      };
      pp.readToken_pipe_amp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (this.options.ecmaVersion >= 12) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 === 61) {
              return this.finishOp(types$1.assign, 3);
            }
          }
          return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
      };
      pp.readToken_caret = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.bitwiseXOR, 1);
      };
      pp.readToken_plus_min = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
            this.skipLineComment(3);
            this.skipSpace();
            return this.nextToken();
          }
          return this.finishOp(types$1.incDec, 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.plusMin, 1);
      };
      pp.readToken_lt_gt = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        if (next === code) {
          size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(this.pos + size) === 61) {
            return this.finishOp(types$1.assign, size + 1);
          }
          return this.finishOp(types$1.bitShift, size);
        }
        if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
          this.skipLineComment(4);
          this.skipSpace();
          return this.nextToken();
        }
        if (next === 61) {
          size = 2;
        }
        return this.finishOp(types$1.relational, size);
      };
      pp.readToken_eq_excl = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
        }
        if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
          this.pos += 2;
          return this.finishToken(types$1.arrow);
        }
        return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
      };
      pp.readToken_question = function() {
        var ecmaVersion2 = this.options.ecmaVersion;
        if (ecmaVersion2 >= 11) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 46) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 < 48 || next2 > 57) {
              return this.finishOp(types$1.questionDot, 2);
            }
          }
          if (next === 63) {
            if (ecmaVersion2 >= 12) {
              var next2$1 = this.input.charCodeAt(this.pos + 2);
              if (next2$1 === 61) {
                return this.finishOp(types$1.assign, 3);
              }
            }
            return this.finishOp(types$1.coalesce, 2);
          }
        }
        return this.finishOp(types$1.question, 1);
      };
      pp.readToken_numberSign = function() {
        var ecmaVersion2 = this.options.ecmaVersion;
        var code = 35;
        if (ecmaVersion2 >= 13) {
          ++this.pos;
          code = this.fullCharCodeAtPos();
          if (isIdentifierStart(code, true) || code === 92) {
            return this.finishToken(types$1.privateId, this.readWord1());
          }
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
      };
      pp.getTokenFromCode = function(code) {
        switch (code) {
          // The interpretation of a dot depends on whether it is followed
          // by a digit or another two dots.
          case 46:
            return this.readToken_dot();
          // Punctuation tokens.
          case 40:
            ++this.pos;
            return this.finishToken(types$1.parenL);
          case 41:
            ++this.pos;
            return this.finishToken(types$1.parenR);
          case 59:
            ++this.pos;
            return this.finishToken(types$1.semi);
          case 44:
            ++this.pos;
            return this.finishToken(types$1.comma);
          case 91:
            ++this.pos;
            return this.finishToken(types$1.bracketL);
          case 93:
            ++this.pos;
            return this.finishToken(types$1.bracketR);
          case 123:
            ++this.pos;
            return this.finishToken(types$1.braceL);
          case 125:
            ++this.pos;
            return this.finishToken(types$1.braceR);
          case 58:
            ++this.pos;
            return this.finishToken(types$1.colon);
          case 96:
            if (this.options.ecmaVersion < 6) {
              break;
            }
            ++this.pos;
            return this.finishToken(types$1.backQuote);
          case 48:
            var next = this.input.charCodeAt(this.pos + 1);
            if (next === 120 || next === 88) {
              return this.readRadixNumber(16);
            }
            if (this.options.ecmaVersion >= 6) {
              if (next === 111 || next === 79) {
                return this.readRadixNumber(8);
              }
              if (next === 98 || next === 66) {
                return this.readRadixNumber(2);
              }
            }
          // Anything else beginning with a digit is an integer, octal
          // number, or float.
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.readNumber(false);
          // Quotes produce strings.
          case 34:
          case 39:
            return this.readString(code);
          // Operators are parsed inline in tiny state machines. '=' (61) is
          // often referred to. `finishOp` simply skips the amount of
          // characters it is given as second argument, and returns a token
          // of the type given by its first argument.
          case 47:
            return this.readToken_slash();
          case 37:
          case 42:
            return this.readToken_mult_modulo_exp(code);
          case 124:
          case 38:
            return this.readToken_pipe_amp(code);
          case 94:
            return this.readToken_caret();
          case 43:
          case 45:
            return this.readToken_plus_min(code);
          case 60:
          case 62:
            return this.readToken_lt_gt(code);
          case 61:
          case 33:
            return this.readToken_eq_excl(code);
          case 63:
            return this.readToken_question();
          case 126:
            return this.finishOp(types$1.prefix, 1);
          case 35:
            return this.readToken_numberSign();
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
      };
      pp.finishOp = function(type, size) {
        var str = this.input.slice(this.pos, this.pos + size);
        this.pos += size;
        return this.finishToken(type, str);
      };
      pp.readRegexp = function() {
        var escaped, inClass, start = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(start, "Unterminated regular expression");
          }
          var ch = this.input.charAt(this.pos);
          if (lineBreak.test(ch)) {
            this.raise(start, "Unterminated regular expression");
          }
          if (!escaped) {
            if (ch === "[") {
              inClass = true;
            } else if (ch === "]" && inClass) {
              inClass = false;
            } else if (ch === "/" && !inClass) {
              break;
            }
            escaped = ch === "\\";
          } else {
            escaped = false;
          }
          ++this.pos;
        }
        var pattern = this.input.slice(start, this.pos);
        ++this.pos;
        var flagsStart = this.pos;
        var flags = this.readWord1();
        if (this.containsEsc) {
          this.unexpected(flagsStart);
        }
        var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
        state.reset(start, pattern, flags);
        this.validateRegExpFlags(state);
        this.validateRegExpPattern(state);
        var value = null;
        try {
          value = new RegExp(pattern, flags);
        } catch (e) {
        }
        return this.finishToken(types$1.regexp, { pattern, flags, value });
      };
      pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
        var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
        var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
        var start = this.pos, total = 0, lastCode = 0;
        for (var i2 = 0, e = len == null ? Infinity : len; i2 < e; ++i2, ++this.pos) {
          var code = this.input.charCodeAt(this.pos), val = void 0;
          if (allowSeparators && code === 95) {
            if (isLegacyOctalNumericLiteral) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
            }
            if (lastCode === 95) {
              this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
            }
            if (i2 === 0) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
            }
            lastCode = code;
            continue;
          }
          if (code >= 97) {
            val = code - 97 + 10;
          } else if (code >= 65) {
            val = code - 65 + 10;
          } else if (code >= 48 && code <= 57) {
            val = code - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            break;
          }
          lastCode = code;
          total = total * radix + val;
        }
        if (allowSeparators && lastCode === 95) {
          this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
        }
        if (this.pos === start || len != null && this.pos - start !== len) {
          return null;
        }
        return total;
      };
      function stringToNumber(str, isLegacyOctalNumericLiteral) {
        if (isLegacyOctalNumericLiteral) {
          return parseInt(str, 8);
        }
        return parseFloat(str.replace(/_/g, ""));
      }
      function stringToBigInt(str) {
        if (typeof BigInt !== "function") {
          return null;
        }
        return BigInt(str.replace(/_/g, ""));
      }
      pp.readRadixNumber = function(radix) {
        var start = this.pos;
        this.pos += 2;
        var val = this.readInt(radix);
        if (val == null) {
          this.raise(this.start + 2, "Expected number in radix " + radix);
        }
        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
          val = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
        } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types$1.num, val);
      };
      pp.readNumber = function(startsWithDot) {
        var start = this.pos;
        if (!startsWithDot && this.readInt(10, void 0, true) === null) {
          this.raise(start, "Invalid number");
        }
        var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (octal && this.strict) {
          this.raise(start, "Invalid number");
        }
        var next = this.input.charCodeAt(this.pos);
        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
          var val$1 = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
          if (isIdentifierStart(this.fullCharCodeAtPos())) {
            this.raise(this.pos, "Identifier directly after number");
          }
          return this.finishToken(types$1.num, val$1);
        }
        if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
          octal = false;
        }
        if (next === 46 && !octal) {
          ++this.pos;
          this.readInt(10);
          next = this.input.charCodeAt(this.pos);
        }
        if ((next === 69 || next === 101) && !octal) {
          next = this.input.charCodeAt(++this.pos);
          if (next === 43 || next === 45) {
            ++this.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(start, "Invalid number");
          }
        }
        if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        var val = stringToNumber(this.input.slice(start, this.pos), octal);
        return this.finishToken(types$1.num, val);
      };
      pp.readCodePoint = function() {
        var ch = this.input.charCodeAt(this.pos), code;
        if (ch === 123) {
          if (this.options.ecmaVersion < 6) {
            this.unexpected();
          }
          var codePos = ++this.pos;
          code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
          ++this.pos;
          if (code > 1114111) {
            this.invalidStringToken(codePos, "Code point out of bounds");
          }
        } else {
          code = this.readHexChar(4);
        }
        return code;
      };
      pp.readString = function(quote) {
        var out = "", chunkStart = ++this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated string constant");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === quote) {
            break;
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(false);
            chunkStart = this.pos;
          } else if (ch === 8232 || ch === 8233) {
            if (this.options.ecmaVersion < 10) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
            if (this.options.locations) {
              this.curLine++;
              this.lineStart = this.pos;
            }
          } else {
            if (isNewLine(ch)) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
          }
        }
        out += this.input.slice(chunkStart, this.pos++);
        return this.finishToken(types$1.string, out);
      };
      var INVALID_TEMPLATE_ESCAPE_ERROR = {};
      pp.tryReadTemplateToken = function() {
        this.inTemplateElement = true;
        try {
          this.readTmplToken();
        } catch (err) {
          if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
            this.readInvalidTemplateToken();
          } else {
            throw err;
          }
        }
        this.inTemplateElement = false;
      };
      pp.invalidStringToken = function(position, message) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
          throw INVALID_TEMPLATE_ESCAPE_ERROR;
        } else {
          this.raise(position, message);
        }
      };
      pp.readTmplToken = function() {
        var out = "", chunkStart = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated template");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
            if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
              if (ch === 36) {
                this.pos += 2;
                return this.finishToken(types$1.dollarBraceL);
              } else {
                ++this.pos;
                return this.finishToken(types$1.backQuote);
              }
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(types$1.template, out);
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(true);
            chunkStart = this.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.pos);
            ++this.pos;
            switch (ch) {
              case 13:
                if (this.input.charCodeAt(this.pos) === 10) {
                  ++this.pos;
                }
              case 10:
                out += "\n";
                break;
              default:
                out += String.fromCharCode(ch);
                break;
            }
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            chunkStart = this.pos;
          } else {
            ++this.pos;
          }
        }
      };
      pp.readInvalidTemplateToken = function() {
        for (; this.pos < this.input.length; this.pos++) {
          switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break;
            case "$":
              if (this.input[this.pos + 1] !== "{") {
                break;
              }
            // fall through
            case "`":
              return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
            case "\r":
              if (this.input[this.pos + 1] === "\n") {
                ++this.pos;
              }
            // fall through
            case "\n":
            case "\u2028":
            case "\u2029":
              ++this.curLine;
              this.lineStart = this.pos + 1;
              break;
          }
        }
        this.raise(this.start, "Unterminated template");
      };
      pp.readEscapedChar = function(inTemplate) {
        var ch = this.input.charCodeAt(++this.pos);
        ++this.pos;
        switch (ch) {
          case 110:
            return "\n";
          // 'n' -> '\n'
          case 114:
            return "\r";
          // 'r' -> '\r'
          case 120:
            return String.fromCharCode(this.readHexChar(2));
          // 'x'
          case 117:
            return codePointToString(this.readCodePoint());
          // 'u'
          case 116:
            return "	";
          // 't' -> '\t'
          case 98:
            return "\b";
          // 'b' -> '\b'
          case 118:
            return "\v";
          // 'v' -> '\u000b'
          case 102:
            return "\f";
          // 'f' -> '\f'
          case 13:
            if (this.input.charCodeAt(this.pos) === 10) {
              ++this.pos;
            }
          // '\r\n'
          case 10:
            if (this.options.locations) {
              this.lineStart = this.pos;
              ++this.curLine;
            }
            return "";
          case 56:
          case 57:
            if (this.strict) {
              this.invalidStringToken(
                this.pos - 1,
                "Invalid escape sequence"
              );
            }
            if (inTemplate) {
              var codePos = this.pos - 1;
              this.invalidStringToken(
                codePos,
                "Invalid escape sequence in template string"
              );
            }
          default:
            if (ch >= 48 && ch <= 55) {
              var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
              var octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              this.pos += octalStr.length - 1;
              ch = this.input.charCodeAt(this.pos);
              if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
                this.invalidStringToken(
                  this.pos - 1 - octalStr.length,
                  inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
                );
              }
              return String.fromCharCode(octal);
            }
            if (isNewLine(ch)) {
              if (this.options.locations) {
                this.lineStart = this.pos;
                ++this.curLine;
              }
              return "";
            }
            return String.fromCharCode(ch);
        }
      };
      pp.readHexChar = function(len) {
        var codePos = this.pos;
        var n = this.readInt(16, len);
        if (n === null) {
          this.invalidStringToken(codePos, "Bad character escape sequence");
        }
        return n;
      };
      pp.readWord1 = function() {
        this.containsEsc = false;
        var word = "", first = true, chunkStart = this.pos;
        var astral = this.options.ecmaVersion >= 6;
        while (this.pos < this.input.length) {
          var ch = this.fullCharCodeAtPos();
          if (isIdentifierChar(ch, astral)) {
            this.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.containsEsc = true;
            word += this.input.slice(chunkStart, this.pos);
            var escStart = this.pos;
            if (this.input.charCodeAt(++this.pos) !== 117) {
              this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
            }
            ++this.pos;
            var esc = this.readCodePoint();
            if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
              this.invalidStringToken(escStart, "Invalid Unicode escape");
            }
            word += codePointToString(esc);
            chunkStart = this.pos;
          } else {
            break;
          }
          first = false;
        }
        return word + this.input.slice(chunkStart, this.pos);
      };
      pp.readWord = function() {
        var word = this.readWord1();
        var type = types$1.name;
        if (this.keywords.test(word)) {
          type = keywords[word];
        }
        return this.finishToken(type, word);
      };
      var version = "8.16.0";
      Parser.acorn = {
        Parser,
        version,
        defaultOptions,
        Position,
        SourceLocation,
        getLineInfo,
        Node,
        TokenType,
        tokTypes: types$1,
        keywordTypes: keywords,
        TokContext,
        tokContexts: types,
        isIdentifierChar,
        isIdentifierStart,
        Token,
        isNewLine,
        lineBreak,
        lineBreakG,
        nonASCIIwhitespace
      };
      function parse(input, options) {
        return Parser.parse(input, options);
      }
      function parseExpressionAt(input, pos, options) {
        return Parser.parseExpressionAt(input, pos, options);
      }
      function tokenizer(input, options) {
        return Parser.tokenizer(input, options);
      }
      exports3.Node = Node;
      exports3.Parser = Parser;
      exports3.Position = Position;
      exports3.SourceLocation = SourceLocation;
      exports3.TokContext = TokContext;
      exports3.Token = Token;
      exports3.TokenType = TokenType;
      exports3.defaultOptions = defaultOptions;
      exports3.getLineInfo = getLineInfo;
      exports3.isIdentifierChar = isIdentifierChar;
      exports3.isIdentifierStart = isIdentifierStart;
      exports3.isNewLine = isNewLine;
      exports3.keywordTypes = keywords;
      exports3.lineBreak = lineBreak;
      exports3.lineBreakG = lineBreakG;
      exports3.nonASCIIwhitespace = nonASCIIwhitespace;
      exports3.parse = parse;
      exports3.parseExpressionAt = parseExpressionAt;
      exports3.tokContexts = types;
      exports3.tokTypes = types$1;
      exports3.tokenizer = tokenizer;
      exports3.version = version;
    }));
  }
});

// src/lib/ast.js
var require_ast = __commonJS({
  "src/lib/ast.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var acorn = require_acorn();
    var { LANGUAGE_MAP } = require_codebase_intel();
    function stripTypeScript(code) {
      code = code.replace(/^\s*import\s+type\s+\{[^}]*\}\s+from\s+['"][^'"]*['"];?\s*$/gm, "");
      code = code.replace(/\btype\s+(\w+)\s*,?\s*/g, "");
      code = code.replace(/^\s*(?:export\s+)?interface\s+\w+(?:\s+extends\s+[^{]*)?\s*\{[^}]*\}/gm, "");
      code = code.replace(/^\s*(?:export\s+)?type\s+\w+(?:<[^>]*>)?\s*=\s*[^;]*;/gm, "");
      code = code.replace(/^\s*(?:export\s+)?(?:const\s+)?enum\s+\w+\s*\{[^}]*\}/gm, "");
      code = code.replace(/^\s*declare\s+[^;{]*[;{][^}]*\}?/gm, "");
      code = code.replace(/<\s*[A-Z_]\w*(?:\s+extends\s+[^>]*)?\s*(?:,\s*[A-Z_]\w*(?:\s+extends\s+[^>]*)?\s*)*>/g, "");
      code = code.replace(/\)\s*:\s*(?:Promise\s*<[^>]*>|[\w\[\]|&<>.,\s?]+?)(?=\s*[{=>])/g, ")");
      code = code.replace(/(\w+)\s*:\s*(?:[\w\[\]|&<>.,\s?]+?)(?=[,\)=])/g, "$1");
      code = code.replace(/(\w+)\?(?=\s*[,\)=:])/g, "$1");
      code = code.replace(/\bas\s+(?:const|[\w\[\]|&<>.,\s?]+?)(?=[,;\)\]\}])/g, "");
      code = code.replace(/(\w+)!(?=\.|\[)/g, "$1");
      code = code.replace(/<(\w+)>(?=\s*\w)/g, "");
      code = code.replace(/\breadonly\s+/g, "");
      code = code.replace(/^\s*(public|private|protected|override)\s+/gm, "");
      code = code.replace(/\babstract\s+/g, "");
      code = code.replace(/\bimplements\s+[\w\s,<>]+(?=\s*\{)/g, "");
      return code;
    }
    function parseWithAcorn(code) {
      const baseOpts = {
        ecmaVersion: "latest",
        allowReturnOutsideFunction: true,
        allowImportExportEverywhere: true
      };
      try {
        return acorn.parse(code, { ...baseOpts, sourceType: "module" });
      } catch {
        try {
          return acorn.parse(code, { ...baseOpts, sourceType: "script" });
        } catch {
          return null;
        }
      }
    }
    function extractParamNames(params) {
      if (!params) return [];
      return params.map((p) => {
        if (p.type === "Identifier") return p.name;
        if (p.type === "AssignmentPattern" && p.left && p.left.type === "Identifier") return p.left.name;
        if (p.type === "RestElement" && p.argument && p.argument.type === "Identifier") return "..." + p.argument.name;
        if (p.type === "ObjectPattern") return "{...}";
        if (p.type === "ArrayPattern") return "[...]";
        return "?";
      });
    }
    function posToLine(code, pos) {
      let line = 1;
      for (let i = 0; i < pos && i < code.length; i++) {
        if (code[i] === "\n") line++;
      }
      return line;
    }
    function walkAstForSignatures(ast, code) {
      const signatures = [];
      function visit(node) {
        if (!node || typeof node !== "object") return;
        switch (node.type) {
          case "FunctionDeclaration":
            if (node.id) {
              signatures.push({
                name: node.id.name,
                type: "function",
                params: extractParamNames(node.params),
                line: posToLine(code, node.start),
                async: !!node.async,
                generator: !!node.generator
              });
            }
            break;
          case "ClassDeclaration":
            if (node.id) {
              signatures.push({
                name: node.id.name,
                type: "class",
                params: [],
                line: posToLine(code, node.start),
                async: false,
                generator: false
              });
              if (node.body && node.body.body) {
                for (const member of node.body.body) {
                  if (member.type === "MethodDefinition" && member.key) {
                    const methodName = member.key.name || member.key.value || "anonymous";
                    const fn = member.value;
                    signatures.push({
                      name: `${node.id.name}.${methodName}`,
                      type: "method",
                      params: fn ? extractParamNames(fn.params) : [],
                      line: posToLine(code, member.start),
                      async: fn ? !!fn.async : false,
                      generator: fn ? !!fn.generator : false
                    });
                  }
                  if (member.type === "PropertyDefinition" && member.key && member.value) {
                    if (member.value.type === "ArrowFunctionExpression" || member.value.type === "FunctionExpression") {
                      const fieldName = member.key.name || member.key.value || "anonymous";
                      signatures.push({
                        name: `${node.id.name}.${fieldName}`,
                        type: "method",
                        params: extractParamNames(member.value.params),
                        line: posToLine(code, member.start),
                        async: !!member.value.async,
                        generator: !!member.value.generator
                      });
                    }
                  }
                }
              }
            }
            break;
          case "VariableDeclaration":
            for (const decl of node.declarations) {
              if (decl.id && decl.id.type === "Identifier" && decl.init) {
                if (decl.init.type === "ArrowFunctionExpression" || decl.init.type === "FunctionExpression") {
                  signatures.push({
                    name: decl.id.name,
                    type: "arrow",
                    params: extractParamNames(decl.init.params),
                    line: posToLine(code, node.start),
                    async: !!decl.init.async,
                    generator: !!decl.init.generator
                  });
                }
              }
            }
            break;
          case "ExpressionStatement":
            if (node.expression && node.expression.type === "AssignmentExpression") {
              const left = node.expression.left;
              const right = node.expression.right;
              if (right && (right.type === "FunctionExpression" || right.type === "ArrowFunctionExpression")) {
                let name = null;
                if (left.type === "MemberExpression" && left.object) {
                  if (left.object.type === "MemberExpression" && left.object.object && left.object.object.name === "module" && left.object.property && left.object.property.name === "exports" && left.property) {
                    name = left.property.name || left.property.value;
                  } else if (left.object.name === "exports" && left.property) {
                    name = left.property.name || left.property.value;
                  }
                }
                if (name) {
                  signatures.push({
                    name,
                    type: "function",
                    params: extractParamNames(right.params),
                    line: posToLine(code, node.start),
                    async: !!right.async,
                    generator: !!right.generator
                  });
                }
              }
            }
            break;
        }
        for (const key of Object.keys(node)) {
          if (key === "type" || key === "start" || key === "end" || key === "loc" || key === "range") continue;
          const child = node[key];
          if (Array.isArray(child)) {
            for (const item of child) {
              if (item && typeof item === "object" && item.type) visit(item);
            }
          } else if (child && typeof child === "object" && child.type) {
            visit(child);
          }
        }
      }
      if (ast.body) {
        for (const node of ast.body) {
          visit(node);
        }
      }
      return signatures;
    }
    function extractJsSignaturesRegex(code) {
      const signatures = [];
      const lines = code.split("\n");
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const lineNum = i + 1;
        const funcMatch = line.match(/^(?:export\s+)?(?:async\s+)?function\s*\*?\s+(\w+)\s*\(([^)]*)\)/);
        if (funcMatch) {
          signatures.push({
            name: funcMatch[1],
            type: "function",
            params: funcMatch[2] ? funcMatch[2].split(",").map((p) => p.trim()).filter(Boolean) : [],
            line: lineNum,
            async: /async\s+function/.test(line),
            generator: /function\s*\*/.test(line)
          });
          continue;
        }
        const classMatch = line.match(/^(?:export\s+)?class\s+(\w+)/);
        if (classMatch) {
          signatures.push({
            name: classMatch[1],
            type: "class",
            params: [],
            line: lineNum,
            async: false,
            generator: false
          });
          continue;
        }
        const arrowMatch = line.match(/^(?:export\s+)?(?:const|let|var)\s+(\w+)\s*=\s*(?:async\s+)?\(?([^)]*)\)?\s*=>/);
        if (arrowMatch) {
          signatures.push({
            name: arrowMatch[1],
            type: "arrow",
            params: arrowMatch[2] ? arrowMatch[2].split(",").map((p) => p.trim()).filter(Boolean) : [],
            line: lineNum,
            async: /=\s*async/.test(line),
            generator: false
          });
          continue;
        }
      }
      return signatures;
    }
    function walkAstForExports(ast) {
      const named = [];
      let defaultExport = null;
      const reExports = [];
      if (!ast || !ast.body) return { named, default: defaultExport, reExports };
      for (const node of ast.body) {
        switch (node.type) {
          case "ExportNamedDeclaration":
            if (node.source) {
              if (node.specifiers) {
                for (const spec of node.specifiers) {
                  const exportedName = spec.exported ? spec.exported.name || spec.exported.value : null;
                  reExports.push(exportedName || "unknown");
                }
              }
            } else if (node.declaration) {
              if (node.declaration.id) {
                named.push(node.declaration.id.name);
              } else if (node.declaration.declarations) {
                for (const decl of node.declaration.declarations) {
                  if (decl.id && decl.id.type === "Identifier") {
                    named.push(decl.id.name);
                  }
                }
              }
            } else if (node.specifiers) {
              for (const spec of node.specifiers) {
                const exportedName = spec.exported ? spec.exported.name || spec.exported.value : null;
                named.push(exportedName || "unknown");
              }
            }
            break;
          case "ExportDefaultDeclaration":
            if (node.declaration) {
              if (node.declaration.id) {
                defaultExport = node.declaration.id.name;
              } else if (node.declaration.type === "Identifier") {
                defaultExport = node.declaration.name;
              } else {
                defaultExport = "anonymous";
              }
            } else {
              defaultExport = "anonymous";
            }
            break;
          case "ExportAllDeclaration":
            reExports.push("* from " + (node.source ? node.source.value : "unknown"));
            break;
        }
      }
      return { named, default: defaultExport, reExports };
    }
    function extractCjsExports(code) {
      const cjsExports = [];
      const seen = /* @__PURE__ */ new Set();
      const stripped = code.replace(/\/\/[^\n]*/g, "");
      const moduleExportsPattern = /module\.exports\.(\w+)\s*=/g;
      let match;
      while ((match = moduleExportsPattern.exec(stripped)) !== null) {
        if (!seen.has(match[1])) {
          seen.add(match[1]);
          cjsExports.push(match[1]);
        }
      }
      const exportsPattern = /(?<![.\w])exports\.(\w+)\s*=/g;
      while ((match = exportsPattern.exec(stripped)) !== null) {
        if (!seen.has(match[1])) {
          seen.add(match[1]);
          cjsExports.push(match[1]);
        }
      }
      const moduleExportsObj = /module\.exports\s*=\s*\{([^}]+)\}/;
      const objMatch = stripped.match(moduleExportsObj);
      if (objMatch) {
        const inner = objMatch[1];
        const entries = inner.match(/(\w+)\s*(?:[:,}])/g);
        if (entries) {
          for (const entry of entries) {
            const name = entry.replace(/\s*[:,}]/g, "").trim();
            if (name && !seen.has(name)) {
              seen.add(name);
              cjsExports.push(name);
            }
          }
        }
      }
      return cjsExports;
    }
    var DETECTOR_REGISTRY = {
      python: {
        signatures: /^(async\s+)?def\s+(\w+)\s*\(([^)]*)\)/gm,
        exports: /^(\w+)\s*=|^class\s+(\w+)/gm,
        extractSignature(match, lineNum) {
          return {
            name: match[2],
            type: match[1] ? "function" : "function",
            params: match[3] ? match[3].split(",").map((p) => p.trim().split(":")[0].split("=")[0].trim()).filter(Boolean) : [],
            line: lineNum,
            async: !!match[1],
            generator: false
          };
        }
      },
      go: {
        signatures: /^func\s+(?:\([\w\s*]+\)\s+)?(\w+)\s*\(([^)]*)\)/gm,
        extractSignature(match, lineNum) {
          return {
            name: match[1],
            type: "function",
            params: match[2] ? match[2].split(",").map((p) => p.trim().split(/\s+/)[0]).filter(Boolean) : [],
            line: lineNum,
            async: false,
            generator: false
          };
        }
      },
      rust: {
        signatures: /^(pub\s+)?(async\s+)?fn\s+(\w+)\s*(?:<[^>]*>)?\s*\(([^)]*)\)/gm,
        extractSignature(match, lineNum) {
          return {
            name: match[3],
            type: "function",
            params: match[4] ? match[4].split(",").map((p) => p.trim().split(":")[0].trim()).filter(Boolean) : [],
            line: lineNum,
            async: !!match[2],
            generator: false
          };
        }
      },
      ruby: {
        signatures: /^\s*def\s+(\w+[?!=]?)\s*(\([^)]*\))?/gm,
        extractSignature(match, lineNum) {
          const params = match[2] ? match[2].replace(/[()]/g, "").split(",").map((p) => p.trim()).filter(Boolean) : [];
          return {
            name: match[1],
            type: "function",
            params,
            line: lineNum,
            async: false,
            generator: false
          };
        }
      },
      elixir: {
        signatures: /^\s*defp?\s+(\w+)\s*(\([^)]*\))?/gm,
        extractSignature(match, lineNum) {
          const params = match[2] ? match[2].replace(/[()]/g, "").split(",").map((p) => p.trim()).filter(Boolean) : [];
          return {
            name: match[1],
            type: "function",
            params,
            line: lineNum,
            async: false,
            generator: false
          };
        }
      },
      java: {
        signatures: /^\s*(?:public|private|protected)?\s*(?:static)?\s*[\w<>\[\]]+\s+(\w+)\s*\(([^)]*)\)/gm,
        extractSignature(match, lineNum) {
          return {
            name: match[1],
            type: "function",
            params: match[2] ? match[2].split(",").map((p) => p.trim().split(/\s+/).pop()).filter(Boolean) : [],
            line: lineNum,
            async: false,
            generator: false
          };
        }
      },
      php: {
        signatures: /^\s*(?:public|private|protected)?\s*(?:static)?\s*function\s+(\w+)\s*\(([^)]*)\)/gm,
        extractSignature(match, lineNum) {
          return {
            name: match[1],
            type: "function",
            params: match[2] ? match[2].split(",").map((p) => p.trim().split(/\s+/).pop().replace(/^\$/, "")).filter(Boolean) : [],
            line: lineNum,
            async: false,
            generator: false
          };
        }
      }
    };
    function detectLanguage(filePath) {
      const ext = path.extname(filePath);
      return LANGUAGE_MAP[ext] || null;
    }
    function isJsFamily(language) {
      return language === "javascript" || language === "typescript";
    }
    function needsTypeStripping(filePath) {
      const ext = path.extname(filePath);
      return ext === ".ts" || ext === ".tsx" || ext === ".jsx";
    }
    function extractSignatures(filePath, options) {
      const opts = options || {};
      let code;
      try {
        code = opts.code || fs.readFileSync(filePath, "utf-8");
      } catch (e) {
        return { signatures: [], language: null, error: "file_not_found" };
      }
      const language = detectLanguage(filePath);
      if (!language) {
        return { signatures: [], language: null, error: "unknown_language" };
      }
      if (isJsFamily(language)) {
        let parseCode = code;
        if (needsTypeStripping(filePath)) {
          parseCode = stripTypeScript(code);
        }
        const ast = parseWithAcorn(parseCode);
        if (ast) {
          const signatures = walkAstForSignatures(ast, parseCode);
          return { signatures, language };
        }
        const regexSigs = extractJsSignaturesRegex(code);
        return {
          signatures: regexSigs,
          language,
          error: regexSigs.length === 0 ? "parse_failed" : void 0
        };
      }
      const detector = DETECTOR_REGISTRY[language];
      if (!detector) {
        return { signatures: [], language, error: "no_detector" };
      }
      try {
        const signatures = [];
        const regex = new RegExp(detector.signatures.source, detector.signatures.flags);
        const lines = code.split("\n");
        let match;
        while ((match = regex.exec(code)) !== null) {
          let lineNum = 1;
          for (let i = 0; i < match.index; i++) {
            if (code[i] === "\n") lineNum++;
          }
          signatures.push(detector.extractSignature(match, lineNum));
        }
        return { signatures, language };
      } catch {
        return { signatures: [], language, error: "parse_failed" };
      }
    }
    function extractExports(filePath) {
      let code;
      try {
        code = fs.readFileSync(filePath, "utf-8");
      } catch (e) {
        return { named: [], default: null, reExports: [], cjsExports: [], type: "cjs", language: null, error: "file_not_found" };
      }
      const language = detectLanguage(filePath);
      if (!language || !isJsFamily(language)) {
        return { named: [], default: null, reExports: [], cjsExports: [], type: "cjs", language, error: "unsupported_language" };
      }
      let parseCode = code;
      if (needsTypeStripping(filePath)) {
        parseCode = stripTypeScript(code);
      }
      const ast = parseWithAcorn(parseCode);
      let esmResult = { named: [], default: null, reExports: [] };
      if (ast) {
        esmResult = walkAstForExports(ast);
      }
      const cjsExports = extractCjsExports(code);
      const hasEsm = esmResult.named.length > 0 || esmResult.default !== null || esmResult.reExports.length > 0;
      const hasCjs = cjsExports.length > 0;
      let type = "cjs";
      if (hasEsm && hasCjs) type = "mixed";
      else if (hasEsm) type = "esm";
      return {
        named: esmResult.named,
        default: esmResult.default,
        reExports: esmResult.reExports,
        cjsExports,
        type,
        language
      };
    }
    var COMPLEXITY_NODES = /* @__PURE__ */ new Set([
      "IfStatement",
      "ConditionalExpression",
      "ForStatement",
      "ForInStatement",
      "ForOfStatement",
      "WhileStatement",
      "DoWhileStatement",
      "CatchClause",
      "LogicalExpression"
    ]);
    var SWITCH_CASE_NODE = "SwitchCase";
    var NESTING_NODES = /* @__PURE__ */ new Set([
      "IfStatement",
      "ForStatement",
      "ForInStatement",
      "ForOfStatement",
      "WhileStatement",
      "DoWhileStatement",
      "SwitchStatement",
      "CatchClause"
    ]);
    function walkComplexity(node, currentDepth) {
      if (!node || typeof node !== "object") return { complexity: 0, nesting_max: currentDepth };
      let complexity = 0;
      let maxNesting = currentDepth;
      if (COMPLEXITY_NODES.has(node.type)) {
        complexity += 1;
      }
      if (node.type === SWITCH_CASE_NODE && node.test !== null) {
        complexity += 1;
      }
      const isNesting = NESTING_NODES.has(node.type);
      const childDepth = isNesting ? currentDepth + 1 : currentDepth;
      if (childDepth > maxNesting) maxNesting = childDepth;
      for (const key of Object.keys(node)) {
        if (key === "type" || key === "start" || key === "end" || key === "loc" || key === "range") continue;
        const child = node[key];
        if (Array.isArray(child)) {
          for (const item of child) {
            if (item && typeof item === "object" && item.type) {
              if (item.type === "FunctionDeclaration" || item.type === "FunctionExpression" || item.type === "ArrowFunctionExpression") continue;
              const sub = walkComplexity(item, childDepth);
              complexity += sub.complexity;
              if (sub.nesting_max > maxNesting) maxNesting = sub.nesting_max;
            }
          }
        } else if (child && typeof child === "object" && child.type) {
          if (child.type === "FunctionDeclaration" || child.type === "FunctionExpression" || child.type === "ArrowFunctionExpression") continue;
          const sub = walkComplexity(child, childDepth);
          complexity += sub.complexity;
          if (sub.nesting_max > maxNesting) maxNesting = sub.nesting_max;
        }
      }
      return { complexity, nesting_max: maxNesting };
    }
    function extractFunctionBodies(ast, code) {
      const functions = [];
      function visit(node, parentClassName) {
        if (!node || typeof node !== "object") return;
        switch (node.type) {
          case "FunctionDeclaration":
            if (node.id && node.body) {
              functions.push({
                name: node.id.name,
                line: posToLine(code, node.start),
                body: node.body
              });
            }
            break;
          case "ClassDeclaration":
            if (node.id && node.body && node.body.body) {
              for (const member of node.body.body) {
                if (member.type === "MethodDefinition" && member.key && member.value && member.value.body) {
                  const methodName = member.key.name || member.key.value || "anonymous";
                  functions.push({
                    name: `${node.id.name}.${methodName}`,
                    line: posToLine(code, member.start),
                    body: member.value.body
                  });
                }
                if (member.type === "PropertyDefinition" && member.key && member.value) {
                  if ((member.value.type === "ArrowFunctionExpression" || member.value.type === "FunctionExpression") && member.value.body) {
                    const fieldName = member.key.name || member.key.value || "anonymous";
                    functions.push({
                      name: `${node.id.name}.${fieldName}`,
                      line: posToLine(code, member.start),
                      body: member.value.body
                    });
                  }
                }
              }
            }
            return;
          case "VariableDeclaration":
            for (const decl of node.declarations) {
              if (decl.id && decl.id.type === "Identifier" && decl.init) {
                if ((decl.init.type === "ArrowFunctionExpression" || decl.init.type === "FunctionExpression") && decl.init.body) {
                  functions.push({
                    name: decl.id.name,
                    line: posToLine(code, node.start),
                    body: decl.init.body
                  });
                }
              }
            }
            break;
          case "ExpressionStatement":
            if (node.expression && node.expression.type === "AssignmentExpression") {
              const left = node.expression.left;
              const right = node.expression.right;
              if (right && (right.type === "FunctionExpression" || right.type === "ArrowFunctionExpression") && right.body) {
                let name = null;
                if (left.type === "MemberExpression" && left.object) {
                  if (left.object.type === "MemberExpression" && left.object.object && left.object.object.name === "module" && left.object.property && left.object.property.name === "exports" && left.property) {
                    name = left.property.name || left.property.value;
                  } else if (left.object.name === "exports" && left.property) {
                    name = left.property.name || left.property.value;
                  }
                }
                if (name) {
                  functions.push({
                    name,
                    line: posToLine(code, node.start),
                    body: right.body
                  });
                }
              }
            }
            break;
        }
        for (const key of Object.keys(node)) {
          if (key === "type" || key === "start" || key === "end" || key === "loc" || key === "range") continue;
          const child = node[key];
          if (Array.isArray(child)) {
            for (const item of child) {
              if (item && typeof item === "object" && item.type) visit(item);
            }
          } else if (child && typeof child === "object" && child.type) {
            visit(child);
          }
        }
      }
      if (ast.body) {
        for (const node of ast.body) {
          visit(node);
        }
      }
      return functions;
    }
    function regexComplexity(code) {
      const patterns = [
        /\bif\b/g,
        /\belse\s+if\b/g,
        /\bfor\b/g,
        /\bwhile\b/g,
        /\bswitch\b/g,
        /\bcase\b/g,
        /\bcatch\b/g,
        /&&/g,
        /\|\|/g
      ];
      let count = 1;
      for (const pattern of patterns) {
        const matches = code.match(pattern);
        if (matches) count += matches.length;
      }
      return count;
    }
    function computeComplexity(filePath) {
      let code;
      try {
        code = fs.readFileSync(filePath, "utf-8");
      } catch (e) {
        return { file: filePath, module_complexity: 0, functions: [], error: "file_not_found" };
      }
      const language = detectLanguage(filePath);
      if (!language) {
        return { file: filePath, module_complexity: 0, functions: [], error: "unknown_language" };
      }
      if (isJsFamily(language)) {
        let parseCode = code;
        if (needsTypeStripping(filePath)) {
          parseCode = stripTypeScript(code);
        }
        const ast = parseWithAcorn(parseCode);
        if (!ast) {
          const approx2 = regexComplexity(code);
          return {
            file: filePath,
            module_complexity: approx2,
            functions: [{ name: "<module>", line: 1, complexity: approx2, nesting_max: 0 }],
            error: "parse_failed_regex_fallback"
          };
        }
        const fnBodies = extractFunctionBodies(ast, parseCode);
        const functions = [];
        let moduleComplexity = 0;
        for (const fn of fnBodies) {
          const result = walkComplexity(fn.body, 0);
          const complexity = 1 + result.complexity;
          functions.push({
            name: fn.name,
            line: fn.line,
            complexity,
            nesting_max: result.nesting_max
          });
          moduleComplexity += complexity;
        }
        return { file: filePath, module_complexity: moduleComplexity, functions };
      }
      const approx = regexComplexity(code);
      return {
        file: filePath,
        module_complexity: approx,
        functions: [{ name: "<module>", line: 1, complexity: approx, nesting_max: 0 }]
      };
    }
    function generateRepoMap(cwd, options) {
      const opts = options || {};
      const tokenBudget = opts.tokenBudget || 1e3;
      const charBudget = tokenBudget * 4;
      const { getSourceDirs, walkSourceFiles, SKIP_DIRS, LANGUAGE_MAP: LANGUAGE_MAP2 } = require_codebase_intel();
      const sourceDirs = getSourceDirs(cwd);
      const allFiles = walkSourceFiles(cwd, sourceDirs, SKIP_DIRS);
      const codeExtensions = /* @__PURE__ */ new Set([
        ".js",
        ".cjs",
        ".mjs",
        ".ts",
        ".tsx",
        ".jsx",
        ".py",
        ".pyw",
        ".go",
        ".rs",
        ".rb",
        ".rake",
        ".java",
        ".kt",
        ".php",
        ".ex",
        ".exs",
        ".c",
        ".h",
        ".cpp",
        ".hpp",
        ".cc",
        ".swift",
        ".dart",
        ".lua",
        ".zig",
        ".nim"
      ]);
      const sourceFiles = allFiles.filter((f) => {
        const ext = path.extname(f);
        if (!codeExtensions.has(ext)) return false;
        if (f.includes("bin/") || f.includes("dist/") || f.includes("build/")) return false;
        return true;
      });
      const fileData = [];
      for (const relPath of sourceFiles) {
        const absPath = path.join(cwd, relPath);
        const sigResult = extractSignatures(absPath);
        const expResult = isJsFamily(detectLanguage(absPath)) ? extractExports(absPath) : null;
        const exportNames = [];
        if (expResult) {
          if (expResult.named && expResult.named.length > 0) exportNames.push(...expResult.named);
          if (expResult.cjsExports && expResult.cjsExports.length > 0) exportNames.push(...expResult.cjsExports);
          if (expResult.default) exportNames.push("default:" + expResult.default);
        }
        const exportCount = exportNames.length;
        const signatures = sigResult.signatures || [];
        if (signatures.length === 0 && exportCount === 0) continue;
        fileData.push({
          path: relPath,
          signatures,
          exportNames,
          exportCount,
          sigCount: signatures.length
        });
      }
      fileData.sort((a, b) => b.sigCount - a.sigCount);
      const lines = ["# Repo Map", ""];
      let totalChars = lines.join("\n").length;
      let filesIncluded = 0;
      let totalSignatures = 0;
      for (const file of fileData) {
        const fileLines = [];
        const exportLabel = file.exportCount > 0 ? ` (${file.exportCount} exports)` : "";
        fileLines.push(`## ${file.path}${exportLabel}`);
        const remainingChars = charBudget * 1.2 - totalChars;
        const maxSigsPerFile = remainingChars < 2e3 ? 10 : 30;
        const displaySigs = file.signatures.slice(0, maxSigsPerFile);
        for (const sig of displaySigs) {
          const prefix = sig.type === "method" ? "    method" : sig.type === "class" ? "  class" : sig.type === "arrow" ? "  fn" : "  fn";
          const asyncMark = sig.async ? "async " : "";
          let paramsStr = sig.params.join(", ");
          if (paramsStr.length > 40) paramsStr = paramsStr.substring(0, 37) + "...";
          fileLines.push(`${prefix} ${asyncMark}${sig.name}(${paramsStr}) :${sig.line}`);
        }
        if (file.signatures.length > maxSigsPerFile) {
          fileLines.push(`  ... +${file.signatures.length - maxSigsPerFile} more`);
        }
        if (file.exportNames.length > 0) {
          let exportStr = file.exportNames.join(", ");
          if (exportStr.length > 60) exportStr = exportStr.substring(0, 57) + "...";
          fileLines.push(`  exports: ${exportStr}`);
        }
        fileLines.push("");
        const sectionText = fileLines.join("\n");
        const sectionChars = sectionText.length;
        if (totalChars + sectionChars > charBudget * 1.2 && filesIncluded > 0) {
          break;
        }
        lines.push(sectionText);
        totalChars += sectionChars;
        filesIncluded++;
        totalSignatures += file.sigCount;
      }
      const summary = lines.join("\n").trim();
      const tokenEstimate = Math.ceil(summary.length / 4);
      return {
        summary,
        files_included: filesIncluded,
        total_signatures: totalSignatures,
        token_estimate: tokenEstimate
      };
    }
    module2.exports = {
      extractSignatures,
      extractExports,
      computeComplexity,
      generateRepoMap,
      DETECTOR_REGISTRY,
      // Internal helpers exposed for testing
      stripTypeScript,
      parseWithAcorn,
      extractCjsExports,
      extractJsSignaturesRegex
    };
  }
});

// src/lib/context.js
var require_context = __commonJS({
  "src/lib/context.js"(exports2, module2) {
    "use strict";
    var { debugLog } = require_output();
    var _estimateTokenCount = null;
    function getTokenizer() {
      if (_estimateTokenCount !== null) return _estimateTokenCount;
      try {
        const tokenx = (init_dist(), __toCommonJS(dist_exports));
        _estimateTokenCount = tokenx.estimateTokenCount;
        debugLog("context.tokenizer", "tokenx loaded successfully");
      } catch (e) {
        debugLog("context.tokenizer", "tokenx load failed, using fallback", e);
        _estimateTokenCount = (text) => Math.ceil(String(text).length / 4);
      }
      return _estimateTokenCount;
    }
    function estimateTokens(text) {
      if (!text || typeof text !== "string") return 0;
      try {
        const fn = getTokenizer();
        return fn(text);
      } catch (e) {
        debugLog("context.estimateTokens", "estimation failed, using fallback", e);
        return Math.ceil(text.length / 4);
      }
    }
    function estimateJsonTokens(obj) {
      if (obj === void 0 || obj === null) return 0;
      try {
        return estimateTokens(JSON.stringify(obj));
      } catch (e) {
        debugLog("context.estimateJsonTokens", "stringify failed", e);
        return 0;
      }
    }
    function checkBudget(tokens, config = {}) {
      const contextWindow = config.context_window || 2e5;
      const targetPercent = config.context_target_percent || 50;
      const percent = Math.round(tokens / contextWindow * 100);
      const warning = percent > targetPercent;
      let recommendation = null;
      if (percent > 80) {
        recommendation = "Critical: exceeds 80% of context window. Split into smaller units.";
      } else if (percent > 60) {
        recommendation = "High: exceeds 60% of context window. Consider reducing scope.";
      } else if (percent > targetPercent) {
        recommendation = `Above target: exceeds ${targetPercent}% target. Monitor closely.`;
      }
      return { tokens, percent, warning, recommendation };
    }
    function isWithinBudget(text, config = {}) {
      const tokens = estimateTokens(text);
      return checkBudget(tokens, config);
    }
    var AGENT_MANIFESTS = {
      "gsd-executor": {
        fields: [
          "phase_dir",
          "phase_number",
          "phase_name",
          "plans",
          "incomplete_plans",
          "plan_count",
          "incomplete_count",
          "branch_name",
          "commit_docs",
          "verifier_enabled",
          "task_routing",
          "env_summary"
        ],
        optional: ["codebase_conventions", "codebase_dependencies"],
        exclude: [
          "intent_drift",
          "intent_summary",
          "worktree_config",
          "worktree_active",
          "file_overlaps",
          "codebase_freshness",
          "codebase_stats"
        ]
      },
      "gsd-verifier": {
        fields: [
          "phase_dir",
          "phase_number",
          "phase_name",
          "plans",
          "summaries",
          "verifier_enabled"
        ],
        optional: ["codebase_stats"],
        exclude: [
          "intent_drift",
          "intent_summary",
          "task_routing",
          "worktree_config",
          "worktree_active",
          "file_overlaps",
          "env_summary",
          "branch_name",
          "codebase_conventions",
          "codebase_dependencies"
        ]
      },
      "gsd-planner": {
        fields: [
          "phase_dir",
          "phase_number",
          "phase_name",
          "plan_count",
          "research_enabled",
          "plan_checker_enabled",
          "intent_summary"
        ],
        optional: [
          "codebase_stats",
          "codebase_conventions",
          "codebase_dependencies",
          "codebase_freshness",
          "env_summary"
        ],
        exclude: [
          "task_routing",
          "worktree_config",
          "worktree_active",
          "file_overlaps",
          "branch_name"
        ]
      },
      "gsd-phase-researcher": {
        fields: ["phase_dir", "phase_number", "phase_name", "intent_summary"],
        optional: ["codebase_stats", "env_summary"],
        exclude: [
          "task_routing",
          "worktree_config",
          "worktree_active",
          "file_overlaps",
          "branch_name",
          "verifier_enabled",
          "plans",
          "incomplete_plans"
        ]
      },
      "gsd-plan-checker": {
        fields: ["phase_dir", "phase_number", "phase_name", "plans", "plan_count"],
        optional: ["codebase_stats", "codebase_dependencies"],
        exclude: [
          "intent_drift",
          "intent_summary",
          "task_routing",
          "worktree_config",
          "worktree_active",
          "file_overlaps",
          "env_summary",
          "branch_name"
        ]
      },
      "gsd-reviewer": {
        fields: ["phase_dir", "phase_number", "phase_name", "codebase_conventions", "codebase_dependencies"],
        optional: ["codebase_stats"],
        exclude: ["intent_summary", "plan_count", "summaries", "incomplete_plans"]
      }
    };
    function scopeContextForAgent(result, agentType) {
      const manifest = AGENT_MANIFESTS[agentType];
      if (!manifest || !result) return result;
      const originalKeys = Object.keys(result).length;
      const allowed = /* @__PURE__ */ new Set([...manifest.fields, ...manifest.optional]);
      const scoped = { _agent: agentType };
      for (const key of allowed) {
        if (key in result && result[key] !== void 0 && result[key] !== null) {
          scoped[key] = result[key];
        } else if (manifest.fields.includes(key) && key in result) {
          scoped[key] = result[key];
        }
      }
      const scopedKeys = Object.keys(scoped).length - 1;
      scoped._savings = {
        original_keys: originalKeys,
        scoped_keys: scopedKeys,
        reduction_pct: originalKeys > 0 ? Math.round((1 - scopedKeys / originalKeys) * 100) : 0
      };
      return scoped;
    }
    function compactPlanState(stateRaw) {
      if (!stateRaw || typeof stateRaw !== "string") {
        return { phase: null, progress: null, status: null, last_activity: null, decisions: [], blockers: [] };
      }
      let phase = null, progress = null, status = null, lastActivity = null;
      const phaseMatch = stateRaw.match(/^Phase:\s*(\S+)/m);
      if (phaseMatch) phase = phaseMatch[1];
      const planMatch = stateRaw.match(/^Plan:\s*(.+)$/m);
      if (planMatch) progress = planMatch[1].trim();
      const statusMatch = stateRaw.match(/^Status:\s*(.+)$/m);
      if (statusMatch) status = statusMatch[1].trim();
      const activityMatch = stateRaw.match(/^Last activity:\s*(\S+)/m);
      if (activityMatch) lastActivity = activityMatch[1];
      const decisions = [];
      const decisionRe = /^- Phase .+$/gm;
      let m;
      while ((m = decisionRe.exec(stateRaw)) !== null) {
        decisions.push(m[0].replace(/^- /, ""));
      }
      const blockers = [];
      const blockerSection = stateRaw.match(/### Blockers\/Concerns\n([\s\S]*?)(?:\n## |\n$|$)/);
      if (blockerSection) {
        const lines = blockerSection[1].trim().split("\n").filter((l) => l.startsWith("- "));
        for (const line of lines) {
          const text = line.replace(/^- /, "").trim();
          if (text && text.toLowerCase() !== "none" && text.toLowerCase() !== "none.") {
            blockers.push(text);
          }
        }
      }
      return {
        phase,
        progress,
        status,
        last_activity: lastActivity,
        decisions: decisions.slice(-5),
        blockers
      };
    }
    function compactDepGraph(depData) {
      if (!depData || typeof depData !== "object") return {};
      return {
        total_modules: depData.total_modules || 0,
        total_edges: depData.total_edges || 0,
        top_imported: Array.isArray(depData.top_imported) ? depData.top_imported.slice(0, 5) : [],
        has_cycles: !!depData.has_cycles
      };
    }
    function scoreTaskFile(file, taskFiles, graph, planFiles, recentFiles) {
      if (taskFiles.includes(file)) return { score: 1, reason: "direct task file" };
      let score = 0;
      const reasons = [];
      for (const tf of taskFiles) {
        if ((graph.forward[tf] || []).includes(file)) {
          score += 0.7;
          reasons.push("imported by task file");
          break;
        }
        if ((graph.reverse[tf] || []).includes(file)) {
          score += 0.5;
          reasons.push("imports task file");
          break;
        }
      }
      if (planFiles.includes(file)) {
        score += 0.3;
        reasons.push("in plan scope");
      }
      if (recentFiles.has(file)) {
        score += 0.2;
        reasons.push("recently modified");
      }
      return { score: Math.min(score, 1), reason: reasons.join(", ") || "none" };
    }
    function buildTaskContext(cwd, taskFiles, options) {
      const opts = options || {};
      const planFiles = opts.planFiles || [];
      const tokenBudget = opts.tokenBudget || 3e3;
      const includeSignatures = opts.includeSignatures !== false;
      if (!taskFiles || taskFiles.length === 0) {
        return { task_files: [], context_files: [], stats: { candidates_found: 0, files_included: 0, files_excluded: 0, token_estimate: 0, reduction_pct: 0 } };
      }
      let graph = { forward: {}, reverse: {} };
      try {
        const { readIntel } = require_codebase_intel();
        const intel = readIntel(cwd);
        if (intel && intel.dependencies) {
          graph = intel.dependencies;
        } else if (intel) {
          const { buildDependencyGraph } = require_deps();
          graph = buildDependencyGraph(intel);
        }
      } catch {
      }
      const candidateSet = new Set(taskFiles);
      for (const tf of taskFiles) {
        for (const dep of graph.forward[tf] || []) candidateSet.add(dep);
        for (const dep of graph.reverse[tf] || []) candidateSet.add(dep);
      }
      let recentFiles = /* @__PURE__ */ new Set();
      try {
        const { execGit } = require_git();
        const result = execGit(cwd, ["log", "-10", "--name-only", "--pretty=format:", "--no-merges"]);
        if (result.exitCode === 0) recentFiles = new Set(result.stdout.split("\n").filter((f) => f.trim()));
      } catch {
      }
      const scored = [];
      for (const file of candidateSet) {
        const { score, reason } = scoreTaskFile(file, taskFiles, graph, planFiles, recentFiles);
        if (score >= 0.3) scored.push({ path: file, score, reason });
      }
      scored.sort((a, b) => b.score - a.score);
      if (includeSignatures) {
        try {
          const { extractSignatures } = require_ast();
          const path = require("path");
          for (const entry of scored) {
            if (entry.score < 1) {
              const result = extractSignatures(path.resolve(cwd, entry.path));
              if (result.signatures && result.signatures.length > 0) {
                entry.signatures = result.signatures.map((s) => ({ name: s.name, type: s.type, params: s.params }));
              }
            }
          }
        } catch {
        }
      }
      const allCandidates = scored.length;
      let tokenEstimate = estimateJsonTokens(scored);
      while (tokenEstimate > tokenBudget && scored.length > 1) {
        scored.pop();
        tokenEstimate = estimateJsonTokens(scored);
      }
      const fullEstimate = allCandidates > scored.length ? Math.round(tokenEstimate * allCandidates / Math.max(scored.length, 1)) : tokenEstimate;
      const reductionPct = fullEstimate > 0 ? Math.round((1 - tokenEstimate / fullEstimate) * 100) : 0;
      return {
        task_files: taskFiles,
        context_files: scored,
        stats: {
          candidates_found: allCandidates,
          files_included: scored.length,
          files_excluded: allCandidates - scored.length,
          token_estimate: tokenEstimate,
          reduction_pct: Math.max(reductionPct, 0)
        }
      };
    }
    module2.exports = {
      estimateTokens,
      estimateJsonTokens,
      checkBudget,
      isWithinBudget,
      AGENT_MANIFESTS,
      scopeContextForAgent,
      compactPlanState,
      compactDepGraph,
      buildTaskContext
    };
  }
});

// src/commands/codebase.js
var require_codebase = __commonJS({
  "src/commands/codebase.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var { output, error, debugLog } = require_output();
    var {
      checkStaleness,
      performAnalysis,
      readIntel,
      writeIntel,
      getGitInfo,
      getChangedFilesSinceCommit
    } = require_codebase_intel();
    var { banner, sectionHeader, formatTable, summaryLine, color, SYMBOLS, box, relativeTime } = require_format();
    function formatCodebaseAnalyze(result) {
      const lines = [];
      lines.push(banner("Codebase Analyze"));
      lines.push("");
      if (!result.success) {
        lines.push(box("Analysis failed", "error"));
        return lines.join("\n");
      }
      const mode = result.mode || "full";
      lines.push("  " + color.green(SYMBOLS.check + " Analysis complete") + "  " + color.dim("(" + mode + ")"));
      lines.push("");
      const filesAnalyzed = result.files_analyzed || 0;
      const totalFiles = result.total_files || 0;
      lines.push("  " + filesAnalyzed + " files analyzed, " + totalFiles + " total");
      if (result.languages && result.languages.length > 0) {
        lines.push("  " + result.languages.join(", "));
      }
      if (result.duration_ms !== void 0) {
        lines.push("  " + color.dim(result.duration_ms + "ms"));
      }
      lines.push("");
      lines.push(summaryLine("Analysis complete (" + mode + ")"));
      return lines.join("\n");
    }
    function cmdCodebaseAnalyze(cwd, args, raw) {
      const forceFull = args.includes("--full");
      const startMs = Date.now();
      let mode = "full";
      let previousIntel = null;
      let changedFiles = null;
      if (!forceFull) {
        previousIntel = readIntel(cwd);
        if (previousIntel) {
          const staleness = checkStaleness(cwd);
          if (staleness.stale && staleness.changed_files && staleness.changed_files.length > 0) {
            mode = "incremental";
            changedFiles = staleness.changed_files;
            debugLog("codebase.analyze", `incremental mode: ${changedFiles.length} changed files`);
          } else if (!staleness.stale) {
            const durationMs2 = Date.now() - startMs;
            output({
              success: true,
              mode: "cached",
              files_analyzed: 0,
              total_files: previousIntel.stats.total_files,
              languages: Object.keys(previousIntel.languages),
              duration_ms: durationMs2,
              path: ".planning/codebase/codebase-intel.json"
            }, { formatter: formatCodebaseAnalyze });
            return;
          }
        }
      }
      debugLog("codebase.analyze", `analyzing in ${mode} mode...`);
      const intel = performAnalysis(cwd, {
        incremental: mode === "incremental",
        previousIntel,
        changedFiles
      });
      if (previousIntel) {
        if (previousIntel.conventions && !intel.conventions) intel.conventions = previousIntel.conventions;
        if (previousIntel.dependencies && !intel.dependencies) intel.dependencies = previousIntel.dependencies;
        if (previousIntel.lifecycle && !intel.lifecycle) intel.lifecycle = previousIntel.lifecycle;
      }
      writeIntel(cwd, intel);
      const durationMs = Date.now() - startMs;
      const filesAnalyzed = mode === "incremental" && changedFiles ? changedFiles.length : intel.stats.total_files;
      try {
        fs.unlinkSync(path.join(cwd, ".planning", ".cache", ".analyzing"));
      } catch {
      }
      output({
        success: true,
        mode,
        files_analyzed: filesAnalyzed,
        total_files: intel.stats.total_files,
        languages: Object.keys(intel.languages),
        duration_ms: durationMs,
        path: ".planning/codebase/codebase-intel.json"
      }, { formatter: formatCodebaseAnalyze });
    }
    function formatCodebaseStatus(result) {
      const lines = [];
      lines.push(banner("Codebase"));
      lines.push("");
      if (!result.exists) {
        lines.push(box("No codebase intel. Run: codebase analyze", "warning"));
        return lines.join("\n");
      }
      if (result.stale) {
        lines.push(box("Intel is stale: " + (result.reason || "unknown"), "warning"));
        lines.push("");
        if (result.changed_files && result.changed_files.length > 0) {
          lines.push("  " + color.yellow(result.changed_files.length + " files changed"));
        }
        if (result.changed_groups) {
          const g = result.changed_groups;
          const parts = [];
          if (g.added && g.added.length > 0) parts.push(color.green(g.added.length + " added"));
          if (g.modified && g.modified.length > 0) parts.push(color.yellow(g.modified.length + " modified"));
          if (g.deleted && g.deleted.length > 0) parts.push(color.red(g.deleted.length + " deleted"));
          if (parts.length > 0) {
            lines.push("  " + parts.join(", "));
          }
        }
        lines.push("");
        lines.push(summaryLine("Stale \u2014 run codebase analyze"));
      } else {
        lines.push("  " + color.green(SYMBOLS.check + " Intel is fresh"));
        if (result.generated_at) {
          lines.push("  Generated " + relativeTime(result.generated_at));
        }
        const fileCount = result.total_files || 0;
        const langCount = result.languages ? result.languages.length : 0;
        lines.push("  " + fileCount + " files, " + langCount + " languages");
        lines.push("");
        lines.push(summaryLine("Fresh"));
      }
      return lines.join("\n");
    }
    function cmdCodebaseStatus(cwd, args, raw) {
      const intel = readIntel(cwd);
      if (!intel) {
        output({
          exists: false,
          message: "No codebase intel. Run: codebase analyze"
        }, { formatter: formatCodebaseStatus });
        return;
      }
      const staleness = checkStaleness(cwd);
      const gitInfo = getGitInfo(cwd);
      if (staleness.stale) {
        let changedGroups = null;
        if (staleness.changed_files && staleness.changed_files.length > 0 && intel.git_commit_hash) {
          changedGroups = groupChangedFiles(cwd, intel.git_commit_hash, staleness.changed_files);
        }
        output({
          exists: true,
          stale: true,
          reason: staleness.reason,
          changed_files: staleness.changed_files || [],
          changed_groups: changedGroups,
          intel_commit: intel.git_commit_hash,
          current_commit: gitInfo.commit_hash,
          generated_at: intel.generated_at
        }, { formatter: formatCodebaseStatus });
      } else {
        output({
          exists: true,
          stale: false,
          generated_at: intel.generated_at,
          git_commit_hash: intel.git_commit_hash,
          total_files: intel.stats.total_files,
          total_lines: intel.stats.total_lines,
          languages: Object.keys(intel.languages),
          languages_detected: intel.stats.languages_detected
        }, { formatter: formatCodebaseStatus });
      }
    }
    function groupChangedFiles(cwd, fromCommit, changedFiles) {
      const { execGit } = require_git();
      const addedResult = execGit(cwd, ["diff", "--name-only", "--diff-filter=A", fromCommit, "HEAD"]);
      const modifiedResult = execGit(cwd, ["diff", "--name-only", "--diff-filter=M", fromCommit, "HEAD"]);
      const deletedResult = execGit(cwd, ["diff", "--name-only", "--diff-filter=D", fromCommit, "HEAD"]);
      const parse = (result) => {
        if (result.exitCode !== 0) return [];
        return result.stdout.split("\n").filter((f) => f.trim().length > 0);
      };
      const added = parse(addedResult);
      const modified = parse(modifiedResult);
      const deleted = parse(deletedResult);
      if (added.length === 0 && modified.length === 0 && deleted.length === 0) {
        return null;
      }
      return { added, modified, deleted };
    }
    function spawnBackgroundAnalysis(cwd) {
      try {
        const lockPath = path.join(cwd, ".planning", ".cache", ".analyzing");
        try {
          const lockStat = fs.statSync(lockPath);
          const lockAgeMs = Date.now() - lockStat.mtimeMs;
          const LOCK_TIMEOUT = 5 * 60 * 1e3;
          if (lockAgeMs < LOCK_TIMEOUT) {
            debugLog("codebase.bgAnalysis", "lock file exists, skipping");
            return;
          }
          debugLog("codebase.bgAnalysis", "stale lock detected, cleaning up");
          fs.unlinkSync(lockPath);
        } catch (e) {
          if (e.code !== "ENOENT") {
            debugLog("codebase.bgAnalysis", "lock check error", e);
            return;
          }
        }
        const cacheDir = path.join(cwd, ".planning", ".cache");
        try {
          fs.mkdirSync(cacheDir, { recursive: true });
        } catch {
        }
        try {
          fs.writeFileSync(lockPath, String(process.pid));
        } catch {
          return;
        }
        try {
          const { spawn } = require("child_process");
          const gsdBin = path.resolve(__dirname, "../../bin/gsd-tools.cjs");
          const child = spawn(process.execPath, [gsdBin, "codebase", "analyze", "--raw"], {
            cwd,
            detached: true,
            stdio: "ignore",
            env: { ...process.env, GSD_BG_ANALYSIS: "1" }
          });
          child.unref();
          debugLog("codebase.bgAnalysis", `spawned background analysis (pid: ${child.pid})`);
        } catch (e) {
          debugLog("codebase.bgAnalysis", "spawn failed", e);
          try {
            fs.unlinkSync(lockPath);
          } catch {
          }
        }
      } catch (e) {
        debugLog("codebase.bgAnalysis", "unexpected error", e);
      }
    }
    function autoTriggerCodebaseIntel(cwd, options) {
      const opts = options || {};
      const synchronous = opts.synchronous || false;
      const planningDir = path.join(cwd, ".planning");
      if (!fs.existsSync(planningDir)) return null;
      const intel = readIntel(cwd);
      if (!intel) {
        debugLog("codebase.autoTrigger", "no existing intel, skipping (first run needs explicit analyze)");
        return null;
      }
      try {
        const staleness = checkStaleness(cwd);
        if (!staleness.stale) {
          debugLog("codebase.autoTrigger", "intel is fresh");
          return intel;
        }
        if (synchronous) {
          debugLog("codebase.autoTrigger", `stale (${staleness.reason}), running synchronous analysis (--refresh)`);
          const newIntel = performAnalysis(cwd, {
            incremental: !!(staleness.changed_files && staleness.changed_files.length > 0),
            previousIntel: intel,
            changedFiles: staleness.changed_files || null
          });
          if (intel.conventions && !newIntel.conventions) {
            newIntel.conventions = intel.conventions;
          }
          if (intel.dependencies && !newIntel.dependencies) {
            newIntel.dependencies = intel.dependencies;
          }
          if (intel.lifecycle && !newIntel.lifecycle) {
            newIntel.lifecycle = intel.lifecycle;
          }
          writeIntel(cwd, newIntel);
          return newIntel;
        }
        debugLog("codebase.autoTrigger", `stale (${staleness.reason}), returning cached + spawning background`);
        spawnBackgroundAnalysis(cwd);
        return intel;
      } catch (e) {
        debugLog("codebase.autoTrigger", `analysis failed: ${e.message}`);
        return intel;
      }
    }
    function readCodebaseIntel(cwd) {
      return readIntel(cwd);
    }
    function checkCodebaseIntelStaleness(cwd) {
      return checkStaleness(cwd);
    }
    function cmdCodebaseConventions(cwd, args, raw) {
      const intel = readIntel(cwd);
      if (!intel) {
        error("No codebase intel. Run: codebase analyze");
        return;
      }
      const { extractConventions } = require_conventions();
      const showAll = args.includes("--all");
      const thresholdIdx = args.indexOf("--threshold");
      const threshold = thresholdIdx !== -1 ? parseInt(args[thresholdIdx + 1], 10) : 60;
      const conventions = extractConventions(intel, { threshold, showAll, cwd });
      intel.conventions = conventions;
      writeIntel(cwd, intel);
      const namingPatterns = [];
      for (const [, value] of Object.entries(conventions.naming.overall || {})) {
        namingPatterns.push({
          scope: "project",
          pattern: value.pattern,
          confidence: value.confidence,
          file_count: value.file_count,
          examples: value.examples
        });
      }
      for (const [dir, value] of Object.entries(conventions.naming.by_directory || {})) {
        namingPatterns.push({
          scope: dir,
          pattern: value.dominant_pattern,
          confidence: value.confidence,
          file_count: value.file_count,
          examples: value.patterns[value.dominant_pattern] ? value.patterns[value.dominant_pattern].examples : []
        });
      }
      const frameworkPatterns = conventions.frameworks || [];
      output({
        success: true,
        naming_patterns: namingPatterns,
        file_organization: conventions.file_organization,
        framework_patterns: frameworkPatterns,
        total_conventions: namingPatterns.length + (conventions.file_organization.patterns || []).length + frameworkPatterns.length,
        threshold_used: threshold,
        show_all: showAll,
        extracted_at: conventions.extracted_at
      }, raw);
    }
    function cmdCodebaseRules(cwd, args, raw) {
      const intel = readIntel(cwd);
      if (!intel) {
        error("No codebase intel. Run: codebase analyze");
        return;
      }
      const { extractConventions, generateRules } = require_conventions();
      let conventions = intel.conventions;
      if (!conventions) {
        debugLog("codebase.rules", "no cached conventions, running extraction");
        conventions = extractConventions(intel, { cwd });
        intel.conventions = conventions;
        writeIntel(cwd, intel);
      }
      const thresholdIdx = args.indexOf("--threshold");
      const threshold = thresholdIdx !== -1 ? parseInt(args[thresholdIdx + 1], 10) : 60;
      const maxIdx = args.indexOf("--max");
      const maxRules = maxIdx !== -1 ? parseInt(args[maxIdx + 1], 10) : 15;
      const result = generateRules(conventions, { threshold, maxRules });
      output({
        success: true,
        rules: result.rules,
        rules_text: result.rules_text,
        rule_count: result.rule_count,
        total_conventions: result.total_conventions,
        filtered_count: result.filtered_count
      }, raw, result.rules_text + "\n");
    }
    function cmdCodebaseDeps(cwd, args, raw) {
      const intel = readIntel(cwd);
      if (!intel) {
        error("No codebase intel. Run: codebase analyze");
        return;
      }
      const wantCycles = args.includes("--cycles");
      const { buildDependencyGraph, findCycles } = require_deps();
      const graph = buildDependencyGraph(intel);
      intel.dependencies = graph;
      writeIntel(cwd, intel);
      const topDeps = Object.entries(graph.reverse).map(([file, importers]) => ({ file, imported_by_count: importers.length })).sort((a, b) => b.imported_by_count - a.imported_by_count).slice(0, 10);
      const result = {
        success: true,
        stats: graph.stats,
        top_dependencies: topDeps,
        built_at: graph.built_at
      };
      if (wantCycles) {
        result.cycles = findCycles(graph);
      }
      output(result, raw);
    }
    function cmdCodebaseImpact(cwd, args, raw) {
      const filePaths = args.filter((a) => !a.startsWith("-"));
      if (!filePaths || filePaths.length === 0) {
        error("Usage: codebase impact <file1> [file2] ...");
        return;
      }
      const intel = readIntel(cwd);
      if (!intel) {
        error("No codebase intel. Run: codebase analyze");
        return;
      }
      const { buildDependencyGraph, getTransitiveDependents } = require_deps();
      let graph = intel.dependencies;
      if (!graph) {
        debugLog("codebase.impact", "no dependency graph in intel, building...");
        graph = buildDependencyGraph(intel);
        intel.dependencies = graph;
        writeIntel(cwd, intel);
      }
      const files = [];
      for (const filePath of filePaths) {
        const result = getTransitiveDependents(graph, filePath);
        files.push(result);
      }
      output({
        success: true,
        files
      }, raw);
    }
    function cmdCodebaseLifecycle(cwd, args, raw) {
      const intel = readIntel(cwd);
      if (!intel) {
        error("No codebase intel. Run: codebase analyze");
        return;
      }
      const { buildLifecycleGraph } = require_lifecycle();
      const lifecycle = buildLifecycleGraph(intel, cwd);
      intel.lifecycle = lifecycle;
      writeIntel(cwd, intel);
      if (!raw) {
        const lines = [];
        if (lifecycle.nodes.length === 0) {
          lines.push("No lifecycle patterns detected.");
        } else {
          lines.push(`Lifecycle Analysis (${lifecycle.nodes.length} nodes, ${lifecycle.chains.length} chains)`);
          lines.push("");
          for (let i = 0; i < lifecycle.chains.length; i++) {
            const chain = lifecycle.chains[i];
            const nodeMap = {};
            for (let n = 0; n < lifecycle.nodes.length; n++) {
              nodeMap[lifecycle.nodes[n].id] = lifecycle.nodes[n];
            }
            let chainStr;
            if (chain.length <= 5) {
              chainStr = chain.map(function(id) {
                var node = nodeMap[id];
                return node ? node.file_or_step : id;
              }).join(" \u2192 ");
            } else {
              var first3 = chain.slice(0, 3).map(function(id) {
                var node = nodeMap[id];
                return node ? node.file_or_step : id;
              });
              var last = nodeMap[chain[chain.length - 1]];
              chainStr = first3.join(" \u2192 ") + " \u2192 ... +" + (chain.length - 4) + " more \u2192 " + (last ? last.file_or_step : chain[chain.length - 1]);
            }
            lines.push("  Chain " + (i + 1) + ": " + chainStr);
          }
          if (lifecycle.cycles.length > 0) {
            lines.push("");
            lines.push("WARNING: " + lifecycle.cycles.length + " cycle(s) detected");
            for (let c = 0; c < lifecycle.cycles.length; c++) {
              lines.push("  Cycle: " + lifecycle.cycles[c].join(" \u2192 "));
            }
          }
        }
        process.stderr.write(lines.join("\n") + "\n");
      }
      output({
        success: true,
        nodes: lifecycle.nodes.length,
        edges: lifecycle.stats.edge_count,
        chains: lifecycle.chains,
        cycles: lifecycle.cycles,
        detectors_used: lifecycle.detectors_used,
        stats: lifecycle.stats,
        built_at: lifecycle.built_at
      }, raw);
    }
    function scoreRelevance(file, targetFiles, graph, planFiles, recentFiles) {
      if (targetFiles.includes(file)) return 1;
      let score = 0;
      let is1Hop = false;
      let is2Hop = false;
      for (const target of targetFiles) {
        const fwd = graph.forward[target] || [];
        const rev = graph.reverse[target] || [];
        if (fwd.includes(file) || rev.includes(file)) {
          is1Hop = true;
          break;
        }
      }
      if (!is1Hop) {
        outer:
          for (const target of targetFiles) {
            const neighbors = [...graph.forward[target] || [], ...graph.reverse[target] || []];
            for (const neighbor of neighbors) {
              const nFwd = graph.forward[neighbor] || [];
              const nRev = graph.reverse[neighbor] || [];
              if (nFwd.includes(file) || nRev.includes(file)) {
                is2Hop = true;
                break outer;
              }
            }
          }
      }
      if (is1Hop) score += 0.5;
      else if (is2Hop) score += 0.25;
      if (planFiles.includes(file)) score += 0.3;
      if (recentFiles.has(file)) score += 0.2;
      return score;
    }
    function getRecentlyModifiedFiles(cwd, commitCount = 10) {
      const { execGit } = require_git();
      try {
        const result = execGit(cwd, ["log", `-${commitCount}`, "--name-only", "--pretty=format:", "--no-merges"]);
        if (result.exitCode !== 0) return /* @__PURE__ */ new Set();
        return new Set(result.stdout.split("\n").filter((f) => f.trim().length > 0));
      } catch {
        return /* @__PURE__ */ new Set();
      }
    }
    function getPlanFiles(cwd, planPath) {
      if (!planPath) return [];
      try {
        const { extractFrontmatter } = require_frontmatter();
        const resolved = path.resolve(cwd, planPath);
        const content = fs.readFileSync(resolved, "utf-8");
        const fm = extractFrontmatter(content);
        if (Array.isArray(fm.files_modified)) return fm.files_modified;
        if (typeof fm.files_modified === "string" && fm.files_modified.trim()) return [fm.files_modified];
      } catch (e) {
        debugLog("context.planFiles", "read failed", e);
      }
      return [];
    }
    function enforceTokenBudget(fileContexts, maxTokens = 5e3) {
      const { estimateJsonTokens } = require_context();
      const buildOutput = (files) => ({
        success: true,
        files,
        file_count: Object.keys(files).length,
        truncated: false
      });
      let tokens = estimateJsonTokens(buildOutput(fileContexts));
      if (tokens <= maxTokens) {
        return { files: fileContexts, truncated: false, omitted_files: 0 };
      }
      const cloned = JSON.parse(JSON.stringify(fileContexts));
      const levels = [
        // Level 1: Trim dependents to top 3
        (ctx) => {
          if (ctx.dependents) ctx.dependents = ctx.dependents.slice(0, 3);
        },
        // Level 2: Trim imports to top 3
        (ctx) => {
          if (ctx.imports) ctx.imports = ctx.imports.slice(0, 3);
        },
        // Level 3: Remove conventions
        (ctx) => {
          ctx.conventions = null;
        },
        // Level 4: Remove imports and dependents entirely (keep file + risk_level only)
        (ctx) => {
          ctx.imports = void 0;
          ctx.dependents = void 0;
        }
      ];
      for (const degrade of levels) {
        for (const key of Object.keys(cloned)) {
          degrade(cloned[key]);
        }
        tokens = estimateJsonTokens(buildOutput(cloned));
        if (tokens <= maxTokens) {
          return { files: cloned, truncated: true, omitted_files: 0 };
        }
      }
      const entries = Object.entries(cloned).sort((a, b) => (b[1].relevance_score || 0) - (a[1].relevance_score || 0));
      const originalCount = entries.length;
      const kept = {};
      for (const [key, val] of entries) {
        kept[key] = val;
        tokens = estimateJsonTokens(buildOutput(kept));
        if (tokens > maxTokens && Object.keys(kept).length > 1) {
          delete kept[key];
          break;
        }
      }
      return {
        files: kept,
        truncated: true,
        omitted_files: originalCount - Object.keys(kept).length
      };
    }
    function computeRiskLevel(file, graph, cycleFiles) {
      const dependentCount = (graph.reverse[file] || []).length;
      if (dependentCount > 10) return "high";
      if (cycleFiles.has(file)) return "caution";
      return "normal";
    }
    function matchFileConventions(file, conventions) {
      if (!conventions) return null;
      const dir = path.dirname(file);
      const ext = path.extname(file);
      let naming = null;
      if (conventions.naming && conventions.naming.by_directory && conventions.naming.by_directory[dir]) {
        const dirConv = conventions.naming.by_directory[dir];
        naming = { pattern: dirConv.dominant_pattern, confidence: dirConv.confidence };
      } else if (conventions.naming && conventions.naming.overall) {
        let best = null;
        let bestConf = 0;
        for (const [, value] of Object.entries(conventions.naming.overall)) {
          if (value.confidence > bestConf) {
            bestConf = value.confidence;
            best = value.pattern;
          }
        }
        if (best) {
          naming = { pattern: best, confidence: bestConf };
        }
      }
      const matchingFrameworks = [];
      if (conventions.frameworks && Array.isArray(conventions.frameworks)) {
        for (const fw of conventions.frameworks) {
          if (fw.evidence && Array.isArray(fw.evidence)) {
            const matches = fw.evidence.some((e) => {
              if (e.endsWith("/")) {
                return file.startsWith(e) || dir.startsWith(e.replace(/\/$/, ""));
              }
              return path.extname(e) === ext || path.dirname(e) === dir;
            });
            if (matches) {
              matchingFrameworks.push({
                framework: fw.framework,
                pattern: fw.pattern,
                confidence: fw.confidence
              });
            }
          }
        }
      }
      if (!naming && matchingFrameworks.length === 0) return null;
      return { naming, frameworks: matchingFrameworks };
    }
    function cmdCodebaseContext(cwd, args, raw) {
      const taskIdx = args.indexOf("--task");
      if (taskIdx !== -1) {
        const taskArg = args[taskIdx + 1];
        if (!taskArg || taskArg.startsWith("--")) {
          error("Usage: codebase context --task <file1,file2,...>");
          return;
        }
        const taskFiles = taskArg.split(",").map((f) => f.trim()).filter(Boolean);
        const planIdx2 = args.indexOf("--plan");
        const planPath2 = planIdx2 !== -1 ? args[planIdx2 + 1] : null;
        const budgetIdx = args.indexOf("--budget");
        const tokenBudget = budgetIdx !== -1 ? parseInt(args[budgetIdx + 1], 10) : 3e3;
        const planFiles2 = getPlanFiles(cwd, planPath2);
        const { buildTaskContext } = require_context();
        const result2 = buildTaskContext(cwd, taskFiles, { planFiles: planFiles2, tokenBudget });
        output({ success: true, ...result2 }, raw);
        return;
      }
      const filesIdx = args.indexOf("--files");
      let filePaths = [];
      if (filesIdx !== -1) {
        for (let i = filesIdx + 1; i < args.length; i++) {
          if (args[i].startsWith("--")) break;
          filePaths.push(args[i]);
        }
      } else {
        filePaths = args.filter((a) => !a.startsWith("--"));
      }
      const planIdx = args.indexOf("--plan");
      const planPath = planIdx !== -1 ? args[planIdx + 1] : null;
      if (!filePaths.length) {
        error("Usage: codebase context --files <file1> [file2] ...");
        return;
      }
      const intel = readIntel(cwd);
      if (!intel) {
        error("No codebase intel. Run: codebase analyze");
        return;
      }
      const { buildDependencyGraph, findCycles } = require_deps();
      const { extractConventions } = require_conventions();
      let graph = intel.dependencies;
      if (!graph) {
        debugLog("codebase.context", "no dependency graph in intel, building...");
        graph = buildDependencyGraph(intel);
        intel.dependencies = graph;
        writeIntel(cwd, intel);
      }
      let conventions = intel.conventions;
      if (!conventions) {
        debugLog("codebase.context", "no conventions in intel, extracting...");
        conventions = extractConventions(intel, { cwd });
        intel.conventions = conventions;
        writeIntel(cwd, intel);
      }
      const cycleData = findCycles(graph);
      const cycleFiles = /* @__PURE__ */ new Set();
      for (const scc of cycleData.cycles) {
        for (const f of scc) cycleFiles.add(f);
      }
      const planFiles = getPlanFiles(cwd, planPath);
      const recentFiles = getRecentlyModifiedFiles(cwd);
      const filesResult = {};
      for (const file of filePaths) {
        if (!graph.forward[file] && !graph.reverse[file]) {
          filesResult[file] = {
            status: "no-data",
            imports: [],
            dependents: [],
            conventions: null,
            risk_level: "normal",
            relevance_score: scoreRelevance(file, filePaths, graph, planFiles, recentFiles)
          };
          continue;
        }
        const imports = [...graph.forward[file] || []];
        imports.sort((a, b) => {
          const scoreA = scoreRelevance(a, filePaths, graph, planFiles, recentFiles);
          const scoreB = scoreRelevance(b, filePaths, graph, planFiles, recentFiles);
          if (scoreB !== scoreA) return scoreB - scoreA;
          return (graph.reverse[b] || []).length - (graph.reverse[a] || []).length;
        });
        const cappedImports = imports.slice(0, 8);
        const dependents = [...graph.reverse[file] || []];
        dependents.sort((a, b) => {
          const scoreA = scoreRelevance(a, filePaths, graph, planFiles, recentFiles);
          const scoreB = scoreRelevance(b, filePaths, graph, planFiles, recentFiles);
          if (scoreB !== scoreA) return scoreB - scoreA;
          return (graph.forward[b] || []).length - (graph.forward[a] || []).length;
        });
        const cappedDependents = dependents.slice(0, 8);
        const riskLevel = computeRiskLevel(file, graph, cycleFiles);
        const fileConventions = matchFileConventions(file, conventions);
        const relevanceScore = scoreRelevance(file, filePaths, graph, planFiles, recentFiles);
        filesResult[file] = {
          imports: cappedImports,
          dependents: cappedDependents,
          conventions: fileConventions,
          risk_level: riskLevel,
          relevance_score: relevanceScore
        };
      }
      const budgetResult = enforceTokenBudget(filesResult);
      const result = {
        success: true,
        files: budgetResult.files,
        file_count: filePaths.length,
        truncated: budgetResult.truncated,
        omitted_files: budgetResult.omitted_files
      };
      if (raw) {
        output(result, raw);
      } else {
        const lines = [];
        lines.push("");
        lines.push("File Context Summary");
        lines.push("\u2550".repeat(80));
        lines.push("");
        for (const [file, ctx] of Object.entries(budgetResult.files)) {
          if (ctx.status === "no-data") {
            lines.push(`  ${file}  [no data]`);
            lines.push("");
            continue;
          }
          const riskBadge = ctx.risk_level === "high" ? "\u{1F534} HIGH" : ctx.risk_level === "caution" ? "\u{1F7E1} CAUTION" : "\u{1F7E2} normal";
          const namingStr = ctx.conventions && ctx.conventions.naming ? `${ctx.conventions.naming.pattern} (${ctx.conventions.naming.confidence}%)` : "-";
          const scoreStr = ctx.relevance_score !== void 0 ? ` | Score: ${ctx.relevance_score.toFixed(2)}` : "";
          lines.push(`  ${file}`);
          lines.push(`    Risk: ${riskBadge}  |  Naming: ${namingStr}${scoreStr}`);
          if (ctx.imports) {
            lines.push(`    Imports (${ctx.imports.length}): ${ctx.imports.length > 0 ? ctx.imports.join(", ") : "none"}`);
          }
          if (ctx.dependents) {
            lines.push(`    Dependents (${ctx.dependents.length}): ${ctx.dependents.length > 0 ? ctx.dependents.join(", ") : "none"}`);
          }
          if (ctx.conventions && ctx.conventions.frameworks && ctx.conventions.frameworks.length > 0) {
            lines.push(`    Frameworks: ${ctx.conventions.frameworks.map((f) => f.framework).join(", ")}`);
          }
          lines.push("");
        }
        if (budgetResult.truncated) {
          lines.push(`  \u26A0 Output truncated to fit 5K token budget (${budgetResult.omitted_files} files omitted)`);
          lines.push("");
        }
        process.stderr.write(lines.join("\n") + "\n");
        output(result, false);
      }
    }
    function formatCodebaseAst(result) {
      const lines = [];
      lines.push(banner("AST Signatures"));
      lines.push("");
      if (result.error) {
        lines.push(box(result.error, "error"));
        return lines.join("\n");
      }
      lines.push("  " + color.dim("File: ") + result.file);
      lines.push("  " + color.dim("Language: ") + (result.language || "unknown"));
      lines.push("  " + color.dim("Signatures: ") + result.count);
      lines.push("");
      if (result.signatures && result.signatures.length > 0) {
        const tableData = result.signatures.map((sig) => ({
          Name: sig.name,
          Type: sig.type + (sig.async ? " async" : "") + (sig.generator ? " gen" : ""),
          Params: sig.params.join(", ") || "-",
          Line: String(sig.line)
        }));
        lines.push(formatTable(tableData, ["Name", "Type", "Params", "Line"]));
      } else {
        lines.push("  No signatures found.");
      }
      lines.push("");
      lines.push(summaryLine(result.count + " signatures"));
      return lines.join("\n");
    }
    function cmdCodebaseAst(cwd, args, raw) {
      const filePath = args.filter((a) => !a.startsWith("-"))[0];
      if (!filePath) {
        error("Usage: codebase ast <file>");
        return;
      }
      const { extractSignatures } = require_ast();
      const resolved = path.resolve(cwd, filePath);
      const result = extractSignatures(resolved);
      output({
        file: filePath,
        language: result.language,
        signatures: result.signatures,
        count: result.signatures.length,
        error: result.error || void 0
      }, { formatter: formatCodebaseAst });
    }
    function formatCodebaseExports(result) {
      const lines = [];
      lines.push(banner("Export Surface"));
      lines.push("");
      if (result.error) {
        lines.push(box(result.error, "error"));
        return lines.join("\n");
      }
      lines.push("  " + color.dim("File: ") + result.file);
      lines.push("  " + color.dim("Module type: ") + (result.type || "unknown"));
      lines.push("");
      if (result.named && result.named.length > 0) {
        lines.push(sectionHeader("Named Exports"));
        for (const name of result.named) {
          lines.push("  " + SYMBOLS.bullet + " " + name);
        }
        lines.push("");
      }
      if (result.default) {
        lines.push(sectionHeader("Default Export"));
        lines.push("  " + result.default);
        lines.push("");
      }
      if (result.re_exports && result.re_exports.length > 0) {
        lines.push(sectionHeader("Re-exports"));
        for (const name of result.re_exports) {
          lines.push("  " + SYMBOLS.arrow + " " + name);
        }
        lines.push("");
      }
      if (result.cjs_exports && result.cjs_exports.length > 0) {
        lines.push(sectionHeader("CJS Exports"));
        for (const name of result.cjs_exports) {
          lines.push("  " + SYMBOLS.bullet + " " + name);
        }
        lines.push("");
      }
      const totalExports = (result.named || []).length + (result.default ? 1 : 0) + (result.re_exports || []).length + (result.cjs_exports || []).length;
      lines.push(summaryLine(totalExports + " exports (" + (result.type || "unknown") + ")"));
      return lines.join("\n");
    }
    function cmdCodebaseExports(cwd, args, raw) {
      const filePath = args.filter((a) => !a.startsWith("-"))[0];
      if (!filePath) {
        error("Usage: codebase exports <file>");
        return;
      }
      const { extractExports } = require_ast();
      const resolved = path.resolve(cwd, filePath);
      const result = extractExports(resolved);
      output({
        file: filePath,
        type: result.type,
        named: result.named,
        default: result.default,
        re_exports: result.reExports,
        cjs_exports: result.cjsExports,
        error: result.error || void 0
      }, { formatter: formatCodebaseExports });
    }
    function formatCodebaseComplexity(result) {
      const lines = [];
      lines.push(banner("Complexity Analysis"));
      lines.push("");
      if (result.error) {
        lines.push(box(result.error, "error"));
        return lines.join("\n");
      }
      lines.push("  " + color.dim("File: ") + result.file);
      lines.push("  " + color.dim("Module complexity: ") + result.module_complexity);
      lines.push("");
      if (result.functions && result.functions.length > 0) {
        const tableData = result.functions.map((fn) => {
          const complexityStr = String(fn.complexity);
          let coloredComplexity;
          if (fn.complexity <= 5) coloredComplexity = color.green(complexityStr);
          else if (fn.complexity <= 10) coloredComplexity = color.yellow(complexityStr);
          else coloredComplexity = color.red(complexityStr);
          return {
            Name: fn.name,
            Complexity: coloredComplexity,
            "Max Nesting": String(fn.nesting_max),
            Line: String(fn.line)
          };
        });
        lines.push(formatTable(tableData, ["Name", "Complexity", "Max Nesting", "Line"]));
      } else {
        lines.push("  No functions found.");
      }
      lines.push("");
      lines.push(summaryLine(result.functions.length + " functions, module complexity " + result.module_complexity));
      return lines.join("\n");
    }
    function cmdCodebaseComplexity(cwd, args, raw) {
      const filePath = args.filter((a) => !a.startsWith("-"))[0];
      if (!filePath) {
        error("Usage: codebase complexity <file>");
        return;
      }
      const { computeComplexity } = require_ast();
      const resolved = path.resolve(cwd, filePath);
      const result = computeComplexity(resolved);
      output({
        file: filePath,
        module_complexity: result.module_complexity,
        functions: result.functions,
        error: result.error || void 0
      }, { formatter: formatCodebaseComplexity });
    }
    function cmdCodebaseRepoMap(cwd, args, raw) {
      const budgetIdx = args.indexOf("--budget");
      const tokenBudget = budgetIdx !== -1 ? parseInt(args[budgetIdx + 1], 10) : 1e3;
      const { generateRepoMap } = require_ast();
      const result = generateRepoMap(cwd, { tokenBudget });
      output({
        summary: result.summary,
        files_included: result.files_included,
        total_signatures: result.total_signatures,
        token_estimate: result.token_estimate
      }, raw, result.summary + "\n");
    }
    module2.exports = {
      cmdCodebaseAnalyze,
      cmdCodebaseStatus,
      cmdCodebaseConventions,
      cmdCodebaseRules,
      cmdCodebaseDeps,
      cmdCodebaseImpact,
      cmdCodebaseLifecycle,
      cmdCodebaseContext,
      cmdCodebaseAst,
      cmdCodebaseExports,
      cmdCodebaseComplexity,
      cmdCodebaseRepoMap,
      readCodebaseIntel,
      checkCodebaseIntelStaleness,
      autoTriggerCodebaseIntel,
      spawnBackgroundAnalysis,
      // Exported for testing (Plan 02)
      scoreRelevance,
      getRecentlyModifiedFiles,
      getPlanFiles,
      enforceTokenBudget,
      computeRiskLevel,
      matchFileConventions
    };
  }
});

// src/commands/worktree.js
var require_worktree = __commonJS({
  "src/commands/worktree.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var os = require("os");
    var { execSync, execFileSync } = require("child_process");
    var { output, error, debugLog } = require_output();
    var { execGit } = require_git();
    var { loadConfig } = require_config();
    var { extractFrontmatter } = require_frontmatter();
    var WORKTREE_DEFAULTS = {
      enabled: false,
      base_path: "/tmp/gsd-worktrees",
      sync_files: [".env", ".env.local", ".planning/config.json"],
      setup_hooks: [],
      max_concurrent: 3
    };
    function getWorktreeConfig(cwd) {
      const defaults = { ...WORKTREE_DEFAULTS };
      try {
        const configPath = path.join(cwd, ".planning", "config.json");
        const raw = JSON.parse(fs.readFileSync(configPath, "utf-8"));
        if (raw.worktree && typeof raw.worktree === "object") {
          return { ...defaults, ...raw.worktree };
        }
      } catch {
        debugLog("worktree.config", "No worktree config found, using defaults");
      }
      return defaults;
    }
    function getProjectName(cwd) {
      return path.basename(cwd);
    }
    function parsePlanId(planId) {
      if (!planId) return null;
      const match = planId.match(/^(\d+(?:\.\d+)?)-(\d+)$/);
      if (!match) return null;
      return { phase: match[1], plan: match[2] };
    }
    function getWaveFromPlan(cwd, planId) {
      const parsed = parsePlanId(planId);
      if (!parsed) return "0";
      const phasesDir = path.join(cwd, ".planning", "phases");
      try {
        const entries = fs.readdirSync(phasesDir, { withFileTypes: true });
        const phaseDir = entries.find((e) => e.isDirectory() && e.name.startsWith(parsed.phase.padStart(2, "0")));
        if (!phaseDir) return "0";
        const planFile = path.join(phasesDir, phaseDir.name, `${parsed.phase.padStart(2, "0")}-${parsed.plan.padStart(2, "0")}-PLAN.md`);
        if (!fs.existsSync(planFile)) return "0";
        const content = fs.readFileSync(planFile, "utf-8");
        const waveMatch = content.match(/^wave:\s*(\d+)/m);
        return waveMatch ? waveMatch[1] : "0";
      } catch {
        return "0";
      }
    }
    function parseWorktreeListPorcelain(porcelainOutput) {
      if (!porcelainOutput || !porcelainOutput.trim()) return [];
      const worktrees = [];
      const blocks = porcelainOutput.split("\n\n");
      for (const block of blocks) {
        if (!block.trim()) continue;
        const lines = block.trim().split("\n");
        const wt = {};
        for (const line of lines) {
          if (line.startsWith("worktree ")) {
            wt.path = line.slice("worktree ".length);
          } else if (line.startsWith("HEAD ")) {
            wt.head = line.slice("HEAD ".length);
          } else if (line.startsWith("branch ")) {
            wt.branch = line.slice("branch ".length).replace("refs/heads/", "");
          } else if (line === "bare") {
            wt.bare = true;
          } else if (line === "detached") {
            wt.detached = true;
          }
        }
        if (wt.path) worktrees.push(wt);
      }
      return worktrees;
    }
    function getDiskUsage(dirPath) {
      try {
        const result = execFileSync("du", ["-sh", dirPath], {
          encoding: "utf-8",
          timeout: 5e3,
          stdio: "pipe"
        }).trim();
        const match = result.match(/^([\d.]+[BKMGT]?)\s/);
        return match ? match[1] : "unknown";
      } catch {
        return "unknown";
      }
    }
    function getAvailableDiskMB(dirPath) {
      try {
        const result = execFileSync("df", ["-k", dirPath], {
          encoding: "utf-8",
          timeout: 5e3,
          stdio: "pipe"
        }).trim();
        const lines = result.split("\n");
        const lastLine = lines[lines.length - 1];
        const parts = lastLine.split(/\s+/);
        const availKB = parseInt(parts[3], 10);
        return isNaN(availKB) ? null : Math.round(availKB / 1024);
      } catch {
        return null;
      }
    }
    function getProjectSizeMB(cwd) {
      try {
        const result = execFileSync("du", ["-sm", cwd], {
          encoding: "utf-8",
          timeout: 1e4,
          stdio: "pipe"
        }).trim();
        const match = result.match(/^(\d+)/);
        return match ? parseInt(match[1], 10) : null;
      } catch {
        return null;
      }
    }
    function cmdWorktreeCreate(cwd, planId, raw) {
      if (!planId) {
        error("Usage: gsd-tools worktree create <plan-id>\n\nplan-id format: NN-MM (e.g., 21-02)");
      }
      const parsed = parsePlanId(planId);
      if (!parsed) {
        error(`Invalid plan ID "${planId}". Expected format: NN-MM (e.g., 21-02)`);
      }
      const config = getWorktreeConfig(cwd);
      const projectName = getProjectName(cwd);
      const wave = getWaveFromPlan(cwd, planId);
      const branchName = `worktree-${parsed.phase.padStart(2, "0")}-${parsed.plan.padStart(2, "0")}-${wave}`;
      const worktreePath = path.join(config.base_path, projectName, planId);
      const listResult = execGit(cwd, ["worktree", "list", "--porcelain"]);
      if (listResult.exitCode === 0) {
        const existing = parseWorktreeListPorcelain(listResult.stdout);
        const alreadyExists = existing.some((wt) => wt.path === worktreePath || wt.branch === branchName);
        if (alreadyExists) {
          error(`Worktree already exists for plan ${planId} (path: ${worktreePath}, branch: ${branchName})`);
        }
        const projectWorktrees = existing.filter(
          (wt) => wt.path && wt.path.startsWith(path.join(config.base_path, projectName))
        );
        if (projectWorktrees.length >= config.max_concurrent) {
          error(`Max concurrent worktrees (${config.max_concurrent}) reached. Remove a worktree first or increase max_concurrent in config.`);
        }
      }
      const freeMemMB = Math.round(os.freemem() / (1024 * 1024));
      const requiredMemMB = config.max_concurrent * 4096;
      const resourceWarnings = [];
      if (freeMemMB < requiredMemMB) {
        resourceWarnings.push(`Low memory: ${freeMemMB}MB free, estimated need ${requiredMemMB}MB for ${config.max_concurrent} concurrent worktrees`);
      }
      const projectSizeMB = getProjectSizeMB(cwd);
      if (projectSizeMB) {
        const neededMB = Math.round(projectSizeMB * 1.5);
        const basePathParent = path.dirname(config.base_path);
        const availMB = getAvailableDiskMB(fs.existsSync(config.base_path) ? config.base_path : basePathParent);
        if (availMB !== null && availMB < neededMB) {
          resourceWarnings.push(`Low disk: ${availMB}MB available at ${config.base_path}, estimated need ${neededMB}MB`);
        }
      }
      const projectWorktreeDir = path.join(config.base_path, projectName);
      try {
        fs.mkdirSync(projectWorktreeDir, { recursive: true });
      } catch (e) {
        error(`Failed to create worktree base directory: ${projectWorktreeDir}: ${e.message}`);
      }
      const createResult = execGit(cwd, ["worktree", "add", "-b", branchName, worktreePath]);
      if (createResult.exitCode !== 0) {
        error(`Failed to create worktree: ${createResult.stderr}`);
      }
      const syncedFiles = [];
      for (const syncFile of config.sync_files) {
        const srcPath = path.join(cwd, syncFile);
        const destPath = path.join(worktreePath, syncFile);
        try {
          if (fs.existsSync(srcPath)) {
            fs.mkdirSync(path.dirname(destPath), { recursive: true });
            fs.copyFileSync(srcPath, destPath);
            syncedFiles.push(syncFile);
          }
        } catch (e) {
          debugLog("worktree.sync", `Failed to sync ${syncFile}: ${e.message}`);
        }
      }
      let setupStatus = "ok";
      let setupError = null;
      for (const hook of config.setup_hooks) {
        try {
          execSync(hook, {
            cwd: worktreePath,
            timeout: 12e4,
            stdio: "pipe",
            encoding: "utf-8"
          });
        } catch (e) {
          setupStatus = "failed";
          setupError = `Hook "${hook}" failed: ${e.message}`;
          debugLog("worktree.setup", `Setup hook failed: ${hook}: ${e.message}`);
          break;
        }
      }
      const result = {
        created: true,
        plan_id: planId,
        branch: branchName,
        path: worktreePath,
        synced_files: syncedFiles,
        setup_status: setupStatus
      };
      if (setupError) result.setup_error = setupError;
      if (resourceWarnings.length > 0) result.resource_warnings = resourceWarnings;
      output(result, raw);
    }
    function cmdWorktreeList(cwd, raw) {
      const config = getWorktreeConfig(cwd);
      const projectName = getProjectName(cwd);
      const projectBase = path.join(config.base_path, projectName);
      const listResult = execGit(cwd, ["worktree", "list", "--porcelain"]);
      if (listResult.exitCode !== 0) {
        error(`Failed to list worktrees: ${listResult.stderr}`);
      }
      const allWorktrees = parseWorktreeListPorcelain(listResult.stdout);
      const projectWorktrees = allWorktrees.filter(
        (wt) => wt.path && wt.path.startsWith(projectBase + "/")
      );
      const worktrees = projectWorktrees.map((wt) => {
        const planId = path.basename(wt.path);
        const diskUsage = fs.existsSync(wt.path) ? getDiskUsage(wt.path) : "removed";
        return {
          plan_id: planId,
          branch: wt.branch || null,
          path: wt.path,
          head: wt.head ? wt.head.slice(0, 8) : null,
          disk_usage: diskUsage
        };
      });
      const result = { worktrees };
      if (worktrees.length === 0) {
        output(result, raw, "No active worktrees for this project.\n");
      } else {
        const lines = [
          "Plan ID   | Branch                     | Path                                    | Disk Usage",
          "--------- | -------------------------- | --------------------------------------- | ----------"
        ];
        for (const wt of worktrees) {
          lines.push(`${(wt.plan_id || "").padEnd(9)} | ${(wt.branch || "").padEnd(26)} | ${(wt.path || "").padEnd(39)} | ${wt.disk_usage}`);
        }
        output(result, raw, lines.join("\n") + "\n");
      }
    }
    function cmdWorktreeRemove(cwd, planId, raw) {
      if (!planId) {
        error("Usage: gsd-tools worktree remove <plan-id>");
      }
      const config = getWorktreeConfig(cwd);
      const projectName = getProjectName(cwd);
      const worktreePath = path.join(config.base_path, projectName, planId);
      const listResult = execGit(cwd, ["worktree", "list", "--porcelain"]);
      if (listResult.exitCode !== 0) {
        error(`Failed to list worktrees: ${listResult.stderr}`);
      }
      const allWorktrees = parseWorktreeListPorcelain(listResult.stdout);
      const targetWt = allWorktrees.find((wt) => wt.path === worktreePath);
      if (!targetWt) {
        error(`No worktree found for plan ${planId} at ${worktreePath}`);
      }
      const branchName = targetWt.branch;
      const removeResult = execGit(cwd, ["worktree", "remove", worktreePath, "--force"]);
      if (removeResult.exitCode !== 0) {
        error(`Failed to remove worktree: ${removeResult.stderr}`);
      }
      if (branchName) {
        const branchResult = execGit(cwd, ["branch", "-D", branchName]);
        if (branchResult.exitCode !== 0) {
          debugLog("worktree.remove", `Failed to delete branch ${branchName}: ${branchResult.stderr}`);
        }
      }
      output({ removed: true, plan_id: planId, path: worktreePath }, raw);
    }
    function cmdWorktreeCleanup(cwd, raw) {
      const config = getWorktreeConfig(cwd);
      const projectName = getProjectName(cwd);
      const projectBase = path.join(config.base_path, projectName);
      const listResult = execGit(cwd, ["worktree", "list", "--porcelain"]);
      if (listResult.exitCode !== 0) {
        error(`Failed to list worktrees: ${listResult.stderr}`);
      }
      const allWorktrees = parseWorktreeListPorcelain(listResult.stdout);
      const projectWorktrees = allWorktrees.filter(
        (wt) => wt.path && wt.path.startsWith(projectBase + "/")
      );
      const removed = [];
      for (const wt of projectWorktrees) {
        const planId = path.basename(wt.path);
        const branchName = wt.branch;
        const removeResult = execGit(cwd, ["worktree", "remove", wt.path, "--force"]);
        if (removeResult.exitCode === 0) {
          removed.push({ plan_id: planId, path: wt.path });
        } else {
          debugLog("worktree.cleanup", `Failed to remove ${wt.path}: ${removeResult.stderr}`);
        }
        if (branchName) {
          execGit(cwd, ["branch", "-D", branchName]);
        }
      }
      execGit(cwd, ["worktree", "prune"]);
      try {
        if (fs.existsSync(projectBase)) {
          const remaining = fs.readdirSync(projectBase);
          if (remaining.length === 0) {
            fs.rmdirSync(projectBase);
          }
        }
      } catch {
        debugLog("worktree.cleanup", "Failed to remove empty project directory");
      }
      output({ cleaned: removed.length, worktrees: removed }, raw);
    }
    var AUTO_RESOLVE_PATTERNS = [
      "package-lock.json",
      "pnpm-lock.yaml",
      "yarn.lock",
      "go.sum",
      ".planning/baselines/"
    ];
    function isAutoResolvable(filePath) {
      return AUTO_RESOLVE_PATTERNS.some((pattern) => {
        if (pattern.endsWith("/")) {
          return filePath.startsWith(pattern);
        }
        return filePath === pattern || filePath.endsWith("/" + pattern);
      });
    }
    function parseMergeTreeConflicts(output2) {
      const conflicts = [];
      const lines = output2.split("\n");
      for (const line of lines) {
        const match = line.match(/^CONFLICT\s+\(([^)]+)\):\s+.*?(?:in\s+)?(\S+)\s*$/);
        if (match) {
          conflicts.push({ file: match[2], type: match[1] });
        } else {
          const altMatch = line.match(/^CONFLICT\s+\(([^)]+)\):\s+Merge conflict in\s+(.+)$/);
          if (altMatch) {
            conflicts.push({ file: altMatch[2].trim(), type: altMatch[1] });
          }
        }
      }
      return conflicts;
    }
    function getPhaseFilesModified(cwd, phaseNumber) {
      const phasesDir = path.join(cwd, ".planning", "phases");
      const paddedPhase = String(phaseNumber).padStart(2, "0");
      const results = [];
      try {
        const entries = fs.readdirSync(phasesDir, { withFileTypes: true });
        const phaseDir = entries.find((e) => e.isDirectory() && e.name.startsWith(paddedPhase + "-"));
        if (!phaseDir) return results;
        const phasePath = path.join(phasesDir, phaseDir.name);
        const planFiles = fs.readdirSync(phasePath).filter((f) => f.match(/^\d+-\d+-PLAN\.md$/));
        for (const planFile of planFiles) {
          const content = fs.readFileSync(path.join(phasePath, planFile), "utf-8");
          const fm = extractFrontmatter(content);
          const idMatch = planFile.match(/^(\d+-\d+)-PLAN\.md$/);
          if (!idMatch) continue;
          const planId = idMatch[1];
          const wave = fm.wave || "0";
          const filesModified = fm.files_modified || [];
          results.push({ planId, wave: String(wave), files_modified: filesModified });
        }
      } catch (e) {
        debugLog("worktree.overlap", `Error reading phase plans: ${e.message}`);
      }
      return results;
    }
    function cmdWorktreeMerge(cwd, planId, raw) {
      if (!planId) {
        error("Usage: gsd-tools worktree merge <plan-id>");
      }
      const parsed = parsePlanId(planId);
      if (!parsed) {
        error(`Invalid plan ID "${planId}". Expected format: NN-MM (e.g., 21-02)`);
      }
      const config = getWorktreeConfig(cwd);
      const projectName = getProjectName(cwd);
      const listResult = execGit(cwd, ["worktree", "list", "--porcelain"]);
      if (listResult.exitCode !== 0) {
        error(`Failed to list worktrees: ${listResult.stderr}`);
      }
      const allWorktrees = parseWorktreeListPorcelain(listResult.stdout);
      const projectBase = path.join(config.base_path, projectName);
      const worktreePath = path.join(projectBase, planId);
      const targetWt = allWorktrees.find(
        (wt) => wt.path === worktreePath || wt.branch && wt.branch.match(new RegExp(`^worktree-${parsed.phase.padStart(2, "0")}-${parsed.plan.padStart(2, "0")}-`))
      );
      if (!targetWt) {
        error(`No worktree found for plan ${planId}. Check with 'worktree list'.`);
      }
      const worktreeBranch = targetWt.branch;
      if (!worktreeBranch) {
        error(`Worktree for plan ${planId} has no branch (detached HEAD?)`);
      }
      const baseBranchResult = execGit(cwd, ["rev-parse", "--abbrev-ref", "HEAD"]);
      if (baseBranchResult.exitCode !== 0) {
        error(`Failed to determine base branch: ${baseBranchResult.stderr}`);
      }
      const baseBranch = baseBranchResult.stdout.trim();
      const fileOverlapWarnings = [];
      const phasePlans = getPhaseFilesModified(cwd, parsed.phase);
      const thisPlan = phasePlans.find((p) => p.planId === planId);
      if (thisPlan && thisPlan.files_modified.length > 0) {
        for (const other of phasePlans) {
          if (other.planId === planId) continue;
          const overlap = thisPlan.files_modified.filter((f) => other.files_modified.includes(f));
          if (overlap.length > 0) {
            fileOverlapWarnings.push({
              plan: other.planId,
              wave: other.wave,
              shared_files: overlap
            });
          }
        }
      }
      const mergeTreeResult = execGit(cwd, ["merge-tree", "--write-tree", baseBranch, worktreeBranch]);
      if (mergeTreeResult.exitCode > 1) {
        error(`git merge-tree failed: ${mergeTreeResult.stderr || mergeTreeResult.stdout}`);
      }
      let conflicts = [];
      let treeSha = null;
      if (mergeTreeResult.exitCode === 0) {
        treeSha = mergeTreeResult.stdout.split("\n")[0].trim();
      } else {
        const fullOutput = (mergeTreeResult.stdout + "\n" + mergeTreeResult.stderr).trim();
        conflicts = parseMergeTreeConflicts(fullOutput);
        if (conflicts.length === 0) {
          const firstLine = mergeTreeResult.stdout.split("\n")[0].trim();
          if (/^[0-9a-f]{40}$/.test(firstLine)) {
            treeSha = firstLine;
          }
        }
      }
      const autoResolvable = conflicts.filter((c) => isAutoResolvable(c.file));
      const realConflicts = conflicts.filter((c) => !isAutoResolvable(c.file));
      if (realConflicts.length > 0) {
        output({
          merged: false,
          plan_id: planId,
          branch: worktreeBranch,
          base_branch: baseBranch,
          conflicts: realConflicts.map((c) => ({ file: c.file, type: c.type })),
          auto_resolved: autoResolvable.map((c) => ({ file: c.file, type: c.type })),
          file_overlap_warnings: fileOverlapWarnings
        }, raw);
        return;
      }
      const mergeResult = execGit(cwd, ["merge", worktreeBranch, "--no-ff", "-m", `merge: plan ${planId} worktree`]);
      if (mergeResult.exitCode !== 0 && autoResolvable.length > 0) {
        let resolved = true;
        for (const c of autoResolvable) {
          const checkoutResult = execGit(cwd, ["checkout", "--theirs", c.file]);
          if (checkoutResult.exitCode !== 0) {
            resolved = false;
            break;
          }
          execGit(cwd, ["add", c.file]);
        }
        if (resolved) {
          const commitResult = execGit(cwd, ["commit", "--no-edit"]);
          if (commitResult.exitCode !== 0) {
            execGit(cwd, ["merge", "--abort"]);
            error(`Merge auto-resolution failed during commit: ${commitResult.stderr}`);
          }
        } else {
          execGit(cwd, ["merge", "--abort"]);
          error(`Merge auto-resolution failed: could not checkout --theirs for lockfiles`);
        }
      } else if (mergeResult.exitCode !== 0) {
        error(`Merge execution failed: ${mergeResult.stderr}`);
      }
      output({
        merged: true,
        plan_id: planId,
        branch: worktreeBranch,
        base_branch: baseBranch,
        tree_sha: treeSha,
        auto_resolved: autoResolvable.map((c) => ({ file: c.file, type: c.type })),
        file_overlap_warnings: fileOverlapWarnings
      }, raw);
    }
    function cmdWorktreeCheckOverlap(cwd, phaseNumber, raw) {
      if (!phaseNumber) {
        error("Usage: gsd-tools worktree check-overlap <phase-number>");
      }
      const phasePlans = getPhaseFilesModified(cwd, phaseNumber);
      const overlaps = [];
      const checked = /* @__PURE__ */ new Set();
      for (let i = 0; i < phasePlans.length; i++) {
        for (let j = i + 1; j < phasePlans.length; j++) {
          const a = phasePlans[i];
          const b = phasePlans[j];
          if (a.wave !== b.wave) continue;
          const pairKey = `${a.planId}:${b.planId}`;
          if (checked.has(pairKey)) continue;
          checked.add(pairKey);
          const sharedFiles = a.files_modified.filter((f) => b.files_modified.includes(f));
          if (sharedFiles.length > 0) {
            overlaps.push({
              plans: [a.planId, b.planId],
              files: sharedFiles,
              wave: a.wave
            });
          }
        }
      }
      output({
        phase: phaseNumber,
        plans_analyzed: phasePlans.length,
        overlaps,
        has_conflicts: overlaps.length > 0
      }, raw);
    }
    module2.exports = {
      cmdWorktreeCreate,
      cmdWorktreeList,
      cmdWorktreeRemove,
      cmdWorktreeCleanup,
      cmdWorktreeMerge,
      cmdWorktreeCheckOverlap,
      // Exported for testing
      getWorktreeConfig,
      parsePlanId,
      parseWorktreeListPorcelain,
      getPhaseFilesModified,
      parseMergeTreeConflicts,
      isAutoResolvable,
      WORKTREE_DEFAULTS
    };
  }
});

// src/lib/orchestration.js
var require_orchestration = __commonJS({
  "src/lib/orchestration.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var { debugLog, output, error } = require_output();
    var { extractFrontmatter } = require_frontmatter();
    var { banner, sectionHeader, formatTable, summaryLine, color, SYMBOLS } = require_format();
    function parseTasksFromPlan(content) {
      if (!content || typeof content !== "string") return [];
      const tasks = [];
      const taskBlockRe = /<task\s+type="([^"]*)"[^>]*>([\s\S]*?)<\/task>/g;
      let match;
      while ((match = taskBlockRe.exec(content)) !== null) {
        const type = match[1] || "auto";
        const body = match[2];
        const task = {
          name: extractElement(body, "name") || "Unnamed Task",
          type,
          files: parseFilesList(extractElement(body, "files")),
          action: extractElement(body, "action") || "",
          verify: extractElement(body, "verify") || "",
          done: extractElement(body, "done") || ""
        };
        tasks.push(task);
      }
      return tasks;
    }
    function extractElement(body, tagName) {
      const re = new RegExp(`<${tagName}>([\\s\\S]*?)<\\/${tagName}>`, "i");
      const m = body.match(re);
      return m ? m[1].trim() : null;
    }
    function parseFilesList(filesStr) {
      if (!filesStr) return [];
      return filesStr.split(",").map((f) => f.trim()).filter(Boolean);
    }
    var COMPLEXITY_LABELS = {
      1: "trivial",
      2: "simple",
      3: "moderate",
      4: "complex",
      5: "very_complex"
    };
    var MODEL_MAP = {
      1: "sonnet",
      2: "sonnet",
      3: "sonnet",
      4: "opus",
      5: "opus"
    };
    function classifyTaskComplexity(task, context) {
      try {
        let score = 1;
        const factors = [];
        const files = task.files || [];
        const action = task.action || "";
        const verify = task.verify || "";
        const type = task.type || "auto";
        if (files.length >= 6) {
          score += 2;
          factors.push(`${files.length} files (high)`);
        } else if (files.length >= 3) {
          score += 1;
          factors.push(`${files.length} files`);
        }
        if (context && context.depGraph && context.depGraph.reverse) {
          let totalImporters = 0;
          for (const file of files) {
            for (const [key, importers] of Object.entries(context.depGraph.reverse)) {
              if (key === file || key.endsWith("/" + file) || file.endsWith("/" + key)) {
                totalImporters += importers.length;
              }
            }
          }
          if (totalImporters >= 6) {
            score += 2;
            factors.push(`high blast radius (${totalImporters} importers)`);
          } else if (totalImporters >= 3) {
            score += 1;
            factors.push(`moderate blast radius (${totalImporters} importers)`);
          }
        }
        const testKeywords = /\btest\b|npm\s+test|pytest|jest|mocha|vitest|go\s+test|mix\s+test/i;
        if (testKeywords.test(action) || testKeywords.test(verify)) {
          score += 1;
          factors.push("has tests");
        }
        if (type === "checkpoint:decision" || type === "checkpoint:human-verify") {
          score += 1;
          factors.push(`checkpoint (${type})`);
        }
        if (action.length > 800) {
          score += 1;
          factors.push("complex action (>800 chars)");
        }
        score = Math.max(1, Math.min(5, score));
        return {
          score,
          label: COMPLEXITY_LABELS[score],
          factors,
          recommended_model: MODEL_MAP[score],
          recommended_agent: "gsd-executor"
        };
      } catch (e) {
        debugLog("orchestration.classifyTask", "classification failed", e);
        return {
          score: 3,
          label: "moderate",
          factors: ["classification error \u2014 defaulting"],
          recommended_model: "sonnet",
          recommended_agent: "gsd-executor"
        };
      }
    }
    function classifyPlan(planPath, cwd) {
      try {
        const absPath = path.isAbsolute(planPath) ? planPath : path.resolve(cwd, planPath);
        const content = fs.readFileSync(absPath, "utf-8");
        const frontmatter = extractFrontmatter(content);
        const tasks = parseTasksFromPlan(content);
        let depGraph = null;
        try {
          const { readIntel } = require_codebase_intel();
          const { buildDependencyGraph } = require_deps();
          const intel = readIntel(cwd);
          if (intel) {
            depGraph = buildDependencyGraph(intel);
          }
        } catch (e) {
          debugLog("orchestration.classifyPlan", "dep graph unavailable (non-blocking)", e);
        }
        const context = { cwd, depGraph };
        const classifiedTasks = tasks.map((task) => ({
          name: task.name,
          type: task.type,
          files: task.files,
          complexity: classifyTaskComplexity(task, context)
        }));
        const planComplexity = classifiedTasks.length > 0 ? Math.max(...classifiedTasks.map((t) => t.complexity.score)) : 1;
        const highestModel = classifiedTasks.reduce((best, t) => {
          const modelPriority = { haiku: 0, sonnet: 1, opus: 2 };
          const current = modelPriority[t.complexity.recommended_model] || 0;
          const bestPriority = modelPriority[best] || 0;
          return current > bestPriority ? t.complexity.recommended_model : best;
        }, "sonnet");
        return {
          plan: path.basename(absPath),
          wave: parseInt(frontmatter.wave, 10) || 1,
          autonomous: frontmatter.autonomous === "true" || frontmatter.autonomous === true,
          task_count: classifiedTasks.length,
          tasks: classifiedTasks,
          plan_complexity: planComplexity,
          recommended_model: highestModel
        };
      } catch (e) {
        debugLog("orchestration.classifyPlan", "plan classification failed", e);
        return null;
      }
    }
    function selectExecutionMode(planClassifications) {
      try {
        if (!planClassifications || planClassifications.length === 0) {
          return {
            mode: "single",
            reason: "no plans to execute",
            waves: {},
            total_plans: 0,
            total_waves: 0,
            has_checkpoints: false
          };
        }
        const totalPlans = planClassifications.length;
        const waves = {};
        for (const plan of planClassifications) {
          const wave = plan.wave || 1;
          if (!waves[wave]) waves[wave] = [];
          waves[wave].push(plan.plan);
        }
        const totalWaves = Object.keys(waves).length;
        const hasCheckpoints = planClassifications.some(
          (plan) => plan.tasks && plan.tasks.some(
            (t) => t.type && t.type.startsWith("checkpoint:")
          )
        );
        if (hasCheckpoints) {
          return {
            mode: "sequential",
            reason: "plan has checkpoint tasks requiring human interaction",
            waves,
            total_plans: totalPlans,
            total_waves: totalWaves,
            has_checkpoints: true
          };
        }
        if (totalPlans === 1) {
          const taskCount = planClassifications[0].task_count || 0;
          if (taskCount <= 2) {
            return {
              mode: "single",
              reason: `1 plan with ${taskCount} task${taskCount !== 1 ? "s" : ""}`,
              waves,
              total_plans: 1,
              total_waves: totalWaves,
              has_checkpoints: false
            };
          }
        }
        for (const [wave, plans] of Object.entries(waves)) {
          if (plans.length > 1) {
            return {
              mode: "parallel",
              reason: `${plans.length} independent plans in wave ${wave}`,
              waves,
              total_plans: totalPlans,
              total_waves: totalWaves,
              has_checkpoints: false
            };
          }
        }
        if (totalWaves >= 3) {
          return {
            mode: "pipeline",
            reason: `${totalWaves} waves requiring sequential execution`,
            waves,
            total_plans: totalPlans,
            total_waves: totalWaves,
            has_checkpoints: false
          };
        }
        return {
          mode: "sequential",
          reason: `${totalPlans} plans across ${totalWaves} wave${totalWaves !== 1 ? "s" : ""}`,
          waves,
          total_plans: totalPlans,
          total_waves: totalWaves,
          has_checkpoints: false
        };
      } catch (e) {
        debugLog("orchestration.selectMode", "mode selection failed", e);
        return {
          mode: "sequential",
          reason: "mode selection error \u2014 defaulting to sequential",
          waves: {},
          total_plans: 0,
          total_waves: 0,
          has_checkpoints: false
        };
      }
    }
    function routeTask(complexity, config) {
      try {
        const score = complexity?.score || 3;
        const baseModel = MODEL_MAP[score] || "sonnet";
        if (config && config.model_profile) {
          const { MODEL_PROFILES } = require_constants();
          const agentModels = MODEL_PROFILES["gsd-executor"];
          if (agentModels && agentModels[config.model_profile]) {
            const profileModel = agentModels[config.model_profile];
            const priority = { haiku: 0, sonnet: 1, opus: 2, inherit: 2 };
            const profilePriority = priority[profileModel] || 1;
            const basePriority = priority[baseModel] || 1;
            const resolvedModel = profilePriority >= basePriority ? profileModel : baseModel;
            return {
              model: resolvedModel === "opus" ? "inherit" : resolvedModel,
              agent: "gsd-executor",
              reason: `score ${score} (${complexity.label}) via ${config.model_profile} profile`
            };
          }
        }
        return {
          model: baseModel === "opus" ? "inherit" : baseModel,
          agent: "gsd-executor",
          reason: `score ${score} (${complexity.label})`
        };
      } catch (e) {
        debugLog("orchestration.routeTask", "routing failed", e);
        return {
          model: "sonnet",
          agent: "gsd-executor",
          reason: "routing error \u2014 defaulting to sonnet"
        };
      }
    }
    function cmdClassifyPlan(cwd, args, raw) {
      const planPath = args[0];
      if (!planPath) {
        error("Usage: classify plan <plan-path>");
      }
      const classification = classifyPlan(planPath, cwd);
      if (!classification) {
        error("Failed to classify plan: " + planPath);
      }
      output(classification, {
        formatter: (result) => {
          const lines = [];
          lines.push(banner("Classify Plan"));
          lines.push("");
          lines.push(sectionHeader(`Plan: ${result.plan}`));
          lines.push(` Wave: ${result.wave}  |  Autonomous: ${result.autonomous}  |  Plan Complexity: ${result.plan_complexity}/5`);
          lines.push(` Recommended Model: ${color.bold(result.recommended_model)}`);
          lines.push("");
          const headers = ["Task", "Score", "Label", "Model", "Factors"];
          const rows = result.tasks.map((t) => [
            t.name,
            String(t.complexity.score),
            t.complexity.label,
            t.complexity.recommended_model,
            t.complexity.factors.join(", ") || "minimal"
          ]);
          lines.push(formatTable(headers, rows, { showAll: true }));
          lines.push("");
          lines.push(summaryLine(`${result.task_count} tasks classified, plan complexity ${result.plan_complexity}/5`));
          return lines.join("\n");
        }
      });
    }
    function cmdClassifyPhase(cwd, args, raw) {
      const phaseNum = args[0];
      if (!phaseNum) {
        error("Usage: classify phase <phase-number>");
      }
      const { findPhaseInternal } = require_helpers();
      const phaseInfo = findPhaseInternal(cwd, phaseNum);
      if (!phaseInfo) {
        error("Phase not found: " + phaseNum);
      }
      const planFiles = phaseInfo.incomplete_plans.length > 0 ? phaseInfo.incomplete_plans : phaseInfo.plans;
      const classifications = [];
      for (const planFile of planFiles) {
        const planPath = path.join(cwd, phaseInfo.directory, planFile);
        const classification = classifyPlan(planPath, cwd);
        if (classification) classifications.push(classification);
      }
      const executionMode = selectExecutionMode(classifications);
      const result = {
        phase: phaseNum,
        phase_name: phaseInfo.phase_name,
        plans_classified: classifications.length,
        plans: classifications,
        execution_mode: executionMode
      };
      output(result, {
        formatter: (res) => {
          const lines = [];
          lines.push(banner(`Classify Phase ${res.phase}`));
          lines.push("");
          if (res.phase_name) {
            lines.push(` Phase: ${color.bold(res.phase_name)}`);
          }
          lines.push(` Plans classified: ${res.plans_classified}`);
          lines.push("");
          for (const plan of res.plans) {
            lines.push(sectionHeader(plan.plan));
            lines.push(` Complexity: ${plan.plan_complexity}/5  |  Model: ${color.bold(plan.recommended_model)}  |  Tasks: ${plan.task_count}`);
            const headers = ["Task", "Score", "Label", "Factors"];
            const rows = plan.tasks.map((t) => [
              t.name,
              String(t.complexity.score),
              t.complexity.label,
              t.complexity.factors.join(", ") || "minimal"
            ]);
            lines.push(formatTable(headers, rows, { showAll: true }));
            lines.push("");
          }
          lines.push(sectionHeader("Execution Mode"));
          lines.push(` Mode: ${color.bold(res.execution_mode.mode)}`);
          lines.push(` Reason: ${res.execution_mode.reason}`);
          lines.push(` Waves: ${res.execution_mode.total_waves}  |  Plans: ${res.execution_mode.total_plans}  |  Checkpoints: ${res.execution_mode.has_checkpoints ? "yes" : "no"}`);
          lines.push("");
          lines.push(summaryLine(`${res.plans_classified} plans \u2192 ${res.execution_mode.mode} execution`));
          return lines.join("\n");
        }
      });
    }
    module2.exports = {
      classifyTaskComplexity,
      classifyPlan,
      selectExecutionMode,
      routeTask,
      parseTasksFromPlan,
      cmdClassifyPlan,
      cmdClassifyPhase
    };
  }
});

// src/commands/init.js
var require_init = __commonJS({
  "src/commands/init.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var { output, error, debugLog } = require_output();
    var { banner, sectionHeader, progressBar, formatTable, summaryLine, actionHint, color, SYMBOLS, colorByPercent } = require_format();
    var { loadConfig } = require_config();
    var { safeReadFile, cachedReadFile, findPhaseInternal, resolveModelInternal, getRoadmapPhaseInternal, getMilestoneInfo, getArchivedPhaseDirs, normalizePhaseName, isValidDateString, sanitizeShellArg, pathExistsInternal, generateSlugInternal, getPhaseTree } = require_helpers();
    var { extractFrontmatter } = require_frontmatter();
    var { execGit } = require_git();
    var { getIntentDriftData, getIntentSummary } = require_intent();
    var { autoTriggerEnvScan, formatEnvSummary, readEnvManifest } = require_env();
    var { autoTriggerCodebaseIntel } = require_codebase();
    var { getWorktreeConfig, parseWorktreeListPorcelain, getPhaseFilesModified } = require_worktree();
    var { getStalenessAge } = require_codebase_intel();
    function formatCodebaseContext(intel, cwd) {
      if (!intel || !intel.stats) {
        return { codebase_stats: null, codebase_conventions: null, codebase_dependencies: null, codebase_freshness: null };
      }
      const langs = Object.entries(intel.languages || {}).sort((a, b) => b[1].count - a[1].count).slice(0, 5).map(([lang, info]) => `${lang}(${info.count})`).join(", ");
      const codebase_stats = {
        total_files: intel.stats.total_files,
        total_lines: intel.stats.total_lines,
        top_languages: langs,
        git_commit: intel.git_commit_hash,
        generated_at: intel.generated_at,
        confidence: 1
      };
      let codebase_conventions = null;
      try {
        const conv = intel.conventions;
        if (conv) {
          const overallNaming = conv.naming?.overall || {};
          const namingEntries = Object.values(overallNaming);
          let naming = null;
          if (namingEntries.length > 0) {
            const dominant = namingEntries.sort((a, b) => b.confidence - a.confidence)[0];
            const alternatives = namingEntries.filter((e) => e.pattern !== dominant.pattern && e.confidence >= 20).map((e) => e.pattern);
            naming = { dominant: dominant.pattern, confidence: Math.round(dominant.confidence), alternatives };
          }
          const org = conv.file_organization;
          let structure = null;
          if (org) {
            structure = {
              type: org.structure_type || "flat",
              test_placement: org.test_placement || "unknown",
              config_placement: "root"
            };
          }
          let framework = null;
          if (conv.frameworks && conv.frameworks.length > 0) {
            const fw = conv.frameworks[0];
            framework = { name: fw.framework || fw.name || "unknown", patterns_detected: conv.frameworks.length };
          }
          const scores = [];
          if (naming) scores.push(naming.confidence / 100);
          if (structure) scores.push(0.7);
          const avgConfidence = scores.length > 0 ? Math.round(scores.reduce((a, b) => a + b, 0) / scores.length * 100) / 100 : 0.5;
          codebase_conventions = { naming, structure, framework, confidence: avgConfidence };
        }
      } catch (e) {
        debugLog("formatCodebaseContext", "conventions formatting failed", e);
      }
      let codebase_dependencies = null;
      try {
        const deps = intel.dependencies;
        if (deps) {
          const rev = deps.reverse || {};
          const topImported = Object.entries(rev).sort((a, b) => b[1].length - a[1].length).slice(0, 5).map(([file, importers]) => `${file}(${importers.length})`);
          codebase_dependencies = {
            total_modules: deps.stats?.total_files_parsed || 0,
            total_edges: deps.stats?.total_edges || 0,
            top_imported: topImported,
            has_cycles: (deps.stats?.cycles || 0) > 0,
            confidence: 0.85
          };
        }
      } catch (e) {
        debugLog("formatCodebaseContext", "dependencies formatting failed", e);
      }
      let codebase_freshness = null;
      try {
        if (cwd && typeof getStalenessAge === "function") {
          const age = getStalenessAge(intel, cwd);
          if (age) {
            const ONE_DAY = 24 * 60 * 60 * 1e3;
            if (age.age_ms > ONE_DAY) {
              codebase_freshness = { stale: true, reason: `${Math.round(age.age_ms / (60 * 60 * 1e3))}h old` };
            } else if (age.commits_behind > 10) {
              codebase_freshness = { stale: true, reason: `${age.commits_behind} commits behind` };
            }
          }
        }
      } catch (e) {
        debugLog("formatCodebaseContext", "freshness check failed", e);
      }
      return { codebase_stats, codebase_conventions, codebase_dependencies, codebase_freshness };
    }
    function cmdInitExecutePhase(cwd, phase, raw) {
      if (!phase) {
        error("phase required for init execute-phase");
      }
      const config = loadConfig(cwd);
      const phaseInfo = findPhaseInternal(cwd, phase);
      const milestone = getMilestoneInfo(cwd);
      let rawConfig = {};
      try {
        rawConfig = JSON.parse(fs.readFileSync(path.join(cwd, ".planning", "config.json"), "utf-8"));
      } catch (e) {
        debugLog("init.executePhase", "raw config read failed", e);
      }
      const result = {
        // Models
        executor_model: resolveModelInternal(cwd, "gsd-executor"),
        verifier_model: resolveModelInternal(cwd, "gsd-verifier"),
        // Config flags
        commit_docs: config.commit_docs,
        parallelization: config.parallelization,
        branching_strategy: config.branching_strategy,
        phase_branch_template: config.phase_branch_template,
        milestone_branch_template: config.milestone_branch_template,
        verifier_enabled: config.verifier,
        // Phase info
        phase_found: !!phaseInfo,
        phase_dir: phaseInfo?.directory || null,
        phase_number: phaseInfo?.phase_number || null,
        phase_name: phaseInfo?.phase_name || null,
        phase_slug: phaseInfo?.phase_slug || null,
        // Plan inventory
        plans: phaseInfo?.plans || [],
        summaries: phaseInfo?.summaries || [],
        incomplete_plans: phaseInfo?.incomplete_plans || [],
        plan_count: phaseInfo?.plans?.length || 0,
        incomplete_count: phaseInfo?.incomplete_plans?.length || 0,
        // Branch name (pre-computed)
        branch_name: config.branching_strategy === "phase" && phaseInfo ? config.phase_branch_template.replace("{phase}", phaseInfo.phase_number).replace("{slug}", phaseInfo.phase_slug || "phase") : config.branching_strategy === "milestone" ? config.milestone_branch_template.replace("{milestone}", milestone.version).replace("{slug}", generateSlugInternal(milestone.name) || "milestone") : null,
        // Milestone info
        milestone_version: milestone.version,
        milestone_name: milestone.name,
        milestone_slug: generateSlugInternal(milestone.name),
        // Gates
        pre_flight_validation: rawConfig.gates?.pre_flight_validation !== false,
        // Worktree parallelism
        worktree_enabled: rawConfig.worktree?.enabled || false,
        worktree_config: {
          base_path: rawConfig.worktree?.base_path || "/tmp/gsd-worktrees",
          sync_files: rawConfig.worktree?.sync_files || [".env", ".env.local", ".planning/config.json"],
          setup_hooks: rawConfig.worktree?.setup_hooks || [],
          max_concurrent: rawConfig.worktree?.max_concurrent || 3
        },
        worktree_active: [],
        file_overlaps: [],
        // File existence
        state_exists: pathExistsInternal(cwd, ".planning/STATE.md"),
        roadmap_exists: pathExistsInternal(cwd, ".planning/ROADMAP.md"),
        config_exists: pathExistsInternal(cwd, ".planning/config.json"),
        // File paths
        state_path: ".planning/STATE.md",
        roadmap_path: ".planning/ROADMAP.md",
        config_path: ".planning/config.json",
        // Intent drift advisory (null if no INTENT.md)
        intent_drift: null,
        // Intent summary (null if no INTENT.md)
        intent_summary: null
      };
      try {
        result.intent_summary = getIntentSummary(cwd);
      } catch (e) {
        debugLog("init.executePhase", "intent summary failed (non-blocking)", e);
      }
      try {
        const driftData = getIntentDriftData(cwd);
        if (driftData) {
          let advisory = null;
          if (driftData.drift_score <= 15) {
            advisory = null;
          } else if (driftData.drift_score <= 35) {
            advisory = "Intent alignment is good.";
          } else if (driftData.drift_score <= 60) {
            const gapsCount = driftData.signals.coverage_gap.details.length;
            advisory = `\u26A0 ${gapsCount} outcomes uncovered. Review intent trace.`;
          } else {
            advisory = `\u26A0 Significant drift detected (score: ${driftData.drift_score}). Run \`intent drift\` for details.`;
          }
          result.intent_drift = {
            score: driftData.drift_score,
            alignment: driftData.alignment,
            gaps_count: driftData.signals.coverage_gap.details.length,
            untraced_plans: driftData.signals.objective_mismatch.plans.length,
            advisory
          };
        }
      } catch (e) {
        debugLog("init.executePhase", "intent drift advisory failed (non-blocking)", e);
      }
      try {
        const envManifest = autoTriggerEnvScan(cwd);
        const envSummary = formatEnvSummary(envManifest);
        result.env_summary = envSummary;
        result.env_languages = envManifest?.languages?.length || 0;
        result.env_stale = false;
      } catch (e) {
        debugLog("init.executePhase", "env scan failed (non-blocking)", e);
        result.env_summary = null;
        result.env_languages = 0;
        result.env_stale = false;
      }
      try {
        const refreshMode = process.argv.includes("--refresh");
        if (refreshMode) {
          try {
            fs.unlinkSync(path.join(cwd, ".planning", ".cache", ".analyzing"));
          } catch {
          }
        }
        const codebaseIntel = autoTriggerCodebaseIntel(cwd, { synchronous: refreshMode });
        const ctx = formatCodebaseContext(codebaseIntel, cwd);
        result.codebase_stats = ctx.codebase_stats;
        result.codebase_conventions = ctx.codebase_conventions;
        result.codebase_dependencies = ctx.codebase_dependencies;
        result.codebase_freshness = ctx.codebase_freshness;
      } catch (e) {
        debugLog("init.executePhase", "codebase intel failed (non-blocking)", e);
        result.codebase_stats = null;
        result.codebase_conventions = null;
        result.codebase_dependencies = null;
        result.codebase_freshness = null;
      }
      try {
        const { classifyPlan, selectExecutionMode } = require_orchestration();
        const planClassifications = [];
        for (const planFile of phaseInfo?.incomplete_plans || []) {
          const planPath = path.join(cwd, phaseInfo.directory, planFile);
          const classification = classifyPlan(planPath, cwd);
          if (classification) planClassifications.push(classification);
        }
        if (planClassifications.length > 0) {
          result.task_routing = {
            plans: planClassifications,
            execution_mode: selectExecutionMode(planClassifications),
            classified_at: (/* @__PURE__ */ new Date()).toISOString()
          };
        } else {
          result.task_routing = null;
        }
      } catch (e) {
        debugLog("init.executePhase", "orchestration classification failed (non-blocking)", e);
        result.task_routing = null;
      }
      try {
        if (result.worktree_enabled) {
          const wtListResult = execGit(cwd, ["worktree", "list", "--porcelain"]);
          if (wtListResult.exitCode === 0) {
            const wtConfig = getWorktreeConfig(cwd);
            const projectName = path.basename(cwd);
            const projectBase = path.join(wtConfig.base_path, projectName);
            const allWts = parseWorktreeListPorcelain(wtListResult.stdout);
            result.worktree_active = allWts.filter((wt) => wt.path && wt.path.startsWith(projectBase + "/")).map((wt) => ({
              plan_id: path.basename(wt.path),
              branch: wt.branch || null,
              path: wt.path
            }));
          }
          if (phaseInfo?.phase_number) {
            const phasePlans = getPhaseFilesModified(cwd, phaseInfo.phase_number);
            const overlaps = [];
            const checked = /* @__PURE__ */ new Set();
            for (let i = 0; i < phasePlans.length; i++) {
              for (let j = i + 1; j < phasePlans.length; j++) {
                const a = phasePlans[i];
                const b = phasePlans[j];
                if (a.wave !== b.wave) continue;
                const pairKey = `${a.planId}:${b.planId}`;
                if (checked.has(pairKey)) continue;
                checked.add(pairKey);
                const sharedFiles = a.files_modified.filter((f) => b.files_modified.includes(f));
                if (sharedFiles.length > 0) {
                  overlaps.push({ plans: [a.planId, b.planId], files: sharedFiles, wave: a.wave });
                }
              }
            }
            result.file_overlaps = overlaps;
          }
        }
      } catch (e) {
        debugLog("init.executePhase", "worktree context failed (non-blocking)", e);
      }
      const agentArg = process.argv.find((a) => a.startsWith("--agent="));
      if (agentArg) {
        const agentType = agentArg.split("=")[1];
        if (agentType) {
          const { scopeContextForAgent } = require_context();
          return output(scopeContextForAgent(result, agentType), raw);
        }
      }
      if (global._gsdCompactMode) {
        const planPaths = (result.plans || []).map((p) => typeof p === "string" ? p : p.file || p);
        const compactResult = {
          phase_found: result.phase_found,
          phase_dir: result.phase_dir,
          phase_number: result.phase_number,
          phase_name: result.phase_name,
          plans: planPaths,
          incomplete_plans: (result.incomplete_plans || []).map((p) => typeof p === "string" ? p : p.file || p),
          plan_count: result.plan_count,
          incomplete_count: result.incomplete_count,
          branch_name: result.branch_name,
          verifier_enabled: result.verifier_enabled,
          pre_flight_validation: result.pre_flight_validation,
          intent_drift: result.intent_drift ? {
            score: result.intent_drift.score,
            alignment: result.intent_drift.alignment,
            advisory: result.intent_drift.advisory
          } : null,
          intent_summary: result.intent_summary || null,
          env_summary: result.env_summary || null,
          codebase_stats: result.codebase_stats || null,
          codebase_conventions: result.codebase_conventions || null,
          codebase_dependencies: result.codebase_dependencies || null,
          codebase_freshness: result.codebase_freshness || null,
          worktree_enabled: result.worktree_enabled,
          worktree_config: result.worktree_config,
          worktree_active: result.worktree_active,
          file_overlaps: result.file_overlaps,
          task_routing: result.task_routing || null
        };
        if (global._gsdManifestMode) {
          compactResult._manifest = {
            files: [
              ...planPaths.map((p) => ({ path: result.phase_dir ? `${result.phase_dir}/${p}` : p, required: true })),
              ...result.state_exists ? [{ path: ".planning/STATE.md", sections: ["Current Position"], required: true }] : [],
              ...result.roadmap_exists ? [{ path: ".planning/ROADMAP.md", sections: [`Phase ${result.phase_number || ""}`], required: true }] : []
            ]
          };
        }
        return output(compactResult, raw);
      }
      if (!result.worktree_enabled) {
        delete result.worktree_config;
        delete result.worktree_active;
        delete result.file_overlaps;
      }
      if (result.intent_drift === null) delete result.intent_drift;
      if (result.intent_summary === null) delete result.intent_summary;
      if (result.env_summary === null) {
        delete result.env_summary;
        delete result.env_languages;
        delete result.env_stale;
      }
      if (result.codebase_stats === null) delete result.codebase_stats;
      if (result.codebase_conventions === null) delete result.codebase_conventions;
      if (result.codebase_dependencies === null) delete result.codebase_dependencies;
      if (result.codebase_freshness === null) delete result.codebase_freshness;
      output(result, raw);
    }
    function cmdInitPlanPhase(cwd, phase, raw) {
      if (!phase) {
        error("phase required for init plan-phase");
      }
      const config = loadConfig(cwd);
      const phaseInfo = findPhaseInternal(cwd, phase);
      const result = {
        // Models
        researcher_model: resolveModelInternal(cwd, "gsd-phase-researcher"),
        planner_model: resolveModelInternal(cwd, "gsd-planner"),
        checker_model: resolveModelInternal(cwd, "gsd-plan-checker"),
        // Workflow flags
        research_enabled: config.research,
        plan_checker_enabled: config.plan_checker,
        commit_docs: config.commit_docs,
        // Phase info
        phase_found: !!phaseInfo,
        phase_dir: phaseInfo?.directory || null,
        phase_number: phaseInfo?.phase_number || null,
        phase_name: phaseInfo?.phase_name || null,
        phase_slug: phaseInfo?.phase_slug || null,
        padded_phase: phaseInfo?.phase_number?.padStart(2, "0") || null,
        // Existing artifacts
        has_research: phaseInfo?.has_research || false,
        has_context: phaseInfo?.has_context || false,
        has_plans: (phaseInfo?.plans?.length || 0) > 0,
        plan_count: phaseInfo?.plans?.length || 0,
        // Environment
        planning_exists: pathExistsInternal(cwd, ".planning"),
        roadmap_exists: pathExistsInternal(cwd, ".planning/ROADMAP.md"),
        // File paths
        state_path: ".planning/STATE.md",
        roadmap_path: ".planning/ROADMAP.md",
        requirements_path: ".planning/REQUIREMENTS.md",
        // Intent context (null if no INTENT.md)
        intent_summary: null,
        intent_path: null
      };
      try {
        result.intent_summary = getIntentSummary(cwd);
        const intentFile = path.join(cwd, ".planning", "INTENT.md");
        if (fs.existsSync(intentFile)) {
          result.intent_path = ".planning/INTENT.md";
        }
      } catch (e) {
        debugLog("init.planPhase", "intent summary failed (non-blocking)", e);
      }
      try {
        const refreshMode = process.argv.includes("--refresh");
        if (refreshMode) {
          try {
            fs.unlinkSync(path.join(cwd, ".planning", ".cache", ".analyzing"));
          } catch {
          }
        }
        const codebaseIntel = autoTriggerCodebaseIntel(cwd, { synchronous: refreshMode });
        const ctx = formatCodebaseContext(codebaseIntel, cwd);
        result.codebase_stats = ctx.codebase_stats;
        result.codebase_conventions = ctx.codebase_conventions;
        result.codebase_dependencies = ctx.codebase_dependencies;
        result.codebase_freshness = ctx.codebase_freshness;
      } catch (e) {
        debugLog("init.planPhase", "codebase intel failed (non-blocking)", e);
        result.codebase_stats = null;
        result.codebase_conventions = null;
        result.codebase_dependencies = null;
        result.codebase_freshness = null;
      }
      if (phaseInfo?.directory) {
        const phaseDirFull = path.join(cwd, phaseInfo.directory);
        try {
          const files = fs.readdirSync(phaseDirFull);
          const contextFile = files.find((f) => f.endsWith("-CONTEXT.md") || f === "CONTEXT.md");
          if (contextFile) {
            result.context_path = path.join(phaseInfo.directory, contextFile);
          }
          const researchFile = files.find((f) => f.endsWith("-RESEARCH.md") || f === "RESEARCH.md");
          if (researchFile) {
            result.research_path = path.join(phaseInfo.directory, researchFile);
          }
          const verificationFile = files.find((f) => f.endsWith("-VERIFICATION.md") || f === "VERIFICATION.md");
          if (verificationFile) {
            result.verification_path = path.join(phaseInfo.directory, verificationFile);
          }
          const uatFile = files.find((f) => f.endsWith("-UAT.md") || f === "UAT.md");
          if (uatFile) {
            result.uat_path = path.join(phaseInfo.directory, uatFile);
          }
        } catch (e) {
          debugLog("init.planPhase", "read phase files failed", e);
        }
      }
      const agentArg = process.argv.find((a) => a.startsWith("--agent="));
      if (agentArg) {
        const agentType = agentArg.split("=")[1];
        if (agentType) {
          const { scopeContextForAgent } = require_context();
          return output(scopeContextForAgent(result, agentType), raw);
        }
      }
      if (global._gsdCompactMode) {
        const compactResult = {
          phase_found: result.phase_found,
          phase_dir: result.phase_dir,
          phase_number: result.phase_number,
          phase_name: result.phase_name,
          phase_slug: result.phase_slug,
          padded_phase: result.padded_phase,
          has_research: result.has_research,
          has_context: result.has_context,
          has_plans: result.has_plans,
          plan_count: result.plan_count,
          research_enabled: result.research_enabled,
          plan_checker_enabled: result.plan_checker_enabled
        };
        if (result.intent_summary) compactResult.intent_summary = result.intent_summary;
        if (result.intent_path) compactResult.intent_path = result.intent_path;
        if (result.codebase_stats) compactResult.codebase_stats = result.codebase_stats;
        if (result.codebase_conventions) compactResult.codebase_conventions = result.codebase_conventions;
        if (result.codebase_dependencies) compactResult.codebase_dependencies = result.codebase_dependencies;
        if (result.codebase_freshness) compactResult.codebase_freshness = result.codebase_freshness;
        if (result.context_path) compactResult.context_path = result.context_path;
        if (result.research_path) compactResult.research_path = result.research_path;
        if (result.verification_path) compactResult.verification_path = result.verification_path;
        if (result.uat_path) compactResult.uat_path = result.uat_path;
        if (global._gsdManifestMode) {
          const manifestFiles = [
            { path: ".planning/STATE.md", sections: ["Current Position", "Accumulated Context"], required: true },
            { path: ".planning/ROADMAP.md", sections: [`Phase ${result.phase_number || ""}`], required: true },
            { path: ".planning/REQUIREMENTS.md", required: true }
          ];
          if (result.context_path) manifestFiles.push({ path: result.context_path, required: false });
          if (result.research_path) manifestFiles.push({ path: result.research_path, required: false });
          if (result.verification_path) manifestFiles.push({ path: result.verification_path, required: false });
          compactResult._manifest = { files: manifestFiles };
        }
        return output(compactResult, raw);
      }
      if (result.intent_summary === null) delete result.intent_summary;
      if (result.intent_path === null) delete result.intent_path;
      if (result.codebase_stats === null) delete result.codebase_stats;
      if (result.codebase_conventions === null) delete result.codebase_conventions;
      if (result.codebase_dependencies === null) delete result.codebase_dependencies;
      if (result.codebase_freshness === null) delete result.codebase_freshness;
      output(result, raw);
    }
    function cmdInitNewProject(cwd, raw) {
      const config = loadConfig(cwd);
      const homedir = require("os").homedir();
      const braveKeyFile = path.join(homedir, ".gsd", "brave_api_key");
      const hasBraveSearch = !!(process.env.BRAVE_API_KEY || fs.existsSync(braveKeyFile));
      let hasCode = false;
      let hasPackageFile = false;
      const codeExts = /* @__PURE__ */ new Set([".ts", ".js", ".py", ".go", ".rs", ".swift", ".java"]);
      const skipDirs = /* @__PURE__ */ new Set(["node_modules", ".git", "dist", "build", "__pycache__"]);
      try {
        const scanForCode = (dir, depth) => {
          if (hasCode || depth > 3) return;
          const entries = fs.readdirSync(dir, { withFileTypes: true });
          for (const e of entries) {
            if (hasCode) return;
            if (e.isDirectory() && !skipDirs.has(e.name)) {
              scanForCode(path.join(dir, e.name), depth + 1);
            } else if (e.isFile() && codeExts.has(path.extname(e.name))) {
              hasCode = true;
            }
          }
        };
        scanForCode(cwd, 0);
      } catch (e) {
        debugLog("init.newProject", "code scan failed", e);
      }
      hasPackageFile = pathExistsInternal(cwd, "package.json") || pathExistsInternal(cwd, "requirements.txt") || pathExistsInternal(cwd, "Cargo.toml") || pathExistsInternal(cwd, "go.mod") || pathExistsInternal(cwd, "Package.swift");
      const result = {
        // Models
        researcher_model: resolveModelInternal(cwd, "gsd-project-researcher"),
        synthesizer_model: resolveModelInternal(cwd, "gsd-research-synthesizer"),
        roadmapper_model: resolveModelInternal(cwd, "gsd-roadmapper"),
        // Config
        commit_docs: config.commit_docs,
        // Existing state
        project_exists: pathExistsInternal(cwd, ".planning/PROJECT.md"),
        has_codebase_map: pathExistsInternal(cwd, ".planning/codebase"),
        planning_exists: pathExistsInternal(cwd, ".planning"),
        // Brownfield detection
        has_existing_code: hasCode,
        has_package_file: hasPackageFile,
        is_brownfield: hasCode || hasPackageFile,
        needs_codebase_map: (hasCode || hasPackageFile) && !pathExistsInternal(cwd, ".planning/codebase"),
        // Git state
        has_git: pathExistsInternal(cwd, ".git"),
        // Enhanced search
        brave_search_available: hasBraveSearch,
        // File paths
        project_path: ".planning/PROJECT.md"
      };
      if (global._gsdCompactMode) {
        const manifestFiles = [];
        if (result.project_exists) manifestFiles.push({ path: ".planning/PROJECT.md", required: false });
        if (pathExistsInternal(cwd, "AGENTS.md")) manifestFiles.push({ path: "AGENTS.md", required: false });
        const compactResult = {
          is_brownfield: result.is_brownfield,
          needs_codebase_map: result.needs_codebase_map,
          has_existing_code: result.has_existing_code,
          has_package_file: result.has_package_file,
          project_exists: result.project_exists,
          has_codebase_map: result.has_codebase_map,
          planning_exists: result.planning_exists,
          has_git: result.has_git,
          brave_search_available: result.brave_search_available
        };
        if (global._gsdManifestMode) {
          compactResult._manifest = { files: manifestFiles };
        }
        return output(compactResult, raw);
      }
      output(result, raw);
    }
    function cmdInitNewMilestone(cwd, raw) {
      const config = loadConfig(cwd);
      const milestone = getMilestoneInfo(cwd);
      const result = {
        // Models
        researcher_model: resolveModelInternal(cwd, "gsd-project-researcher"),
        synthesizer_model: resolveModelInternal(cwd, "gsd-research-synthesizer"),
        roadmapper_model: resolveModelInternal(cwd, "gsd-roadmapper"),
        // Config
        commit_docs: config.commit_docs,
        research_enabled: config.research,
        // Current milestone
        current_milestone: milestone.version,
        current_milestone_name: milestone.name,
        // File existence
        project_exists: pathExistsInternal(cwd, ".planning/PROJECT.md"),
        roadmap_exists: pathExistsInternal(cwd, ".planning/ROADMAP.md"),
        state_exists: pathExistsInternal(cwd, ".planning/STATE.md"),
        // File paths
        project_path: ".planning/PROJECT.md",
        roadmap_path: ".planning/ROADMAP.md",
        state_path: ".planning/STATE.md"
      };
      if (global._gsdCompactMode) {
        const manifestFiles = [];
        if (result.project_exists) manifestFiles.push({ path: ".planning/PROJECT.md", required: true });
        if (result.roadmap_exists) manifestFiles.push({ path: ".planning/ROADMAP.md", sections: ["Milestones", "Progress"], required: true });
        if (result.state_exists) manifestFiles.push({ path: ".planning/STATE.md", sections: ["Accumulated Context"], required: true });
        const compactResult = {
          current_milestone: result.current_milestone,
          current_milestone_name: result.current_milestone_name,
          project_exists: result.project_exists,
          roadmap_exists: result.roadmap_exists,
          state_exists: result.state_exists,
          research_enabled: result.research_enabled
        };
        if (global._gsdManifestMode) {
          compactResult._manifest = { files: manifestFiles };
        }
        return output(compactResult, raw);
      }
      output(result, raw);
    }
    function cmdInitQuick(cwd, description, raw) {
      const config = loadConfig(cwd);
      const now = /* @__PURE__ */ new Date();
      const slug = description ? generateSlugInternal(description)?.substring(0, 40) : null;
      const quickDir = path.join(cwd, ".planning", "quick");
      let nextNum = 1;
      try {
        const existing = fs.readdirSync(quickDir).filter((f) => /^\d+-/.test(f)).map((f) => parseInt(f.split("-")[0], 10)).filter((n) => !isNaN(n));
        if (existing.length > 0) {
          nextNum = Math.max(...existing) + 1;
        }
      } catch (e) {
        debugLog("init.quick", "readdir failed", e);
      }
      const result = {
        // Models
        planner_model: resolveModelInternal(cwd, "gsd-planner"),
        executor_model: resolveModelInternal(cwd, "gsd-executor"),
        checker_model: resolveModelInternal(cwd, "gsd-plan-checker"),
        verifier_model: resolveModelInternal(cwd, "gsd-verifier"),
        // Config
        commit_docs: config.commit_docs,
        // Quick task info
        next_num: nextNum,
        slug,
        description: description || null,
        // Timestamps
        date: now.toISOString().split("T")[0],
        timestamp: now.toISOString(),
        // Paths
        quick_dir: ".planning/quick",
        task_dir: slug ? `.planning/quick/${nextNum}-${slug}` : null,
        // File existence
        roadmap_exists: pathExistsInternal(cwd, ".planning/ROADMAP.md"),
        planning_exists: pathExistsInternal(cwd, ".planning")
      };
      try {
        const envManifest = autoTriggerEnvScan(cwd);
        result.env_summary = formatEnvSummary(envManifest);
      } catch (e) {
        debugLog("init.quick", "env scan failed (non-blocking)", e);
        result.env_summary = null;
      }
      if (global._gsdCompactMode) {
        const manifestFiles = [];
        if (pathExistsInternal(cwd, ".planning/STATE.md")) manifestFiles.push({ path: ".planning/STATE.md", sections: ["Current Position"], required: false });
        const compactResult = {
          next_num: result.next_num,
          slug: result.slug,
          description: result.description,
          task_dir: result.task_dir,
          date: result.date,
          planning_exists: result.planning_exists,
          env_summary: result.env_summary || null
        };
        if (global._gsdManifestMode) {
          compactResult._manifest = { files: manifestFiles };
        }
        return output(compactResult, raw);
      }
      output(result, raw);
    }
    function cmdInitResume(cwd, raw) {
      const config = loadConfig(cwd);
      let interruptedAgentId = null;
      try {
        interruptedAgentId = fs.readFileSync(path.join(cwd, ".planning", "current-agent-id.txt"), "utf-8").trim();
      } catch (e) {
        debugLog("init.resume", "read failed", e);
      }
      const result = {
        // File existence
        state_exists: pathExistsInternal(cwd, ".planning/STATE.md"),
        roadmap_exists: pathExistsInternal(cwd, ".planning/ROADMAP.md"),
        project_exists: pathExistsInternal(cwd, ".planning/PROJECT.md"),
        planning_exists: pathExistsInternal(cwd, ".planning"),
        // File paths
        state_path: ".planning/STATE.md",
        roadmap_path: ".planning/ROADMAP.md",
        project_path: ".planning/PROJECT.md",
        // Agent state
        has_interrupted_agent: !!interruptedAgentId,
        interrupted_agent_id: interruptedAgentId,
        // Config
        commit_docs: config.commit_docs
      };
      try {
        const envManifest = autoTriggerEnvScan(cwd);
        result.env_summary = formatEnvSummary(envManifest);
      } catch (e) {
        debugLog("init.resume", "env scan failed (non-blocking)", e);
        result.env_summary = null;
      }
      if (global._gsdCompactMode) {
        const manifestFiles = [];
        if (result.state_exists) manifestFiles.push({ path: ".planning/STATE.md", required: true });
        if (result.roadmap_exists) manifestFiles.push({ path: ".planning/ROADMAP.md", sections: ["Progress"], required: true });
        const compactResult = {
          state_exists: result.state_exists,
          planning_exists: result.planning_exists,
          has_interrupted_agent: result.has_interrupted_agent,
          interrupted_agent_id: result.interrupted_agent_id,
          env_summary: result.env_summary || null
        };
        if (global._gsdManifestMode) {
          compactResult._manifest = { files: manifestFiles };
        }
        return output(compactResult, raw);
      }
      output(result, raw);
    }
    function cmdInitVerifyWork(cwd, phase, raw) {
      if (!phase) {
        error("phase required for init verify-work");
      }
      const config = loadConfig(cwd);
      const phaseInfo = findPhaseInternal(cwd, phase);
      const result = {
        // Models
        planner_model: resolveModelInternal(cwd, "gsd-planner"),
        checker_model: resolveModelInternal(cwd, "gsd-plan-checker"),
        // Config
        commit_docs: config.commit_docs,
        // Phase info
        phase_found: !!phaseInfo,
        phase_dir: phaseInfo?.directory || null,
        phase_number: phaseInfo?.phase_number || null,
        phase_name: phaseInfo?.phase_name || null,
        // Existing artifacts
        has_verification: phaseInfo?.has_verification || false
      };
      if (global._gsdCompactMode) {
        const manifestFiles = [];
        if (phaseInfo?.directory) {
          try {
            const phaseFiles = fs.readdirSync(path.join(cwd, phaseInfo.directory));
            phaseFiles.filter((f) => f.endsWith("-PLAN.md")).forEach((f) => {
              manifestFiles.push({ path: `${phaseInfo.directory}/${f}`, required: true });
            });
            phaseFiles.filter((f) => f.endsWith("-SUMMARY.md")).forEach((f) => {
              manifestFiles.push({ path: `${phaseInfo.directory}/${f}`, required: true });
            });
          } catch (e) {
            debugLog("init.verifyWork", "manifest scan failed", e);
          }
        }
        if (pathExistsInternal(cwd, ".planning/ROADMAP.md")) {
          manifestFiles.push({ path: ".planning/ROADMAP.md", sections: [`Phase ${result.phase_number || ""}`], required: true });
        }
        const compactResult = {
          phase_found: result.phase_found,
          phase_dir: result.phase_dir,
          phase_number: result.phase_number,
          phase_name: result.phase_name,
          has_verification: result.has_verification
        };
        if (global._gsdManifestMode) {
          compactResult._manifest = { files: manifestFiles };
        }
        return output(compactResult, raw);
      }
      output(result, raw);
    }
    function cmdInitPhaseOp(cwd, phase, raw) {
      const config = loadConfig(cwd);
      let phaseInfo = findPhaseInternal(cwd, phase);
      if (!phaseInfo) {
        const roadmapPhase = getRoadmapPhaseInternal(cwd, phase);
        if (roadmapPhase?.found) {
          const phaseName = roadmapPhase.phase_name;
          phaseInfo = {
            found: true,
            directory: null,
            phase_number: roadmapPhase.phase_number,
            phase_name: phaseName,
            phase_slug: phaseName ? phaseName.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "") : null,
            plans: [],
            summaries: [],
            incomplete_plans: [],
            has_research: false,
            has_context: false,
            has_verification: false
          };
        }
      }
      const result = {
        // Config
        commit_docs: config.commit_docs,
        brave_search: config.brave_search,
        // Phase info
        phase_found: !!phaseInfo,
        phase_dir: phaseInfo?.directory || null,
        phase_number: phaseInfo?.phase_number || null,
        phase_name: phaseInfo?.phase_name || null,
        phase_slug: phaseInfo?.phase_slug || null,
        padded_phase: phaseInfo?.phase_number?.padStart(2, "0") || null,
        // Existing artifacts
        has_research: phaseInfo?.has_research || false,
        has_context: phaseInfo?.has_context || false,
        has_plans: (phaseInfo?.plans?.length || 0) > 0,
        has_verification: phaseInfo?.has_verification || false,
        plan_count: phaseInfo?.plans?.length || 0,
        // File existence
        roadmap_exists: pathExistsInternal(cwd, ".planning/ROADMAP.md"),
        planning_exists: pathExistsInternal(cwd, ".planning"),
        // File paths
        state_path: ".planning/STATE.md",
        roadmap_path: ".planning/ROADMAP.md",
        requirements_path: ".planning/REQUIREMENTS.md"
      };
      if (phaseInfo?.directory) {
        const phaseDirFull = path.join(cwd, phaseInfo.directory);
        try {
          const files = fs.readdirSync(phaseDirFull);
          const contextFile = files.find((f) => f.endsWith("-CONTEXT.md") || f === "CONTEXT.md");
          if (contextFile) {
            result.context_path = path.join(phaseInfo.directory, contextFile);
          }
          const researchFile = files.find((f) => f.endsWith("-RESEARCH.md") || f === "RESEARCH.md");
          if (researchFile) {
            result.research_path = path.join(phaseInfo.directory, researchFile);
          }
          const verificationFile = files.find((f) => f.endsWith("-VERIFICATION.md") || f === "VERIFICATION.md");
          if (verificationFile) {
            result.verification_path = path.join(phaseInfo.directory, verificationFile);
          }
          const uatFile = files.find((f) => f.endsWith("-UAT.md") || f === "UAT.md");
          if (uatFile) {
            result.uat_path = path.join(phaseInfo.directory, uatFile);
          }
        } catch (e) {
          debugLog("init.phaseOp", "read phase files failed", e);
        }
      }
      try {
        const refreshMode = process.argv.includes("--refresh");
        if (refreshMode) {
          try {
            fs.unlinkSync(path.join(cwd, ".planning", ".cache", ".analyzing"));
          } catch {
          }
        }
        const codebaseIntel = autoTriggerCodebaseIntel(cwd, { synchronous: refreshMode });
        const ctx = formatCodebaseContext(codebaseIntel, cwd);
        result.codebase_stats = ctx.codebase_stats;
        result.codebase_conventions = ctx.codebase_conventions;
        result.codebase_dependencies = ctx.codebase_dependencies;
        result.codebase_freshness = ctx.codebase_freshness;
      } catch (e) {
        debugLog("init.phaseOp", "codebase intel failed (non-blocking)", e);
        result.codebase_stats = null;
        result.codebase_conventions = null;
        result.codebase_dependencies = null;
        result.codebase_freshness = null;
      }
      if (global._gsdCompactMode) {
        const compactResult = {
          phase_found: result.phase_found,
          phase_dir: result.phase_dir,
          phase_number: result.phase_number,
          phase_name: result.phase_name,
          phase_slug: result.phase_slug,
          padded_phase: result.padded_phase,
          has_research: result.has_research,
          has_context: result.has_context,
          has_plans: result.has_plans,
          has_verification: result.has_verification,
          plan_count: result.plan_count
        };
        if (result.context_path) compactResult.context_path = result.context_path;
        if (result.research_path) compactResult.research_path = result.research_path;
        if (result.verification_path) compactResult.verification_path = result.verification_path;
        if (result.uat_path) compactResult.uat_path = result.uat_path;
        if (result.codebase_stats) compactResult.codebase_stats = result.codebase_stats;
        if (result.codebase_conventions) compactResult.codebase_conventions = result.codebase_conventions;
        if (result.codebase_dependencies) compactResult.codebase_dependencies = result.codebase_dependencies;
        if (result.codebase_freshness) compactResult.codebase_freshness = result.codebase_freshness;
        if (global._gsdManifestMode) {
          const manifestFiles = [
            { path: ".planning/STATE.md", sections: ["Current Position"], required: true },
            { path: ".planning/ROADMAP.md", sections: [`Phase ${result.phase_number || ""}`], required: true }
          ];
          if (pathExistsInternal(cwd, ".planning/REQUIREMENTS.md")) manifestFiles.push({ path: ".planning/REQUIREMENTS.md", required: false });
          if (result.context_path) manifestFiles.push({ path: result.context_path, required: false });
          if (result.research_path) manifestFiles.push({ path: result.research_path, required: false });
          compactResult._manifest = { files: manifestFiles };
        }
        return output(compactResult, raw);
      }
      output(result, raw);
    }
    function cmdInitTodos(cwd, area, raw) {
      const config = loadConfig(cwd);
      const now = /* @__PURE__ */ new Date();
      const pendingDir = path.join(cwd, ".planning", "todos", "pending");
      let count = 0;
      const todos = [];
      try {
        const files = fs.readdirSync(pendingDir).filter((f) => f.endsWith(".md"));
        for (const file of files) {
          try {
            const content = fs.readFileSync(path.join(pendingDir, file), "utf-8");
            const createdMatch = content.match(/^created:\s*(.+)$/m);
            const titleMatch = content.match(/^title:\s*(.+)$/m);
            const areaMatch = content.match(/^area:\s*(.+)$/m);
            const todoArea = areaMatch ? areaMatch[1].trim() : "general";
            if (area && todoArea !== area) continue;
            count++;
            todos.push({
              file,
              created: createdMatch ? createdMatch[1].trim() : "unknown",
              title: titleMatch ? titleMatch[1].trim() : "Untitled",
              area: todoArea,
              path: path.join(".planning", "todos", "pending", file)
            });
          } catch (e) {
            debugLog("init.todos", "read todo file failed", e);
          }
        }
      } catch (e) {
        debugLog("init.todos", "read pending dir failed", e);
      }
      const result = {
        // Config
        commit_docs: config.commit_docs,
        // Timestamps
        date: now.toISOString().split("T")[0],
        timestamp: now.toISOString(),
        // Todo inventory
        todo_count: count,
        todos,
        area_filter: area || null,
        // Paths
        pending_dir: ".planning/todos/pending",
        completed_dir: ".planning/todos/completed",
        // File existence
        planning_exists: pathExistsInternal(cwd, ".planning"),
        todos_dir_exists: pathExistsInternal(cwd, ".planning/todos"),
        pending_dir_exists: pathExistsInternal(cwd, ".planning/todos/pending")
      };
      if (global._gsdCompactMode) {
        const manifestFiles = result.todos.map((t) => ({ path: t.path, required: true }));
        const compactResult = {
          todo_count: result.todo_count,
          todos: result.todos,
          area_filter: result.area_filter,
          date: result.date,
          pending_dir_exists: result.pending_dir_exists
        };
        if (global._gsdManifestMode) {
          compactResult._manifest = { files: manifestFiles };
        }
        return output(compactResult, raw);
      }
      output(result, raw);
    }
    function cmdInitMilestoneOp(cwd, raw) {
      const config = loadConfig(cwd);
      const milestone = getMilestoneInfo(cwd);
      let phaseCount = 0;
      let completedPhases = 0;
      const phaseTree = getPhaseTree(cwd);
      phaseCount = phaseTree.size;
      for (const [, entry] of phaseTree) {
        if (entry.summaries.length > 0) completedPhases++;
      }
      const archiveDir = path.join(cwd, ".planning", "archive");
      let archivedMilestones = [];
      try {
        archivedMilestones = fs.readdirSync(archiveDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name);
      } catch (e) {
        debugLog("init.milestoneOp", "readdir failed", e);
      }
      const result = {
        // Config
        commit_docs: config.commit_docs,
        // Current milestone
        milestone_version: milestone.version,
        milestone_name: milestone.name,
        milestone_slug: generateSlugInternal(milestone.name),
        // Phase counts
        phase_count: phaseCount,
        completed_phases: completedPhases,
        all_phases_complete: phaseCount > 0 && phaseCount === completedPhases,
        // Archive
        archived_milestones: archivedMilestones,
        archive_count: archivedMilestones.length,
        // File existence
        project_exists: pathExistsInternal(cwd, ".planning/PROJECT.md"),
        roadmap_exists: pathExistsInternal(cwd, ".planning/ROADMAP.md"),
        state_exists: pathExistsInternal(cwd, ".planning/STATE.md"),
        archive_exists: pathExistsInternal(cwd, ".planning/archive"),
        phases_dir_exists: pathExistsInternal(cwd, ".planning/phases")
      };
      if (global._gsdCompactMode) {
        const manifestFiles = [];
        if (result.roadmap_exists) manifestFiles.push({ path: ".planning/ROADMAP.md", sections: ["Milestones", "Progress"], required: true });
        if (result.state_exists) manifestFiles.push({ path: ".planning/STATE.md", sections: ["Current Position"], required: true });
        const compactResult = {
          milestone_version: result.milestone_version,
          milestone_name: result.milestone_name,
          phase_count: result.phase_count,
          completed_phases: result.completed_phases,
          all_phases_complete: result.all_phases_complete,
          archived_milestones: result.archived_milestones,
          archive_count: result.archive_count
        };
        if (global._gsdManifestMode) {
          compactResult._manifest = { files: manifestFiles };
        }
        return output(compactResult, raw);
      }
      output(result, raw);
    }
    function cmdInitMapCodebase(cwd, raw) {
      const config = loadConfig(cwd);
      const codebaseDir = path.join(cwd, ".planning", "codebase");
      let existingMaps = [];
      try {
        existingMaps = fs.readdirSync(codebaseDir).filter((f) => f.endsWith(".md"));
      } catch (e) {
        debugLog("init.mapCodebase", "readdir failed", e);
      }
      const result = {
        // Models
        mapper_model: resolveModelInternal(cwd, "gsd-codebase-mapper"),
        // Config
        commit_docs: config.commit_docs,
        search_gitignored: config.search_gitignored,
        parallelization: config.parallelization,
        // Paths
        codebase_dir: ".planning/codebase",
        // Existing maps
        existing_maps: existingMaps,
        has_maps: existingMaps.length > 0,
        // File existence
        planning_exists: pathExistsInternal(cwd, ".planning"),
        codebase_dir_exists: pathExistsInternal(cwd, ".planning/codebase")
      };
      if (global._gsdCompactMode) {
        const manifestFiles = result.existing_maps.map((m) => ({ path: `.planning/codebase/${m}`, required: false }));
        if (pathExistsInternal(cwd, ".planning/PROJECT.md")) manifestFiles.push({ path: ".planning/PROJECT.md", sections: ["Tech Stack"], required: false });
        const compactResult = {
          existing_maps: result.existing_maps,
          has_maps: result.has_maps,
          planning_exists: result.planning_exists,
          codebase_dir_exists: result.codebase_dir_exists,
          parallelization: result.parallelization
        };
        if (global._gsdManifestMode) {
          compactResult._manifest = { files: manifestFiles };
        }
        return output(compactResult, raw);
      }
      output(result, raw);
    }
    function formatInitProgress(result) {
      const lines = [];
      lines.push(banner("Progress"));
      lines.push("");
      if (result.milestone_version || result.milestone_name) {
        const version = result.milestone_version || "?";
        const name = result.milestone_name || "";
        lines.push(color.bold(`${version}`) + (name ? ` ${color.dim("\u2014")} ${name}` : ""));
        lines.push("");
      }
      const completedCount = result.completed_count || 0;
      const phaseCount = result.phase_count || 0;
      const completedPercent = phaseCount > 0 ? Math.round(completedCount / phaseCount * 100) : 0;
      lines.push(progressBar(completedPercent) + `  ${completedCount}/${phaseCount} phases`);
      lines.push("");
      if (result.phases && result.phases.length > 0) {
        lines.push(sectionHeader("Phases"));
        const rows = result.phases.map((p) => {
          let statusIcon;
          if (p.status === "complete") statusIcon = color.green(SYMBOLS.check);
          else if (p.status === "in_progress") statusIcon = color.cyan(SYMBOLS.progress);
          else statusIcon = color.dim(SYMBOLS.pending);
          const plans = p.plan_count > 0 ? `${p.summary_count}/${p.plan_count}` : color.dim("TBD");
          return [p.number, statusIcon + " " + (p.status || "pending"), p.name || "", plans];
        });
        lines.push(formatTable(["#", "Status", "Phase", "Plans"], rows, { maxRows: 20, showAll: true }));
        lines.push("");
      }
      if (result.current_phase) {
        lines.push(sectionHeader("Current"));
        lines.push(` Phase ${result.current_phase.number}: ${result.current_phase.name || "unnamed"}`);
        lines.push("");
      }
      if (result.next_phase) {
        lines.push(actionHint(`Next: /gsd-discuss-phase ${result.next_phase.number}`));
      }
      if (result.session_diff && result.session_diff.commit_count > 0) {
        lines.push("");
        lines.push(sectionHeader("Session"));
        lines.push(` ${result.session_diff.commit_count} commits since last session`);
        if (result.session_diff.recent && result.session_diff.recent.length > 0) {
          for (const commit of result.session_diff.recent.slice(0, 3)) {
            lines.push(color.dim(`   ${commit}`));
          }
        }
      }
      lines.push("");
      const milestoneSuffix = result.milestone_name ? ` \u2014 ${result.milestone_name}` : "";
      lines.push(summaryLine(`${completedCount}/${phaseCount} phases complete${milestoneSuffix}`));
      return lines.join("\n");
    }
    function cmdInitProgress(cwd, raw) {
      const config = loadConfig(cwd);
      const milestone = getMilestoneInfo(cwd);
      const phases = [];
      let currentPhase = null;
      let nextPhase = null;
      const phaseTree = getPhaseTree(cwd);
      for (const [, entry] of phaseTree) {
        const phaseNumber = entry.phaseNumber;
        if (milestone.phaseRange) {
          const num = parseInt(phaseNumber);
          if (num < milestone.phaseRange.start || num > milestone.phaseRange.end) continue;
        }
        const status = entry.summaries.length >= entry.plans.length && entry.plans.length > 0 ? "complete" : entry.plans.length > 0 ? "in_progress" : entry.hasResearch ? "researched" : "pending";
        const phaseInfo = {
          number: phaseNumber,
          name: entry.phaseName,
          directory: entry.relPath,
          status,
          plan_count: entry.plans.length,
          summary_count: entry.summaries.length,
          has_research: entry.hasResearch
        };
        phases.push(phaseInfo);
        if (!currentPhase && (status === "in_progress" || status === "researched")) {
          currentPhase = phaseInfo;
        }
        if (!nextPhase && status === "pending") {
          nextPhase = phaseInfo;
        }
      }
      let pausedAt = null;
      try {
        const state = cachedReadFile(path.join(cwd, ".planning", "STATE.md"));
        const pauseMatch = state.match(/\*\*Paused At:\*\*\s*(.+)/);
        if (pauseMatch) pausedAt = pauseMatch[1].trim();
      } catch (e) {
        debugLog("init.progress", "read failed", e);
      }
      const result = {
        // Models
        executor_model: resolveModelInternal(cwd, "gsd-executor"),
        planner_model: resolveModelInternal(cwd, "gsd-planner"),
        // Config
        commit_docs: config.commit_docs,
        // Milestone
        milestone_version: milestone.version,
        milestone_name: milestone.name,
        // Phase overview
        phases,
        phase_count: phases.length,
        completed_count: phases.filter((p) => p.status === "complete").length,
        in_progress_count: phases.filter((p) => p.status === "in_progress").length,
        // Current state
        current_phase: currentPhase,
        next_phase: nextPhase,
        paused_at: pausedAt,
        has_work_in_progress: !!currentPhase,
        // File existence
        project_exists: pathExistsInternal(cwd, ".planning/PROJECT.md"),
        roadmap_exists: pathExistsInternal(cwd, ".planning/ROADMAP.md"),
        state_exists: pathExistsInternal(cwd, ".planning/STATE.md"),
        // File paths
        state_path: ".planning/STATE.md",
        roadmap_path: ".planning/ROADMAP.md",
        project_path: ".planning/PROJECT.md",
        config_path: ".planning/config.json",
        // Session diff (what changed since last session)
        session_diff: getSessionDiffSummary(cwd),
        // Intent summary (null if no INTENT.md)
        intent_summary: null
      };
      try {
        result.intent_summary = getIntentSummary(cwd);
      } catch (e) {
        debugLog("init.progress", "intent summary failed (non-blocking)", e);
      }
      try {
        const envManifest = autoTriggerEnvScan(cwd);
        result.env_summary = formatEnvSummary(envManifest);
        result.env_languages = envManifest?.languages?.length || 0;
        result.env_stale = false;
      } catch (e) {
        debugLog("init.progress", "env scan failed (non-blocking)", e);
        result.env_summary = null;
        result.env_languages = 0;
        result.env_stale = false;
      }
      try {
        const refreshMode = process.argv.includes("--refresh");
        if (refreshMode) {
          try {
            fs.unlinkSync(path.join(cwd, ".planning", ".cache", ".analyzing"));
          } catch {
          }
        }
        const codebaseIntel = autoTriggerCodebaseIntel(cwd, { synchronous: refreshMode });
        const ctx = formatCodebaseContext(codebaseIntel, cwd);
        result.codebase_stats = ctx.codebase_stats;
        result.codebase_conventions = ctx.codebase_conventions;
        result.codebase_dependencies = ctx.codebase_dependencies;
        result.codebase_freshness = ctx.codebase_freshness;
        result.codebase_intel_exists = !!codebaseIntel;
      } catch (e) {
        debugLog("init.progress", "codebase intel failed (non-blocking)", e);
        result.codebase_stats = null;
        result.codebase_conventions = null;
        result.codebase_dependencies = null;
        result.codebase_freshness = null;
        result.codebase_intel_exists = false;
      }
      if (global._gsdCompactMode) {
        const manifestFiles = [];
        if (result.state_exists) manifestFiles.push({ path: ".planning/STATE.md", sections: ["Current Position"], required: false });
        if (result.roadmap_exists) manifestFiles.push({ path: ".planning/ROADMAP.md", sections: ["Progress"], required: false });
        const compactResult = {
          milestone_version: result.milestone_version,
          milestone_name: result.milestone_name,
          phases: result.phases,
          phase_count: result.phase_count,
          completed_count: result.completed_count,
          in_progress_count: result.in_progress_count,
          current_phase: result.current_phase,
          next_phase: result.next_phase,
          has_work_in_progress: result.has_work_in_progress,
          session_diff: result.session_diff,
          intent_summary: result.intent_summary || null,
          env_summary: result.env_summary || null,
          codebase_stats: result.codebase_stats || null,
          codebase_conventions: result.codebase_conventions || null,
          codebase_dependencies: result.codebase_dependencies || null,
          codebase_freshness: result.codebase_freshness || null,
          codebase_intel_exists: result.codebase_intel_exists || false
        };
        if (!compactResult.codebase_stats) delete compactResult.codebase_stats;
        if (!compactResult.codebase_conventions) delete compactResult.codebase_conventions;
        if (!compactResult.codebase_dependencies) delete compactResult.codebase_dependencies;
        if (!compactResult.codebase_freshness) delete compactResult.codebase_freshness;
        if (global._gsdManifestMode) {
          compactResult._manifest = { files: manifestFiles };
        }
        return output(compactResult, { formatter: formatInitProgress });
      }
      if (result.intent_summary === null) delete result.intent_summary;
      if (result.env_summary === null) {
        delete result.env_summary;
        delete result.env_languages;
        delete result.env_stale;
      }
      if (result.codebase_stats === null) {
        delete result.codebase_stats;
        delete result.codebase_intel_exists;
      }
      if (result.codebase_conventions === null) delete result.codebase_conventions;
      if (result.codebase_dependencies === null) delete result.codebase_dependencies;
      if (result.codebase_freshness === null) delete result.codebase_freshness;
      if (result.paused_at === null) delete result.paused_at;
      if (result.session_diff === null) delete result.session_diff;
      output(result, { formatter: formatInitProgress });
    }
    function cmdInitMemory(cwd, args, raw) {
      const workflowIdx = args.indexOf("--workflow");
      const workflow = workflowIdx !== -1 ? args[workflowIdx + 1] : null;
      const phaseIdx = args.indexOf("--phase");
      const phaseFilter = phaseIdx !== -1 ? args[phaseIdx + 1] : null;
      const compact = args.includes("--compact") || global._gsdCompactMode;
      const maxChars = compact ? 4e3 : 8e3;
      const trimmed = [];
      const statePath = path.join(cwd, ".planning", "STATE.md");
      const stateContent = safeReadFile(statePath);
      const position = {};
      if (stateContent) {
        const phaseMatch = stateContent.match(/\*\*Phase:?\*\*:?\s*(.+)/i);
        if (phaseMatch) position.phase = phaseMatch[1].trim();
        const nameMatch = stateContent.match(/\*\*Phase Name:?\*\*:?\s*(.+)/i);
        if (nameMatch) position.phase_name = nameMatch[1].trim();
        const planMatch = stateContent.match(/\*\*Plan:?\*\*:?\s*(.+)/i);
        if (planMatch) position.plan = planMatch[1].trim();
        const statusMatch = stateContent.match(/\*\*Status:?\*\*:?\s*(.+)/i);
        if (statusMatch) position.status = statusMatch[1].trim();
        const lastMatch = stateContent.match(/\*\*Last [Aa]ctivity:?\*\*:?\s*(.+)/i);
        if (lastMatch) position.last_activity = lastMatch[1].trim();
        const stoppedMatch = stateContent.match(/\*\*Stopped [Aa]t:?\*\*:?\s*(.+)/i);
        if (stoppedMatch) position.stopped_at = stoppedMatch[1].trim();
      }
      let bookmark = null;
      const bookmarksPath = path.join(cwd, ".planning", "memory", "bookmarks.json");
      const bookmarksContent = safeReadFile(bookmarksPath);
      if (bookmarksContent) {
        try {
          const bookmarks = JSON.parse(bookmarksContent);
          if (Array.isArray(bookmarks) && bookmarks.length > 0) {
            bookmark = bookmarks[0];
            if (bookmark.git_head && phaseFilter && String(bookmark.phase) === String(phaseFilter)) {
              try {
                const headResult = execGit(cwd, ["rev-parse", "HEAD"]);
                if (headResult.exitCode === 0 && headResult.stdout !== bookmark.git_head) {
                  const diffResult = execGit(cwd, ["diff", "--name-only", bookmark.git_head, "HEAD"]);
                  if (diffResult.exitCode === 0 && diffResult.stdout) {
                    const changedFiles = diffResult.stdout.split("\n").filter(Boolean);
                    const relevantChanges = changedFiles.filter(
                      (f) => bookmark.last_file && f === bookmark.last_file || f.startsWith(".planning/")
                    );
                    if (relevantChanges.length > 0) {
                      bookmark.drift_warning = `${relevantChanges.length} relevant file(s) changed since bookmark`;
                    } else {
                      bookmark.drift_warning = null;
                    }
                  } else {
                    bookmark.drift_warning = null;
                  }
                } else {
                  bookmark.drift_warning = null;
                }
              } catch (e) {
                debugLog("init.memory", "git drift check failed", e);
                bookmark.drift_warning = null;
              }
            } else {
              bookmark.drift_warning = null;
            }
          }
        } catch (e) {
          debugLog("init.memory", "parse bookmarks failed", e);
        }
      }
      let decisions = [];
      const decisionsPath = path.join(cwd, ".planning", "memory", "decisions.json");
      const decisionsContent = safeReadFile(decisionsPath);
      if (decisionsContent) {
        try {
          let all = JSON.parse(decisionsContent);
          if (Array.isArray(all)) {
            if (phaseFilter) {
              all = all.filter((d) => d.phase && String(d.phase) === String(phaseFilter));
            }
            const limit = compact ? 5 : 10;
            decisions = all.slice(-limit).reverse();
          }
        } catch (e) {
          debugLog("init.memory", "parse decisions failed", e);
        }
      }
      let blockers = [];
      let todos = [];
      if (stateContent) {
        const blockerMatch = stateContent.match(/###\s*Blockers\/Concerns\s*\n([\s\S]*?)(?=\n##|\n###|$)/i);
        if (blockerMatch) {
          blockers = blockerMatch[1].split("\n").filter((l) => /^\s*[-*]\s+/.test(l)).map((l) => l.replace(/^\s*[-*]\s+/, "").trim()).filter(Boolean);
        }
        const todoMatch = stateContent.match(/###\s*Pending Todos\s*\n([\s\S]*?)(?=\n##|\n###|$)/i);
        if (todoMatch) {
          todos = todoMatch[1].split("\n").filter((l) => /^\s*[-*]\s+/.test(l)).map((l) => l.replace(/^\s*[-*]\s+/, "").trim()).filter(Boolean);
        }
      }
      let lessons = [];
      const lessonsPath = path.join(cwd, ".planning", "memory", "lessons.json");
      const lessonsContent = safeReadFile(lessonsPath);
      if (lessonsContent) {
        try {
          let all = JSON.parse(lessonsContent);
          if (Array.isArray(all)) {
            if (phaseFilter) {
              all = all.filter((l) => l.phase && String(l.phase) === String(phaseFilter));
            }
            lessons = all.slice(-5);
          }
        } catch (e) {
          debugLog("init.memory", "parse lessons failed", e);
        }
      }
      const codebaseDir = path.join(cwd, ".planning", "codebase");
      let sectionsToLoad = [];
      switch (workflow) {
        case "execute-phase":
        case "execute-plan":
          sectionsToLoad = ["CONVENTIONS.md", "ARCHITECTURE.md"];
          break;
        case "plan-phase":
          sectionsToLoad = ["ARCHITECTURE.md", "STACK.md", "CONCERNS.md"];
          break;
        case "verify-work":
          sectionsToLoad = ["TESTING.md", "CONVENTIONS.md"];
          break;
        case "quick":
          sectionsToLoad = ["CONVENTIONS.md"];
          break;
        default:
          sectionsToLoad = ["ARCHITECTURE.md"];
          break;
      }
      const codebaseContent = {};
      const sectionsLoaded = [];
      for (const section of sectionsToLoad) {
        const filePath = path.join(codebaseDir, section);
        const content = safeReadFile(filePath);
        if (content) {
          const lines = content.split("\n").slice(0, 50).join("\n");
          const key = section.replace(".md", "").toLowerCase();
          codebaseContent[key] = lines;
          sectionsLoaded.push(section);
        }
      }
      const codebase = {
        sections_loaded: sectionsLoaded,
        content: codebaseContent
      };
      const result = {
        position,
        bookmark,
        decisions,
        blockers,
        todos,
        lessons,
        codebase,
        digest_lines: decisions.length + blockers.length + todos.length + lessons.length,
        workflow: workflow || null,
        trimmed
      };
      let jsonStr = JSON.stringify(result);
      if (jsonStr.length > maxChars) {
        result.codebase.content = {};
        result.codebase.sections_loaded = [];
        trimmed.push("codebase");
        jsonStr = JSON.stringify(result);
      }
      if (jsonStr.length > maxChars) {
        result.lessons = result.lessons.slice(0, 2);
        trimmed.push("lessons");
        jsonStr = JSON.stringify(result);
      }
      if (jsonStr.length > maxChars) {
        result.decisions = result.decisions.slice(0, 3);
        trimmed.push("decisions");
        jsonStr = JSON.stringify(result);
      }
      if (jsonStr.length > maxChars) {
        result.todos = result.todos.slice(0, 2);
        trimmed.push("todos");
        jsonStr = JSON.stringify(result);
      }
      result.digest_lines = result.decisions.length + result.blockers.length + result.todos.length + result.lessons.length;
      output(result, raw);
    }
    function getSessionDiffSummary(cwd) {
      try {
        const state = cachedReadFile(path.join(cwd, ".planning", "STATE.md"));
        let since = null;
        const lastMatch = state.match(/\*\*Last Activity:\*\*\s*(\d{4}-\d{2}-\d{2})/);
        if (lastMatch) since = lastMatch[1];
        const sessionMatch = state.match(/\*\*Last session:\*\*\s*(\S+)/);
        if (sessionMatch && sessionMatch[1] > (since || "")) since = sessionMatch[1].split("T")[0];
        if (!since) return null;
        if (!isValidDateString(since)) {
          debugLog("feature.sessionDiff", `invalid date string rejected: ${since}`);
          return null;
        }
        const gitResult = execGit(cwd, ["log", `--since=${since}`, "--oneline", "--no-merges", "--", ".planning/"]);
        const log = gitResult.stdout || "";
        const commits = log ? log.split("\n").filter(Boolean) : [];
        return { since, commit_count: commits.length, recent: commits.slice(0, 5) };
      } catch (e) {
        debugLog("feature.sessionDiff", "exec failed", e);
        return null;
      }
    }
    module2.exports = {
      cmdInitExecutePhase,
      cmdInitPlanPhase,
      cmdInitNewProject,
      cmdInitNewMilestone,
      cmdInitQuick,
      cmdInitResume,
      cmdInitVerifyWork,
      cmdInitPhaseOp,
      cmdInitTodos,
      cmdInitMilestoneOp,
      cmdInitMapCodebase,
      cmdInitProgress,
      cmdInitMemory,
      getSessionDiffSummary
    };
  }
});

// src/commands/misc.js
var require_misc = __commonJS({
  "src/commands/misc.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var { execSync } = require("child_process");
    var { output, error, debugLog } = require_output();
    var { loadConfig, isGitIgnored } = require_config();
    var { MODEL_PROFILES, CONFIG_SCHEMA } = require_constants();
    var { safeReadFile, cachedReadFile, normalizePhaseName, findPhaseInternal, generateSlugInternal, getArchivedPhaseDirs, getMilestoneInfo, getPhaseTree, cachedReaddirSync } = require_helpers();
    var { extractFrontmatter, reconstructFrontmatter, spliceFrontmatter } = require_frontmatter();
    var { execGit } = require_git();
    function cmdGenerateSlug(text, raw) {
      if (!text) {
        error("text required for slug generation");
      }
      const slug = text.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "");
      const result = { slug };
      output(result, raw, slug);
    }
    function cmdCurrentTimestamp(format, raw) {
      const now = /* @__PURE__ */ new Date();
      let result;
      switch (format) {
        case "date":
          result = now.toISOString().split("T")[0];
          break;
        case "filename":
          result = now.toISOString().replace(/:/g, "-").replace(/\..+/, "");
          break;
        case "full":
        default:
          result = now.toISOString();
          break;
      }
      output({ timestamp: result }, raw, result);
    }
    function cmdListTodos(cwd, area, raw) {
      const pendingDir = path.join(cwd, ".planning", "todos", "pending");
      let count = 0;
      const todos = [];
      try {
        const files = fs.readdirSync(pendingDir).filter((f) => f.endsWith(".md"));
        for (const file of files) {
          try {
            const content = fs.readFileSync(path.join(pendingDir, file), "utf-8");
            const createdMatch = content.match(/^created:\s*(.+)$/m);
            const titleMatch = content.match(/^title:\s*(.+)$/m);
            const areaMatch = content.match(/^area:\s*(.+)$/m);
            const todoArea = areaMatch ? areaMatch[1].trim() : "general";
            if (area && todoArea !== area) continue;
            count++;
            todos.push({
              file,
              created: createdMatch ? createdMatch[1].trim() : "unknown",
              title: titleMatch ? titleMatch[1].trim() : "Untitled",
              area: todoArea,
              path: path.join(".planning", "todos", "pending", file)
            });
          } catch (e) {
            debugLog("feature.listTodos", "read todo file failed", e);
          }
        }
      } catch (e) {
        debugLog("feature.listTodos", "read pending dir failed", e);
      }
      const result = { count, todos };
      output(result, raw, count.toString());
    }
    function cmdVerifyPathExists(cwd, targetPath, raw) {
      if (!targetPath) {
        error("path required for verification");
      }
      const fullPath = path.isAbsolute(targetPath) ? targetPath : path.join(cwd, targetPath);
      try {
        const stats = fs.statSync(fullPath);
        const type = stats.isDirectory() ? "directory" : stats.isFile() ? "file" : "other";
        const result = { exists: true, type };
        output(result, raw, "true");
      } catch (e) {
        debugLog("file.stat", "stat failed", e);
        const result = { exists: false, type: null };
        output(result, raw, "false");
      }
    }
    function cmdConfigEnsureSection(cwd, raw) {
      const configPath = path.join(cwd, ".planning", "config.json");
      const planningDir = path.join(cwd, ".planning");
      try {
        if (!fs.existsSync(planningDir)) {
          fs.mkdirSync(planningDir, { recursive: true });
        }
      } catch (err) {
        debugLog("config.ensure", "mkdir failed", err);
        error("Failed to create .planning directory: " + err.message);
      }
      if (fs.existsSync(configPath)) {
        const result = { created: false, reason: "already_exists" };
        output(result, raw, "exists");
        return;
      }
      const homedir = require("os").homedir();
      const braveKeyFile = path.join(homedir, ".gsd", "brave_api_key");
      const hasBraveSearch = !!(process.env.BRAVE_API_KEY || fs.existsSync(braveKeyFile));
      const globalDefaultsPath = path.join(homedir, ".gsd", "defaults.json");
      let userDefaults = {};
      try {
        if (fs.existsSync(globalDefaultsPath)) {
          userDefaults = JSON.parse(fs.readFileSync(globalDefaultsPath, "utf-8"));
        }
      } catch (err) {
        debugLog("config.ensure", "read failed", err);
      }
      const hardcoded = {};
      for (const [key, def] of Object.entries(CONFIG_SCHEMA)) {
        if (def.nested) {
          if (!hardcoded[def.nested.section]) hardcoded[def.nested.section] = {};
          hardcoded[def.nested.section][def.nested.field] = def.default;
        } else {
          hardcoded[key] = def.default;
        }
      }
      hardcoded.brave_search = hasBraveSearch;
      const defaults = {
        ...hardcoded,
        ...userDefaults,
        workflow: { ...hardcoded.workflow, ...userDefaults.workflow || {} }
      };
      try {
        fs.writeFileSync(configPath, JSON.stringify(defaults, null, 2), "utf-8");
        const result = { created: true, path: ".planning/config.json" };
        output(result, raw, "created");
      } catch (err) {
        debugLog("config.ensure", "write failed", err);
        error("Failed to create config.json: " + err.message);
      }
    }
    function cmdConfigSet(cwd, keyPath, value, raw) {
      const configPath = path.join(cwd, ".planning", "config.json");
      if (!keyPath) {
        error("Usage: config-set <key.path> <value>");
      }
      let parsedValue = value;
      if (value === "true") parsedValue = true;
      else if (value === "false") parsedValue = false;
      else if (!isNaN(value) && value !== "") parsedValue = Number(value);
      let config = {};
      try {
        if (fs.existsSync(configPath)) {
          config = JSON.parse(fs.readFileSync(configPath, "utf-8"));
        }
      } catch (err) {
        debugLog("config.set", "read failed", err);
        error("Failed to read config.json: " + err.message);
      }
      const keys = keyPath.split(".");
      let current = config;
      for (let i = 0; i < keys.length - 1; i++) {
        const key = keys[i];
        if (current[key] === void 0 || typeof current[key] !== "object") {
          current[key] = {};
        }
        current = current[key];
      }
      current[keys[keys.length - 1]] = parsedValue;
      try {
        fs.writeFileSync(configPath, JSON.stringify(config, null, 2), "utf-8");
        const result = { updated: true, key: keyPath, value: parsedValue };
        output(result, raw, `${keyPath}=${parsedValue}`);
      } catch (err) {
        debugLog("config.set", "write failed", err);
        error("Failed to write config.json: " + err.message);
      }
    }
    function cmdConfigGet(cwd, keyPath, raw) {
      const configPath = path.join(cwd, ".planning", "config.json");
      if (!keyPath) {
        error("Usage: config-get <key.path>");
      }
      let config = {};
      try {
        if (fs.existsSync(configPath)) {
          config = JSON.parse(fs.readFileSync(configPath, "utf-8"));
        } else {
          error("No config.json found at " + configPath);
        }
      } catch (err) {
        debugLog("config.get", "read failed", err);
        if (err.message.startsWith("No config.json")) throw err;
        error("Failed to read config.json: " + err.message);
      }
      const keys = keyPath.split(".");
      let current = config;
      for (const key of keys) {
        if (current === void 0 || current === null || typeof current !== "object") {
          error(`Key not found: ${keyPath}`);
        }
        current = current[key];
      }
      if (current === void 0) {
        error(`Key not found: ${keyPath}`);
      }
      output(current, raw, String(current));
    }
    function cmdConfigMigrate(cwd, raw) {
      const configPath = path.join(cwd, ".planning", "config.json");
      const backupPath = configPath + ".bak";
      let config = {};
      try {
        if (fs.existsSync(configPath)) {
          config = JSON.parse(fs.readFileSync(configPath, "utf-8"));
        } else {
          error("No config.json found at " + configPath + ". Run config-ensure-section first.");
        }
      } catch (err) {
        debugLog("config.migrate", "read failed", err);
        if (err.message.startsWith("No config.json")) throw err;
        error("Failed to read config.json: " + err.message);
      }
      const migratedKeys = [];
      const unchangedKeys = [];
      for (const [key, def] of Object.entries(CONFIG_SCHEMA)) {
        if (def.nested) {
          const section = def.nested.section;
          const field = def.nested.field;
          if (config[section] && config[section][field] !== void 0) {
            unchangedKeys.push(`${section}.${field}`);
          } else {
            if (!config[section] || typeof config[section] !== "object") {
              config[section] = {};
            }
            config[section][field] = def.default;
            migratedKeys.push(`${section}.${field}`);
          }
        } else {
          if (config[key] !== void 0) {
            unchangedKeys.push(key);
          } else {
            config[key] = def.default;
            migratedKeys.push(key);
          }
        }
      }
      if (migratedKeys.length > 0) {
        try {
          fs.copyFileSync(configPath, backupPath);
        } catch (err) {
          debugLog("config.migrate", "backup failed", err);
          error("Failed to create backup: " + err.message);
        }
        try {
          fs.writeFileSync(configPath, JSON.stringify(config, null, 2), "utf-8");
        } catch (err) {
          debugLog("config.migrate", "write failed", err);
          error("Failed to write config.json: " + err.message);
        }
      }
      const result = {
        migrated_keys: migratedKeys,
        unchanged_keys: unchangedKeys,
        config_path: ".planning/config.json",
        backup_path: migratedKeys.length > 0 ? ".planning/config.json.bak" : null
      };
      output(result, raw);
    }
    function cmdHistoryDigest(cwd, options, raw) {
      const limit = options.limit || null;
      const phasesFilter = options.phases || null;
      const compact = options.compact || false;
      const phasesDir = path.join(cwd, ".planning", "phases");
      const digest = { phases: {}, decisions: [], tech_stack: /* @__PURE__ */ new Set() };
      const allPhaseDirs = [];
      const archived = getArchivedPhaseDirs(cwd);
      for (const a of archived) {
        allPhaseDirs.push({ name: a.name, fullPath: a.fullPath, milestone: a.milestone });
      }
      if (fs.existsSync(phasesDir)) {
        try {
          const currentDirs = fs.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name).sort();
          for (const dir of currentDirs) {
            allPhaseDirs.push({ name: dir, fullPath: path.join(phasesDir, dir), milestone: null });
          }
        } catch (e) {
          debugLog("feature.historyDigest", "readdir failed", e);
        }
      }
      if (allPhaseDirs.length === 0) {
        digest.tech_stack = [];
        output(digest, raw);
        return;
      }
      try {
        for (const { name: dir, fullPath: dirPath } of allPhaseDirs) {
          const summaries = fs.readdirSync(dirPath).filter((f) => f.endsWith("-SUMMARY.md") || f === "SUMMARY.md");
          for (const summary of summaries) {
            try {
              const content = cachedReadFile(path.join(dirPath, summary));
              if (!content) continue;
              const fm = extractFrontmatter(content);
              const phaseNum = fm.phase || dir.split("-")[0];
              if (!digest.phases[phaseNum]) {
                digest.phases[phaseNum] = {
                  name: fm.name || dir.split("-").slice(1).join(" ") || "Unknown",
                  provides: /* @__PURE__ */ new Set(),
                  affects: /* @__PURE__ */ new Set(),
                  patterns: /* @__PURE__ */ new Set()
                };
              }
              if (fm["dependency-graph"] && fm["dependency-graph"].provides) {
                fm["dependency-graph"].provides.forEach((p) => digest.phases[phaseNum].provides.add(p));
              } else if (fm.provides) {
                fm.provides.forEach((p) => digest.phases[phaseNum].provides.add(p));
              }
              if (fm["dependency-graph"] && fm["dependency-graph"].affects) {
                fm["dependency-graph"].affects.forEach((a) => digest.phases[phaseNum].affects.add(a));
              }
              if (fm["patterns-established"]) {
                fm["patterns-established"].forEach((p) => digest.phases[phaseNum].patterns.add(p));
              }
              if (fm["key-decisions"]) {
                fm["key-decisions"].forEach((d) => {
                  digest.decisions.push({ phase: phaseNum, decision: d });
                });
              }
              if (fm["tech-stack"] && fm["tech-stack"].added) {
                fm["tech-stack"].added.forEach((t) => digest.tech_stack.add(typeof t === "string" ? t : t.name));
              }
            } catch (e) {
              debugLog("feature.historyDigest", "skip malformed summary", e);
            }
          }
        }
        Object.keys(digest.phases).forEach((p) => {
          digest.phases[p].provides = [...digest.phases[p].provides];
          digest.phases[p].affects = [...digest.phases[p].affects];
          digest.phases[p].patterns = [...digest.phases[p].patterns];
        });
        digest.tech_stack = [...digest.tech_stack];
        if (phasesFilter) {
          const allowed = new Set(phasesFilter);
          digest.phases = Object.fromEntries(Object.entries(digest.phases).filter(([k]) => allowed.has(k)));
          digest.decisions = digest.decisions.filter((d) => allowed.has(String(d.phase)));
        }
        if (limit) {
          const kept = new Set(Object.keys(digest.phases).sort((a, b) => parseFloat(b) - parseFloat(a)).slice(0, limit));
          digest.phases = Object.fromEntries(Object.entries(digest.phases).filter(([k]) => kept.has(k)));
          digest.decisions = digest.decisions.filter((d) => kept.has(String(d.phase)));
        }
        if (compact) {
          delete digest.decisions;
          delete digest.tech_stack;
        }
        output(digest, raw);
      } catch (e) {
        debugLog("feature.historyDigest", "digest generation failed", e);
        error("Failed to generate history digest: " + e.message);
      }
    }
    function cmdResolveModel(cwd, agentType, raw) {
      if (!agentType) {
        error("agent-type required");
      }
      const config = loadConfig(cwd);
      const profile = config.model_profile || "balanced";
      const agentModels = MODEL_PROFILES[agentType];
      if (!agentModels) {
        const result2 = { model: "sonnet", profile, unknown_agent: true };
        output(result2, raw, "sonnet");
        return;
      }
      const resolved = agentModels[profile] || agentModels["balanced"] || "sonnet";
      const model = resolved === "opus" ? "inherit" : resolved;
      const result = { model, profile };
      output(result, raw, model);
    }
    function cmdFindPhase(cwd, phase, raw) {
      if (!phase) {
        error("phase identifier required");
      }
      const phasesDir = path.join(cwd, ".planning", "phases");
      const normalized = normalizePhaseName(phase);
      const notFound = { found: false, directory: null, phase_number: null, phase_name: null, plans: [], summaries: [] };
      try {
        const entries = fs.readdirSync(phasesDir, { withFileTypes: true });
        const dirs = entries.filter((e) => e.isDirectory()).map((e) => e.name).sort();
        const match = dirs.find((d) => d.startsWith(normalized));
        if (!match) {
          output(notFound, raw, "");
          return;
        }
        const dirMatch = match.match(/^(\d+(?:\.\d+)?)-?(.*)/);
        const phaseNumber = dirMatch ? dirMatch[1] : normalized;
        const phaseName = dirMatch && dirMatch[2] ? dirMatch[2] : null;
        const phaseDir = path.join(phasesDir, match);
        const phaseFiles = fs.readdirSync(phaseDir);
        const plans = phaseFiles.filter((f) => f.endsWith("-PLAN.md") || f === "PLAN.md").sort();
        const summaries = phaseFiles.filter((f) => f.endsWith("-SUMMARY.md") || f === "SUMMARY.md").sort();
        const result = {
          found: true,
          directory: path.join(".planning", "phases", match),
          phase_number: phaseNumber,
          phase_name: phaseName,
          plans,
          summaries
        };
        output(result, raw, result.directory);
      } catch (e) {
        debugLog("phase.find", "readdir failed", e);
        output(notFound, raw, "");
      }
    }
    function preCommitChecks(cwd, force) {
      if (force) return { passed: true, failures: [] };
      const failures = [];
      const shallowResult = execGit(cwd, ["rev-parse", "--is-shallow-repository"]);
      if (shallowResult.exitCode === 0 && shallowResult.stdout === "true") {
        failures.push({
          check: "shallow_clone",
          message: "Shallow clone detected.",
          fix: "git fetch --unshallow"
        });
      }
      const symbolicResult = execGit(cwd, ["symbolic-ref", "-q", "HEAD"]);
      if (symbolicResult.exitCode !== 0) {
        failures.push({
          check: "detached_head",
          message: "Detached HEAD.",
          fix: "git checkout <branch>"
        });
      }
      let gitDir = cwd;
      try {
        const gitDirResult = execGit(cwd, ["rev-parse", "--git-dir"]);
        if (gitDirResult.exitCode === 0) {
          gitDir = path.resolve(cwd, gitDirResult.stdout);
        }
      } catch (e) {
        debugLog("preCommitChecks", "git-dir resolution failed", e);
      }
      if (fs.existsSync(path.join(gitDir, "rebase-merge")) || fs.existsSync(path.join(gitDir, "rebase-apply"))) {
        failures.push({
          check: "active_rebase",
          message: "Rebase in progress.",
          fix: "git rebase --continue or git rebase --abort"
        });
      }
      const statusResult = execGit(cwd, ["status", "--porcelain"]);
      if (statusResult.exitCode === 0 && statusResult.stdout) {
        const dirtyNonPlanning = statusResult.stdout.split("\n").filter((line) => {
          if (!line.trim()) return false;
          const filePath = line.slice(3).trim();
          const actualPath = filePath.includes(" -> ") ? filePath.split(" -> ")[1] : filePath;
          return !actualPath.startsWith(".planning/") && !actualPath.startsWith(".planning\\");
        });
        if (dirtyNonPlanning.length > 0) {
          failures.push({
            check: "dirty_tree",
            message: `Dirty working tree (${dirtyNonPlanning.length} files).`,
            fix: "git stash or commit changes first"
          });
        }
      }
      return { passed: failures.length === 0, failures };
    }
    function cmdCommit(cwd, message, files, raw, amend, force, agentType, tddPhase) {
      if (!message && !amend) {
        error("commit message required");
      }
      const config = loadConfig(cwd);
      if (!config.commit_docs) {
        const result2 = { committed: false, hash: null, reason: "skipped_commit_docs_false" };
        output(result2, raw, "skipped");
        return;
      }
      if (isGitIgnored(cwd, ".planning")) {
        const result2 = { committed: false, hash: null, reason: "skipped_gitignored" };
        output(result2, raw, "skipped");
        return;
      }
      const checks = preCommitChecks(cwd, force);
      if (!checks.passed) {
        process.exitCode = 2;
        const result2 = { committed: false, hash: null, reason: "pre_commit_blocked", failures: checks.failures };
        output(result2, raw, "blocked");
        return;
      }
      const filesToStage = files && files.length > 0 ? files : [".planning/"];
      for (const file of filesToStage) {
        execGit(cwd, ["add", file]);
      }
      const commitArgs = amend ? ["commit", "--amend", "--no-edit"] : ["commit", "-m", message];
      if (agentType) {
        commitArgs.push("--trailer", `Agent-Type: ${agentType}`);
      }
      if (tddPhase && ["red", "green", "refactor"].includes(tddPhase)) {
        commitArgs.push("--trailer", `GSD-Phase: ${tddPhase}`);
      }
      const commitResult = execGit(cwd, commitArgs);
      if (commitResult.exitCode !== 0) {
        if (commitResult.stdout.includes("nothing to commit") || commitResult.stderr.includes("nothing to commit")) {
          const result3 = { committed: false, hash: null, reason: "nothing_to_commit" };
          output(result3, raw, "nothing");
          return;
        }
        const result2 = { committed: false, hash: null, reason: "nothing_to_commit", error: commitResult.stderr };
        output(result2, raw, "nothing");
        return;
      }
      const hashResult = execGit(cwd, ["rev-parse", "--short", "HEAD"]);
      const hash = hashResult.exitCode === 0 ? hashResult.stdout : null;
      const result = { committed: true, hash, reason: "committed", agent_type: agentType || null, tdd_phase: tddPhase || null };
      output(result, raw, hash || "committed");
    }
    function cmdVerifySummary(cwd, summaryPath, checkFileCount, raw) {
      if (!summaryPath) {
        error("summary-path required");
      }
      const fullPath = path.join(cwd, summaryPath);
      const checkCount = checkFileCount || 2;
      if (!fs.existsSync(fullPath)) {
        const result2 = {
          passed: false,
          checks: {
            summary_exists: false,
            files_created: { checked: 0, found: 0, missing: [] },
            commits_exist: false,
            self_check: "not_found"
          },
          errors: ["SUMMARY.md not found"]
        };
        output(result2, raw, "failed");
        return;
      }
      const content = fs.readFileSync(fullPath, "utf-8");
      const errors = [];
      const mentionedFiles = /* @__PURE__ */ new Set();
      const patterns = [
        /`([^`]+\.[a-zA-Z]+)`/g,
        /(?:Created|Modified|Added|Updated|Edited):\s*`?([^\s`]+\.[a-zA-Z]+)`?/gi
      ];
      for (const pattern of patterns) {
        let m;
        while ((m = pattern.exec(content)) !== null) {
          const filePath = m[1];
          if (filePath && !filePath.startsWith("http") && filePath.includes("/")) {
            mentionedFiles.add(filePath);
          }
        }
      }
      const filesToCheck = Array.from(mentionedFiles).slice(0, checkCount);
      const missing = [];
      for (const file of filesToCheck) {
        if (!fs.existsSync(path.join(cwd, file))) {
          missing.push(file);
        }
      }
      const commitHashPattern = /\b[0-9a-f]{7,40}\b/g;
      const hashes = content.match(commitHashPattern) || [];
      let commitsExist = false;
      if (hashes.length > 0) {
        for (const hash of hashes.slice(0, 3)) {
          const result2 = execGit(cwd, ["cat-file", "-t", hash]);
          if (result2.exitCode === 0 && result2.stdout === "commit") {
            commitsExist = true;
            break;
          }
        }
      }
      let selfCheck = "not_found";
      const selfCheckPattern = /##\s*(?:Self[- ]?Check|Verification|Quality Check)/i;
      if (selfCheckPattern.test(content)) {
        const passPattern = /(?:all\s+)?(?:pass|âœ“|âœ…|complete|succeeded)/i;
        const failPattern = /(?:fail|âœ—|âŒ|incomplete|blocked)/i;
        const checkSection = content.slice(content.search(selfCheckPattern));
        if (failPattern.test(checkSection)) {
          selfCheck = "failed";
        } else if (passPattern.test(checkSection)) {
          selfCheck = "passed";
        }
      }
      if (missing.length > 0) errors.push("Missing files: " + missing.join(", "));
      if (!commitsExist && hashes.length > 0) errors.push("Referenced commit hashes not found in git history");
      if (selfCheck === "failed") errors.push("Self-check section indicates failure");
      const checks = {
        summary_exists: true,
        files_created: { checked: filesToCheck.length, found: filesToCheck.length - missing.length, missing },
        commits_exist: commitsExist,
        self_check: selfCheck
      };
      const passed = missing.length === 0 && selfCheck !== "failed";
      const result = { passed, checks, errors };
      output(result, raw, passed ? "passed" : "failed");
    }
    function cmdTemplateSelect(cwd, planPath, raw) {
      if (!planPath) {
        error("plan-path required");
      }
      try {
        const fullPath = path.join(cwd, planPath);
        const content = fs.readFileSync(fullPath, "utf-8");
        const taskMatch = content.match(/###\s*Task\s*\d+/g) || [];
        const taskCount = taskMatch.length;
        const decisionMatch = content.match(/decision/gi) || [];
        const hasDecisions = decisionMatch.length > 0;
        const fileMentions = /* @__PURE__ */ new Set();
        const filePattern = /`([^`]+\.[a-zA-Z]+)`/g;
        let m;
        while ((m = filePattern.exec(content)) !== null) {
          if (m[1].includes("/") && !m[1].startsWith("http")) {
            fileMentions.add(m[1]);
          }
        }
        const fileCount = fileMentions.size;
        let template = "templates/summary-standard.md";
        let type = "standard";
        if (taskCount <= 2 && fileCount <= 3 && !hasDecisions) {
          template = "templates/summary-minimal.md";
          type = "minimal";
        } else if (hasDecisions || fileCount > 6 || taskCount > 5) {
          template = "templates/summary-complex.md";
          type = "complex";
        }
        const result = { template, type, taskCount, fileCount, hasDecisions };
        output(result, raw, template);
      } catch (e) {
        debugLog("template.pick", "template selection failed", e);
        output({ template: "templates/summary-standard.md", type: "standard", error: e.message }, raw, "templates/summary-standard.md");
      }
    }
    function cmdTemplateFill(cwd, templateType, options, raw) {
      if (!templateType) {
        error("template type required: summary, plan, or verification");
      }
      if (!options.phase) {
        error("--phase required");
      }
      const phaseInfo = findPhaseInternal(cwd, options.phase);
      if (!phaseInfo || !phaseInfo.found) {
        output({ error: "Phase not found", phase: options.phase }, raw);
        return;
      }
      const padded = normalizePhaseName(options.phase);
      const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      const phaseName = options.name || phaseInfo.phase_name || "Unnamed";
      const phaseSlug = phaseInfo.phase_slug || generateSlugInternal(phaseName);
      const phaseId = `${padded}-${phaseSlug}`;
      const planNum = (options.plan || "01").padStart(2, "0");
      const fields = options.fields || {};
      let frontmatter, body, fileName;
      switch (templateType) {
        case "summary": {
          frontmatter = {
            phase: phaseId,
            plan: planNum,
            subsystem: "[primary category]",
            tags: [],
            provides: [],
            affects: [],
            "tech-stack": { added: [], patterns: [] },
            "key-files": { created: [], modified: [] },
            "key-decisions": [],
            "patterns-established": [],
            duration: "[X]min",
            completed: today,
            ...fields
          };
          body = [
            `# Phase ${options.phase}: ${phaseName} Summary`,
            "",
            "**[Substantive one-liner describing outcome]**",
            "",
            "## Performance",
            "- **Duration:** [time]",
            "- **Tasks:** [count completed]",
            "- **Files modified:** [count]",
            "",
            "## Accomplishments",
            "- [Key outcome 1]",
            "- [Key outcome 2]",
            "",
            "## Task Commits",
            "1. **Task 1: [task name]** - `hash`",
            "",
            "## Files Created/Modified",
            "- `path/to/file.ts` - What it does",
            "",
            "## Decisions & Deviations",
            '[Key decisions or "None - followed plan as specified"]',
            "",
            "## Next Phase Readiness",
            "[What's ready for next phase]"
          ].join("\n");
          fileName = `${padded}-${planNum}-SUMMARY.md`;
          break;
        }
        case "plan": {
          const planType = options.type || "execute";
          const wave = parseInt(options.wave) || 1;
          frontmatter = {
            phase: phaseId,
            plan: planNum,
            type: planType,
            wave,
            depends_on: [],
            files_modified: [],
            autonomous: true,
            user_setup: [],
            must_haves: { truths: [], artifacts: [], key_links: [] },
            ...fields
          };
          body = [
            `# Phase ${options.phase} Plan ${planNum}: [Title]`,
            "",
            "## Objective",
            "- **What:** [What this plan builds]",
            "- **Why:** [Why it matters for the phase goal]",
            "- **Output:** [Concrete deliverable]",
            "",
            "## Context",
            "@.planning/PROJECT.md",
            "@.planning/ROADMAP.md",
            "@.planning/STATE.md",
            "",
            "## Tasks",
            "",
            '<task type="code">',
            "  <name>[Task name]</name>",
            "  <files>[file paths]</files>",
            "  <action>[What to do]</action>",
            "  <verify>[How to verify]</verify>",
            "  <done>[Definition of done]</done>",
            "</task>",
            "",
            "## Verification",
            "[How to verify this plan achieved its objective]",
            "",
            "## Success Criteria",
            "- [ ] [Criterion 1]",
            "- [ ] [Criterion 2]"
          ].join("\n");
          fileName = `${padded}-${planNum}-PLAN.md`;
          break;
        }
        case "verification": {
          frontmatter = {
            phase: phaseId,
            verified: (/* @__PURE__ */ new Date()).toISOString(),
            status: "pending",
            score: "0/0 must-haves verified",
            ...fields
          };
          body = [
            `# Phase ${options.phase}: ${phaseName} \u2014 Verification`,
            "",
            "## Observable Truths",
            "| # | Truth | Status | Evidence |",
            "|---|-------|--------|----------|",
            "| 1 | [Truth] | pending | |",
            "",
            "## Required Artifacts",
            "| Artifact | Expected | Status | Details |",
            "|----------|----------|--------|---------|",
            "| [path] | [what] | pending | |",
            "",
            "## Key Link Verification",
            "| From | To | Via | Status | Details |",
            "|------|----|----|--------|---------|",
            "| [source] | [target] | [connection] | pending | |",
            "",
            "## Requirements Coverage",
            "| Requirement | Status | Blocking Issue |",
            "|-------------|--------|----------------|",
            "| [req] | pending | |",
            "",
            "## Result",
            "[Pending verification]"
          ].join("\n");
          fileName = `${padded}-VERIFICATION.md`;
          break;
        }
        default:
          error(`Unknown template type: ${templateType}. Available: summary, plan, verification`);
          return;
      }
      const fullContent = `---
${reconstructFrontmatter(frontmatter)}
---

${body}
`;
      const outPath = path.join(cwd, phaseInfo.directory, fileName);
      if (fs.existsSync(outPath)) {
        output({ error: "File already exists", path: path.relative(cwd, outPath) }, raw);
        return;
      }
      fs.writeFileSync(outPath, fullContent, "utf-8");
      const relPath = path.relative(cwd, outPath);
      output({ created: true, path: relPath, template: templateType }, raw, relPath);
    }
    function cmdPhasePlanIndex(cwd, phase, raw) {
      if (!phase) {
        error("phase required for phase-plan-index");
      }
      const phasesDir = path.join(cwd, ".planning", "phases");
      const normalized = normalizePhaseName(phase);
      let phaseDir = null;
      let phaseDirName = null;
      try {
        const entries = fs.readdirSync(phasesDir, { withFileTypes: true });
        const dirs = entries.filter((e) => e.isDirectory()).map((e) => e.name).sort();
        const match = dirs.find((d) => d.startsWith(normalized));
        if (match) {
          phaseDir = path.join(phasesDir, match);
          phaseDirName = match;
        }
      } catch (e) {
        debugLog("phase.planIndex", "readdir failed", e);
      }
      if (!phaseDir) {
        output({ phase: normalized, error: "Phase not found", plans: [], waves: {}, incomplete: [], has_checkpoints: false }, raw);
        return;
      }
      const phaseFiles = fs.readdirSync(phaseDir);
      const planFiles = phaseFiles.filter((f) => f.endsWith("-PLAN.md") || f === "PLAN.md").sort();
      const summaryFiles = phaseFiles.filter((f) => f.endsWith("-SUMMARY.md") || f === "SUMMARY.md");
      const completedPlanIds = new Set(
        summaryFiles.map((s) => s.replace("-SUMMARY.md", "").replace("SUMMARY.md", ""))
      );
      const plans = [];
      const waves = {};
      const incomplete = [];
      let hasCheckpoints = false;
      for (const planFile of planFiles) {
        const planId = planFile.replace("-PLAN.md", "").replace("PLAN.md", "");
        const planPath = path.join(phaseDir, planFile);
        const content = fs.readFileSync(planPath, "utf-8");
        const fm = extractFrontmatter(content);
        const taskMatches = content.match(/##\s*Task\s*\d+/gi) || [];
        const taskCount = taskMatches.length;
        const wave = parseInt(fm.wave, 10) || 1;
        let autonomous = true;
        if (fm.autonomous !== void 0) {
          autonomous = fm.autonomous === "true" || fm.autonomous === true;
        }
        if (!autonomous) {
          hasCheckpoints = true;
        }
        let filesModified = [];
        if (fm["files-modified"]) {
          filesModified = Array.isArray(fm["files-modified"]) ? fm["files-modified"] : [fm["files-modified"]];
        }
        const hasSummary = completedPlanIds.has(planId);
        if (!hasSummary) {
          incomplete.push(planId);
        }
        const plan = {
          id: planId,
          wave,
          autonomous,
          objective: fm.objective || null,
          files_modified: filesModified,
          task_count: taskCount,
          has_summary: hasSummary
        };
        plans.push(plan);
        const waveKey = String(wave);
        if (!waves[waveKey]) {
          waves[waveKey] = [];
        }
        waves[waveKey].push(planId);
      }
      const result = {
        phase: normalized,
        plans,
        waves,
        incomplete,
        has_checkpoints: hasCheckpoints
      };
      output(result, raw);
    }
    function cmdStateSnapshot(cwd, raw) {
      const statePath = path.join(cwd, ".planning", "STATE.md");
      if (!fs.existsSync(statePath)) {
        output({ error: "STATE.md not found" }, raw);
        return;
      }
      const content = fs.readFileSync(statePath, "utf-8");
      const extractField = (fieldName) => {
        const pattern = new RegExp(`\\*\\*${fieldName}:\\*\\*\\s*(.+)`, "i");
        const match = content.match(pattern);
        return match ? match[1].trim() : null;
      };
      const currentPhase = extractField("Current Phase");
      const currentPhaseName = extractField("Current Phase Name");
      const totalPhasesRaw = extractField("Total Phases");
      const currentPlan = extractField("Current Plan");
      const totalPlansRaw = extractField("Total Plans in Phase");
      const status = extractField("Status");
      const progressRaw = extractField("Progress");
      const lastActivity = extractField("Last Activity");
      const lastActivityDesc = extractField("Last Activity Description");
      const pausedAt = extractField("Paused At");
      const totalPhases = totalPhasesRaw ? parseInt(totalPhasesRaw, 10) : null;
      const totalPlansInPhase = totalPlansRaw ? parseInt(totalPlansRaw, 10) : null;
      const progressPercent = progressRaw ? parseInt(progressRaw.replace("%", ""), 10) : null;
      const decisions = [];
      const decisionsMatch = content.match(/##\s*Decisions Made[\s\S]*?\n\|[^\n]+\n\|[-|\s]+\n([\s\S]*?)(?=\n##|\n$|$)/i);
      if (decisionsMatch) {
        const tableBody = decisionsMatch[1];
        const rows = tableBody.trim().split("\n").filter((r) => r.includes("|"));
        for (const row of rows) {
          const cells = row.split("|").map((c) => c.trim()).filter(Boolean);
          if (cells.length >= 3) {
            decisions.push({
              phase: cells[0],
              summary: cells[1],
              rationale: cells[2]
            });
          }
        }
      }
      const blockers = [];
      const blockersMatch = content.match(/##\s*Blockers\s*\n([\s\S]*?)(?=\n##|$)/i);
      if (blockersMatch) {
        const blockersSection = blockersMatch[1];
        const items = blockersSection.match(/^-\s+(.+)$/gm) || [];
        for (const item of items) {
          blockers.push(item.replace(/^-\s+/, "").trim());
        }
      }
      const session = {
        last_date: null,
        stopped_at: null,
        resume_file: null
      };
      const sessionMatch = content.match(/##\s*Session\s*\n([\s\S]*?)(?=\n##|$)/i);
      if (sessionMatch) {
        const sessionSection = sessionMatch[1];
        const lastDateMatch = sessionSection.match(/\*\*Last Date:\*\*\s*(.+)/i);
        const stoppedAtMatch = sessionSection.match(/\*\*Stopped At:\*\*\s*(.+)/i);
        const resumeFileMatch = sessionSection.match(/\*\*Resume File:\*\*\s*(.+)/i);
        if (lastDateMatch) session.last_date = lastDateMatch[1].trim();
        if (stoppedAtMatch) session.stopped_at = stoppedAtMatch[1].trim();
        if (resumeFileMatch) session.resume_file = resumeFileMatch[1].trim();
      }
      const result = {
        current_phase: currentPhase,
        current_phase_name: currentPhaseName,
        total_phases: totalPhases,
        current_plan: currentPlan,
        total_plans_in_phase: totalPlansInPhase,
        status,
        progress_percent: progressPercent,
        last_activity: lastActivity,
        last_activity_desc: lastActivityDesc,
        decisions,
        blockers,
        paused_at: pausedAt,
        session
      };
      output(result, raw);
    }
    function cmdSummaryExtract(cwd, summaryPath, fields, raw) {
      if (!summaryPath) {
        error("summary-path required for summary-extract");
      }
      const fullPath = path.join(cwd, summaryPath);
      if (!fs.existsSync(fullPath)) {
        output({ error: "File not found", path: summaryPath }, raw);
        return;
      }
      const content = fs.readFileSync(fullPath, "utf-8");
      const fm = extractFrontmatter(content);
      const parseDecisions = (decisionsList) => {
        if (!decisionsList || !Array.isArray(decisionsList)) return [];
        return decisionsList.map((d) => {
          const colonIdx = d.indexOf(":");
          if (colonIdx > 0) {
            return {
              summary: d.substring(0, colonIdx).trim(),
              rationale: d.substring(colonIdx + 1).trim()
            };
          }
          return { summary: d, rationale: null };
        });
      };
      const fullResult = {
        path: summaryPath,
        one_liner: fm["one-liner"] || null,
        key_files: fm["key-files"] || [],
        tech_added: fm["tech-stack"] && fm["tech-stack"].added || [],
        patterns: fm["patterns-established"] || [],
        decisions: parseDecisions(fm["key-decisions"])
      };
      if (fields && fields.length > 0) {
        const filtered = { path: summaryPath };
        for (const field of fields) {
          if (fullResult[field] !== void 0) {
            filtered[field] = fullResult[field];
          }
        }
        output(filtered, raw);
        return;
      }
      output(fullResult, raw);
    }
    async function cmdWebsearch(query, options, raw) {
      const apiKey = process.env.BRAVE_API_KEY;
      if (!apiKey) {
        output({ available: false, reason: "BRAVE_API_KEY not set" }, raw, "");
        return;
      }
      if (!query) {
        output({ available: false, error: "Query required" }, raw, "");
        return;
      }
      const params = new URLSearchParams({
        q: query,
        count: String(options.limit || 10),
        country: "us",
        search_lang: "en",
        text_decorations: "false"
      });
      if (options.freshness) {
        params.set("freshness", options.freshness);
      }
      try {
        const response = await fetch(
          `https://api.search.brave.com/res/v1/web/search?${params}`,
          {
            headers: {
              "Accept": "application/json",
              "X-Subscription-Token": apiKey
            }
          }
        );
        if (!response.ok) {
          output({ available: false, error: `API error: ${response.status}` }, raw, "");
          return;
        }
        const data = await response.json();
        const results = (data.web?.results || []).map((r) => ({
          title: r.title,
          url: r.url,
          description: r.description,
          age: r.age || null
        }));
        output({
          available: true,
          query,
          count: results.length,
          results
        }, raw, results.map((r) => `${r.title}
${r.url}
${r.description}`).join("\n\n"));
      } catch (err) {
        debugLog("feature.webSearch", "search request failed", err);
        output({ available: false, error: err.message }, raw, "");
      }
    }
    function cmdFrontmatterGet(cwd, filePath, field, raw) {
      if (!filePath) {
        error("file path required");
      }
      const fullPath = path.isAbsolute(filePath) ? filePath : path.join(cwd, filePath);
      const content = safeReadFile(fullPath);
      if (!content) {
        output({ error: "File not found", path: filePath }, raw);
        return;
      }
      const fm = extractFrontmatter(content);
      if (field) {
        const value = fm[field];
        if (value === void 0) {
          output({ error: "Field not found", field }, raw);
          return;
        }
        output({ [field]: value }, raw, JSON.stringify(value));
      } else {
        output(fm, raw);
      }
    }
    function cmdFrontmatterSet(cwd, filePath, field, value, raw) {
      if (!filePath || !field || value === void 0) {
        error("file, field, and value required");
      }
      const fullPath = path.isAbsolute(filePath) ? filePath : path.join(cwd, filePath);
      if (!fs.existsSync(fullPath)) {
        output({ error: "File not found", path: filePath }, raw);
        return;
      }
      const content = fs.readFileSync(fullPath, "utf-8");
      const fm = extractFrontmatter(content);
      let parsedValue;
      try {
        parsedValue = JSON.parse(value);
      } catch (e) {
        debugLog("frontmatter.set", "JSON parse value failed, using string", e);
        parsedValue = value;
      }
      fm[field] = parsedValue;
      const newContent = spliceFrontmatter(content, fm);
      fs.writeFileSync(fullPath, newContent, "utf-8");
      output({ updated: true, field, value: parsedValue }, raw, "true");
    }
    function cmdFrontmatterMerge(cwd, filePath, data, raw) {
      if (!filePath || !data) {
        error("file and data required");
      }
      const fullPath = path.isAbsolute(filePath) ? filePath : path.join(cwd, filePath);
      if (!fs.existsSync(fullPath)) {
        output({ error: "File not found", path: filePath }, raw);
        return;
      }
      const content = fs.readFileSync(fullPath, "utf-8");
      const fm = extractFrontmatter(content);
      let mergeData;
      try {
        mergeData = JSON.parse(data);
      } catch (e) {
        debugLog("frontmatter.merge", "JSON parse --data failed", e);
        error("Invalid JSON for --data");
        return;
      }
      Object.assign(fm, mergeData);
      const newContent = spliceFrontmatter(content, fm);
      fs.writeFileSync(fullPath, newContent, "utf-8");
      output({ merged: true, fields: Object.keys(mergeData) }, raw, "true");
    }
    var FRONTMATTER_SCHEMAS = {
      plan: { required: ["phase", "plan", "type", "wave", "depends_on", "files_modified", "autonomous", "must_haves"] },
      summary: { required: ["phase", "plan", "subsystem", "tags", "duration", "completed"] },
      verification: { required: ["phase", "verified", "status", "score"] }
    };
    function cmdFrontmatterValidate(cwd, filePath, schemaName, raw) {
      if (!filePath || !schemaName) {
        error("file and schema required");
      }
      const schema = FRONTMATTER_SCHEMAS[schemaName];
      if (!schema) {
        error(`Unknown schema: ${schemaName}. Available: ${Object.keys(FRONTMATTER_SCHEMAS).join(", ")}`);
      }
      const fullPath = path.isAbsolute(filePath) ? filePath : path.join(cwd, filePath);
      const content = safeReadFile(fullPath);
      if (!content) {
        output({ error: "File not found", path: filePath }, raw);
        return;
      }
      const fm = extractFrontmatter(content);
      const missing = schema.required.filter((f) => fm[f] === void 0);
      const present = schema.required.filter((f) => fm[f] !== void 0);
      output({ valid: missing.length === 0, missing, present, schema: schemaName }, raw, missing.length === 0 ? "valid" : "invalid");
    }
    function cmdProgressRender(cwd, format, raw) {
      const milestone = getMilestoneInfo(cwd);
      const phases = [];
      let totalPlans = 0;
      let totalSummaries = 0;
      const phaseTree = getPhaseTree(cwd);
      for (const [, entry] of phaseTree) {
        const plans = entry.plans.length;
        const summaries = entry.summaries.length;
        const phaseName = entry.phaseName ? entry.phaseName.replace(/-/g, " ") : "";
        totalPlans += plans;
        totalSummaries += summaries;
        let status;
        if (plans === 0) status = "Pending";
        else if (summaries >= plans) status = "Complete";
        else if (summaries > 0) status = "In Progress";
        else status = "Planned";
        phases.push({ number: entry.phaseNumber, name: phaseName, plans, summaries, status });
      }
      const percent = totalPlans > 0 ? Math.round(totalSummaries / totalPlans * 100) : 0;
      if (format === "table") {
        const barWidth = 10;
        const filled = Math.round(percent / 100 * barWidth);
        const bar = "\u2588".repeat(filled) + "\u2591".repeat(barWidth - filled);
        let out = `# ${milestone.version} ${milestone.name}

`;
        out += `**Progress:** [${bar}] ${totalSummaries}/${totalPlans} plans (${percent}%)

`;
        out += `| Phase | Name | Plans | Status |
`;
        out += `|-------|------|-------|--------|
`;
        for (const p of phases) {
          out += `| ${p.number} | ${p.name} | ${p.summaries}/${p.plans} | ${p.status} |
`;
        }
        output({ rendered: out }, raw, out);
      } else if (format === "bar") {
        const barWidth = 20;
        const filled = Math.round(percent / 100 * barWidth);
        const bar = "\u2588".repeat(filled) + "\u2591".repeat(barWidth - filled);
        const text = `[${bar}] ${totalSummaries}/${totalPlans} plans (${percent}%)`;
        output({ bar: text, percent, completed: totalSummaries, total: totalPlans }, raw, text);
      } else {
        output({
          milestone_version: milestone.version,
          milestone_name: milestone.name,
          phases,
          total_plans: totalPlans,
          total_summaries: totalSummaries,
          percent
        }, raw);
      }
    }
    function cmdTodoComplete(cwd, filename, raw) {
      if (!filename) {
        error("filename required for todo complete");
      }
      const pendingDir = path.join(cwd, ".planning", "todos", "pending");
      const completedDir = path.join(cwd, ".planning", "todos", "completed");
      const sourcePath = path.join(pendingDir, filename);
      if (!fs.existsSync(sourcePath)) {
        error(`Todo not found: ${filename}`);
      }
      fs.mkdirSync(completedDir, { recursive: true });
      let content = fs.readFileSync(sourcePath, "utf-8");
      const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      content = `completed: ${today}
` + content;
      fs.writeFileSync(path.join(completedDir, filename), content, "utf-8");
      fs.unlinkSync(sourcePath);
      output({ completed: true, file: filename, date: today }, raw, "completed");
    }
    function cmdScaffold(cwd, type, options, raw) {
      const { phase, name } = options;
      const padded = phase ? normalizePhaseName(phase) : "00";
      const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      const phaseInfo = phase ? findPhaseInternal(cwd, phase) : null;
      const phaseDir = phaseInfo ? path.join(cwd, phaseInfo.directory) : null;
      if (phase && !phaseDir && type !== "phase-dir") {
        error(`Phase ${phase} directory not found`);
      }
      let filePath, content;
      switch (type) {
        case "context": {
          filePath = path.join(phaseDir, `${padded}-CONTEXT.md`);
          content = `---
phase: "${padded}"
name: "${name || phaseInfo?.phase_name || "Unnamed"}"
created: ${today}
---

# Phase ${phase}: ${name || phaseInfo?.phase_name || "Unnamed"} \u2014 Context

## Decisions

_Decisions will be captured during /gsd:discuss-phase ${phase}_

## Discretion Areas

_Areas where the executor can use judgment_

## Deferred Ideas

_Ideas to consider later_
`;
          break;
        }
        case "uat": {
          filePath = path.join(phaseDir, `${padded}-UAT.md`);
          content = `---
phase: "${padded}"
name: "${name || phaseInfo?.phase_name || "Unnamed"}"
created: ${today}
status: pending
---

# Phase ${phase}: ${name || phaseInfo?.phase_name || "Unnamed"} \u2014 User Acceptance Testing

## Test Results

| # | Test | Status | Notes |
|---|------|--------|-------|

## Summary

_Pending UAT_
`;
          break;
        }
        case "verification": {
          filePath = path.join(phaseDir, `${padded}-VERIFICATION.md`);
          content = `---
phase: "${padded}"
name: "${name || phaseInfo?.phase_name || "Unnamed"}"
created: ${today}
status: pending
---

# Phase ${phase}: ${name || phaseInfo?.phase_name || "Unnamed"} \u2014 Verification

## Goal-Backward Verification

**Phase Goal:** [From ROADMAP.md]

## Checks

| # | Requirement | Status | Evidence |
|---|------------|--------|----------|

## Result

_Pending verification_
`;
          break;
        }
        case "phase-dir": {
          if (!phase || !name) {
            error("phase and name required for phase-dir scaffold");
          }
          const slug = generateSlugInternal(name);
          const dirName = `${padded}-${slug}`;
          const phasesParent = path.join(cwd, ".planning", "phases");
          fs.mkdirSync(phasesParent, { recursive: true });
          const dirPath = path.join(phasesParent, dirName);
          fs.mkdirSync(dirPath, { recursive: true });
          output({ created: true, directory: `.planning/phases/${dirName}`, path: dirPath }, raw, dirPath);
          return;
        }
        default:
          error(`Unknown scaffold type: ${type}. Available: context, uat, verification, phase-dir`);
      }
      if (fs.existsSync(filePath)) {
        output({ created: false, reason: "already_exists", path: filePath }, raw, "exists");
        return;
      }
      fs.writeFileSync(filePath, content, "utf-8");
      const relPath = path.relative(cwd, filePath);
      output({ created: true, path: relPath }, raw, relPath);
    }
    function cmdTdd(cwd, subcommand, parsedArgs, raw) {
      const testCmd = parsedArgs["test-cmd"];
      const snip = (s) => (s || "").slice(0, 500);
      if (subcommand === "validate-red" || subcommand === "validate-green" || subcommand === "validate-refactor") {
        if (!testCmd) {
          error("--test-cmd required");
        }
        const phase = subcommand.replace("validate-", "");
        const expectFail = phase === "red";
        let exitCode = 0, out = "";
        try {
          out = execSync(testCmd, { encoding: "utf-8", stdio: ["pipe", "pipe", "pipe"], timeout: 12e4, cwd });
        } catch (e) {
          exitCode = e.status || 1;
          out = (e.stdout || "") + (e.stderr || "");
        }
        const valid = expectFail ? exitCode !== 0 : exitCode === 0;
        if (!valid) process.exitCode = 1;
        output({ phase, valid, test_exit_code: exitCode, output_snippet: snip(out) }, raw);
      } else if (subcommand === "auto-test") {
        if (!testCmd) {
          error("--test-cmd required");
        }
        let exitCode = 0, out = "";
        try {
          out = execSync(testCmd, { encoding: "utf-8", stdio: ["pipe", "pipe", "pipe"], timeout: 12e4, cwd });
        } catch (e) {
          exitCode = e.status || 1;
          out = (e.stdout || "") + (e.stderr || "");
        }
        output({ passed: exitCode === 0, exit_code: exitCode, output_snippet: snip(out) }, raw);
      } else if (subcommand === "detect-antipattern") {
        const phase = parsedArgs.phase;
        const files = (parsedArgs.files || "").split(",").map((f) => f.trim()).filter(Boolean);
        if (!phase) {
          error("--phase required");
        }
        const warnings = [];
        const isTest = (f) => /\.(test|spec)\.[^.]+$/.test(f) || f.includes("__tests__") || f.includes("test/");
        if (phase === "red") {
          for (const f of files) {
            if (!isTest(f)) warnings.push({ type: "pre_test_code", file: f, message: "Non-test file modified in RED phase" });
          }
        } else if (phase === "green") {
          for (const f of files) {
            if (isTest(f)) warnings.push({ type: "test_modified_in_green", file: f, message: "Test file modified in GREEN phase" });
          }
        }
        for (const f of files) {
          if (isTest(f)) {
            try {
              const content = fs.readFileSync(path.isAbsolute(f) ? f : path.join(cwd, f), "utf-8");
              const mocks = (content.match(/jest\.mock\(|vi\.mock\(|sinon\.stub\(|\.mock\(/g) || []).length;
              if (mocks > 5) warnings.push({ type: "over_mocking", file: f, message: `${mocks} mock patterns found (threshold: 5)` });
            } catch (e) {
              debugLog("tdd.antipattern", "read failed", e);
            }
          }
        }
        output({ phase, warnings }, raw);
      } else {
        error("Unknown tdd subcommand: " + subcommand + ". Available: validate-red, validate-green, validate-refactor, auto-test, detect-antipattern");
      }
    }
    function cmdReview(cwd, args, raw) {
      if (!args[0] || !args[1]) {
        error("Usage: review <phase> <plan-number>");
      }
      const phaseInfo = findPhaseInternal(cwd, args[0]);
      if (!phaseInfo || !phaseInfo.found) {
        error(`Phase ${args[0]} not found`);
      }
      const padPlan = String(args[1]).padStart(2, "0");
      const phaseDir = path.join(cwd, phaseInfo.directory);
      const sumFile = fs.readdirSync(phaseDir).find((f) => f.includes(`-${padPlan}-SUMMARY.md`));
      const hashes = [];
      if (sumFile) {
        const sc = safeReadFile(path.join(phaseDir, sumFile));
        if (sc) {
          let m;
          const re = /`([0-9a-f]{7,12})`/g;
          while ((m = re.exec(sc)) !== null) hashes.push(m[1]);
        }
      }
      const { structuredLog, diffSummary } = require_git();
      const scope = `${phaseInfo.phase_number}-${padPlan}`;
      const all = structuredLog(cwd, { count: 20 });
      const scoped = Array.isArray(all) ? all.filter((c) => c.conventional && c.conventional.scope === scope) : [];
      const commits = scoped.length > 0 ? scoped : Array.isArray(all) ? all.slice(0, 10) : [];
      let diff = {};
      if (hashes.length >= 1) diff = diffSummary(cwd, { from: hashes[0] + "~1", to: hashes[hashes.length - 1] });
      else if (commits.length > 0) diff = diffSummary(cwd, { from: commits[commits.length - 1].hash + "~1", to: commits[0].hash });
      let conventions = null;
      try {
        const intel = require_codebase_intel().readIntel(cwd);
        if (intel) conventions = intel.conventions || null;
      } catch (e) {
        debugLog("review", "intel", e);
      }
      let conventionsDoc = null;
      try {
        conventionsDoc = fs.readFileSync(path.join(cwd, ".planning", "codebase", "CONVENTIONS.md"), "utf-8");
      } catch (e) {
      }
      output({
        phase: `${phaseInfo.phase_number}-${phaseInfo.phase_name}`,
        plan: padPlan,
        commits: commits.map((c) => ({ hash: c.hash, message: c.message, files: c.files.map((f) => f.path) })),
        diff: { file_count: diff.file_count || 0, total_insertions: diff.total_insertions || 0, total_deletions: diff.total_deletions || 0 },
        conventions,
        conventions_doc: conventionsDoc,
        files_changed: diff.files ? diff.files.map((f) => f.path) : []
      }, raw);
    }
    module2.exports = {
      cmdGenerateSlug,
      cmdCurrentTimestamp,
      cmdListTodos,
      cmdVerifyPathExists,
      cmdConfigEnsureSection,
      cmdConfigSet,
      cmdConfigGet,
      cmdConfigMigrate,
      cmdHistoryDigest,
      cmdResolveModel,
      cmdFindPhase,
      preCommitChecks,
      cmdCommit,
      cmdVerifySummary,
      cmdTemplateSelect,
      cmdTemplateFill,
      cmdPhasePlanIndex,
      cmdStateSnapshot,
      cmdSummaryExtract,
      cmdWebsearch,
      cmdFrontmatterGet,
      cmdFrontmatterSet,
      cmdFrontmatterMerge,
      FRONTMATTER_SCHEMAS,
      cmdFrontmatterValidate,
      cmdProgressRender,
      cmdTodoComplete,
      cmdScaffold,
      cmdTdd,
      cmdReview
    };
  }
});

// src/commands/features.js
var require_features = __commonJS({
  "src/commands/features.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var { execSync, execFileSync } = require("child_process");
    var { output, error, debugLog } = require_output();
    var { loadConfig } = require_config();
    var { CONFIG_SCHEMA } = require_constants();
    var { parseAssertionsMd } = require_verify();
    var { safeReadFile, cachedReadFile, findPhaseInternal, getArchivedPhaseDirs, normalizePhaseName, isValidDateString, sanitizeShellArg, getMilestoneInfo, getPhaseTree } = require_helpers();
    var { cachedRegex } = require_regex_cache();
    var { extractFrontmatter } = require_frontmatter();
    var { execGit } = require_git();
    var { estimateTokens, estimateJsonTokens, checkBudget } = require_context();
    var { readIntel } = require_codebase_intel();
    var { getTransitiveDependents } = require_deps();
    var { banner, sectionHeader, formatTable, summaryLine, actionHint, color, SYMBOLS, progressBar, colorByPercent } = require_format();
    function cmdSessionDiff(cwd, raw) {
      let since = null;
      try {
        const state2 = cachedReadFile(path.join(cwd, ".planning", "STATE.md"));
        const lastMatch = state2.match(/\*\*Last Activity:\*\*\s*(\d{4}-\d{2}-\d{2})/);
        if (lastMatch) since = lastMatch[1];
        const sessionMatch = state2.match(/\*\*Last session:\*\*\s*(\S+)/);
        if (sessionMatch && sessionMatch[1] > (since || "")) since = sessionMatch[1].split("T")[0];
      } catch (e) {
        debugLog("feature.sessionDiff", "read failed", e);
      }
      if (!since) {
        output({ error: "No last activity found in STATE.md", changes: [] }, raw);
        return;
      }
      if (!isValidDateString(since)) {
        output({ error: "Invalid date format in STATE.md", changes: [] }, raw);
        return;
      }
      const sanitizedSince = sanitizeShellArg(since);
      const changes = [];
      const gitLogResult = execGit(cwd, ["log", `--since=${since}`, "--oneline", "--no-merges", "--", ".planning/"]);
      if (gitLogResult.exitCode === 0 && gitLogResult.stdout) {
        for (const line of gitLogResult.stdout.split("\n")) {
          const match = line.match(/^([a-f0-9]+)\s+(.*)/);
          if (match) changes.push({ sha: match[1], message: match[2] });
        }
      }
      const filesChanged = [];
      const gitDiffResult = execGit(cwd, ["log", `--since=${since}`, "--name-only", "--pretty=format:", "--", ".planning/"]);
      if (gitDiffResult.exitCode === 0 && gitDiffResult.stdout) {
        const unique = [...new Set(gitDiffResult.stdout.split("\n").filter(Boolean))];
        filesChanged.push(...unique);
      }
      const summaries = filesChanged.filter((f) => f.includes("SUMMARY"));
      const plans = filesChanged.filter((f) => f.includes("PLAN"));
      const state = filesChanged.filter((f) => f.includes("STATE"));
      const roadmap = filesChanged.filter((f) => f.includes("ROADMAP"));
      output({
        since,
        commit_count: changes.length,
        commits: changes.slice(0, 20),
        files_changed: filesChanged.length,
        categories: {
          summaries: summaries.length,
          plans: plans.length,
          state_updates: state.length,
          roadmap_updates: roadmap.length
        }
      }, raw);
    }
    function cmdContextBudget(cwd, planPath, raw) {
      if (!planPath || !fs.existsSync(path.join(cwd, planPath))) {
        error("Plan path required and must exist");
      }
      const content = fs.readFileSync(path.join(cwd, planPath), "utf-8");
      const fm = extractFrontmatter(content);
      const filesModified = fm.files_modified || [];
      let totalLines = 0;
      let fileReadTokens = 0;
      let heuristicFileReadTokens = 0;
      let existingFiles = 0;
      let newFiles = 0;
      const fileDetails = [];
      for (const file of filesModified) {
        const fullPath = path.join(cwd, file);
        if (fs.existsSync(fullPath)) {
          existingFiles++;
          try {
            const fileContent = fs.readFileSync(fullPath, "utf-8");
            const lines = fileContent.split("\n").length;
            const tokens = estimateTokens(fileContent);
            totalLines += lines;
            fileReadTokens += tokens;
            heuristicFileReadTokens += lines * 4;
            fileDetails.push({ path: file, lines, tokens, exists: true });
          } catch (e) {
            debugLog("feature.contextBudget", "read failed", e);
            fileDetails.push({ path: file, lines: 0, tokens: 0, exists: true, error: "unreadable" });
          }
        } else {
          newFiles++;
          fileDetails.push({ path: file, lines: 0, tokens: 0, exists: false });
        }
      }
      const taskMatches = content.match(/<task\s/gi) || [];
      const taskCount = taskMatches.length;
      const planTokens = estimateTokens(content);
      const heuristicPlanTokens = content.split("\n").length * 4;
      const executionTokens = taskCount * 3500;
      const testTokens = taskCount * 750;
      const totalEstimate = planTokens + fileReadTokens + executionTokens + testTokens;
      const heuristicTotal = heuristicPlanTokens + heuristicFileReadTokens + executionTokens + testTokens;
      const config = loadConfig(cwd);
      const contextWindow = config.context_window || 2e5;
      const targetPercent = config.context_target_percent || 50;
      const estimatedPercent = Math.round(totalEstimate / contextWindow * 100);
      let risk = "low";
      if (estimatedPercent > 60) risk = "high";
      else if (estimatedPercent > 40) risk = "medium";
      const recommendations = [];
      if (estimatedPercent > 50) {
        recommendations.push("Consider splitting this plan \u2014 estimated to exceed 50% context budget");
      }
      if (filesModified.length > 5) {
        recommendations.push(`${filesModified.length} files modified \u2014 high file count increases context pressure`);
      }
      if (taskCount > 3) {
        recommendations.push(`${taskCount} tasks \u2014 plans should have 2-3 tasks max`);
      }
      if (totalLines > 1e3) {
        recommendations.push(`${totalLines} existing lines to read \u2014 large codebase context`);
      }
      output({
        plan: planPath,
        files: {
          total: filesModified.length,
          existing: existingFiles,
          new: newFiles,
          total_lines: totalLines,
          details: fileDetails
        },
        tasks: taskCount,
        estimates: {
          plan_tokens: planTokens,
          file_read_tokens: fileReadTokens,
          execution_tokens: executionTokens,
          test_tokens: testTokens,
          total_tokens: totalEstimate,
          heuristic_tokens: heuristicTotal,
          context_window: contextWindow,
          context_percent: estimatedPercent,
          target_percent: targetPercent
        },
        risk,
        recommendations
      }, raw);
    }
    function cmdTestRun(cwd, raw) {
      const config = loadConfig(cwd);
      const testCommands = config.test_commands || {};
      const testGate = config.test_gate !== false;
      if (Object.keys(testCommands).length === 0) {
        output({
          configured: false,
          message: "No test_commands configured in .planning/config.json",
          example: {
            test_commands: {
              elixir: "cd services/console && mix test",
              go: "cd services/ingestion && go test ./...",
              python: "cd services/ai && pytest"
            },
            test_gate: true
          }
        }, raw);
        return;
      }
      const results = {};
      let allPassed = true;
      for (const [name, command] of Object.entries(testCommands)) {
        const start = Date.now();
        try {
          const testOutput = execSync(command, {
            cwd,
            encoding: "utf-8",
            timeout: 3e5,
            // 5 min timeout
            stdio: ["pipe", "pipe", "pipe"]
          });
          const duration = Date.now() - start;
          const parsed = parseTestOutput(name, testOutput);
          results[name] = {
            status: "passed",
            duration_ms: duration,
            command,
            ...parsed
          };
        } catch (err) {
          debugLog("feature.testRun", "exec failed", err);
          const duration = Date.now() - start;
          allPassed = false;
          const stderr = err.stderr || "";
          const stdout = err.stdout || "";
          const parsed = parseTestOutput(name, stdout + "\n" + stderr);
          results[name] = {
            status: "failed",
            duration_ms: duration,
            command,
            exit_code: err.status,
            ...parsed,
            error_tail: (stderr || stdout).split("\n").slice(-20).join("\n")
          };
        }
      }
      output({
        configured: true,
        test_gate: testGate,
        all_passed: allPassed,
        gate_blocked: testGate && !allPassed,
        results
      }, raw);
    }
    function parseTestOutput(framework, text) {
      const exunit = text.match(/(\d+)\s+tests?,\s+(\d+)\s+failures?(?:,\s+(\d+)\s+excluded)?/);
      if (exunit) {
        return { passed: parseInt(exunit[1]) - parseInt(exunit[2]), failed: parseInt(exunit[2]), skipped: parseInt(exunit[3] || "0") };
      }
      const goPass = (text.match(/^ok\s+/gm) || []).length;
      const goFail = (text.match(/^FAIL\s+/gm) || []).length;
      if (goPass + goFail > 0) {
        return { passed: goPass, failed: goFail, skipped: 0 };
      }
      const pytest = text.match(/(\d+)\s+passed(?:.*?(\d+)\s+failed)?(?:.*?(\d+)\s+skipped)?/);
      if (pytest) {
        return { passed: parseInt(pytest[1]), failed: parseInt(pytest[2] || "0"), skipped: parseInt(pytest[3] || "0") };
      }
      return { passed: null, failed: null, skipped: null };
    }
    function cmdSearchDecisions(cwd, query, raw) {
      if (!query) {
        error("Query string required for decision search");
      }
      const queryLower = query.toLowerCase();
      const queryWords = queryLower.split(/\s+/);
      const results = [];
      try {
        const state = cachedReadFile(path.join(cwd, ".planning", "STATE.md"));
        const decisions = extractDecisions(state, "current");
        for (const d of decisions) {
          const score = scoreDecision(d.text, queryWords);
          if (score > 0) results.push({ ...d, score, source: "STATE.md" });
        }
      } catch (e) {
        debugLog("feature.searchDecisions", "read failed", e);
      }
      try {
        const archiveDir = path.join(cwd, ".planning", "milestones");
        let archiveFiles;
        try {
          archiveFiles = fs.readdirSync(archiveDir).filter((f) => f.endsWith("-ROADMAP.md"));
        } catch {
          archiveFiles = [];
        }
        for (const file of archiveFiles) {
          const content = cachedReadFile(path.join(archiveDir, file));
          if (!content) continue;
          const version = file.replace("-ROADMAP.md", "");
          const decisions = extractDecisions(content, version);
          for (const d of decisions) {
            const score = scoreDecision(d.text, queryWords);
            if (score > 0) results.push({ ...d, score, source: file });
          }
        }
      } catch (e) {
        debugLog("feature.searchDecisions", "read failed", e);
      }
      results.sort((a, b) => b.score - a.score);
      output({
        query,
        match_count: results.length,
        decisions: results.slice(0, 20)
      }, raw);
    }
    function extractDecisions(content, milestone) {
      const decisions = [];
      const pattern = /(\d+)\.\s+\*\*([^*]+)\*\*\s*(?:\(([^)]+)\))?\s*:?\s*([^\n]+)/g;
      let match;
      while ((match = pattern.exec(content)) !== null) {
        decisions.push({
          number: parseInt(match[1]),
          title: match[2].trim(),
          phase: match[3] ? match[3].trim() : null,
          text: match[4].trim(),
          full: match[0].trim(),
          milestone
        });
      }
      return decisions;
    }
    function scoreDecision(text, queryWords) {
      const textLower = text.toLowerCase();
      let score = 0;
      for (const word of queryWords) {
        if (textLower.includes(word)) score += 1;
      }
      return score;
    }
    function cmdValidateDependencies(cwd, phase, raw) {
      if (!phase) {
        error("Phase number required for dependency validation");
      }
      const phasesDir = path.join(cwd, ".planning", "phases");
      const issues = [];
      const checked = [];
      const phaseInfo = findPhaseInternal(cwd, phase);
      let planFiles = [];
      let fullPhaseDir = null;
      if (phaseInfo && phaseInfo.found) {
        fullPhaseDir = path.join(cwd, phaseInfo.directory);
        try {
          planFiles = fs.readdirSync(fullPhaseDir).filter((f) => f.endsWith("-PLAN.md") || f === "PLAN.md");
        } catch (e) {
          debugLog("validate.dependencies", "readdir failed", e);
        }
      }
      if (planFiles.length === 0) {
        try {
          const roadmap = cachedReadFile(path.join(cwd, ".planning", "ROADMAP.md"));
          const phaseSection = roadmap ? roadmap.match(cachedRegex(`###?\\s*Phase\\s+${phase}[\\s\\S]*?(?=###?\\s*Phase\\s+\\d|$)`, "i")) : null;
          if (phaseSection) {
            const depMatch = phaseSection[0].match(/\*\*Depends on:?\*\*:?\s*([^\n]+)/i);
            if (depMatch && !depMatch[1].toLowerCase().includes("nothing")) {
              const depPhases = depMatch[1].match(/Phase\s+(\d+)/gi) || [];
              for (const dp of depPhases) {
                const num = dp.match(/\d+/)[0];
                const depCheck = { plan: "ROADMAP", dependency: dp, status: "unknown" };
                const phaseTree = getPhaseTree(cwd);
                const depNorm = normalizePhaseName(num);
                const depEntry = phaseTree.get(depNorm);
                if (!depEntry) {
                  depCheck.status = "missing";
                  depCheck.message = `Dependency phase ${num} has no directory`;
                  issues.push(depCheck);
                } else {
                  if (depEntry.plans.length === 0) {
                    depCheck.status = "not_planned";
                    depCheck.message = `Phase ${num} has no plans`;
                    issues.push(depCheck);
                  } else if (depEntry.summaries.length < depEntry.plans.length) {
                    depCheck.status = "incomplete";
                    depCheck.message = `Phase ${num}: ${depEntry.summaries.length}/${depEntry.plans.length} complete`;
                    issues.push(depCheck);
                  } else {
                    depCheck.status = "satisfied";
                  }
                }
                checked.push(depCheck);
              }
            }
          }
        } catch (e) {
          debugLog("validate.dependencies", "read roadmap deps failed", e);
        }
        output({ phase, valid: issues.length === 0, issue_count: issues.length, issues, checked, note: "Phase has no plans yet \u2014 checked ROADMAP-level dependencies only" }, raw);
        return;
      }
      for (const planFile of planFiles) {
        const planPath = path.join(fullPhaseDir, planFile);
        const content = cachedReadFile(planPath) || "";
        const fm = extractFrontmatter(content);
        const dependsOn = fm.depends_on || [];
        for (const dep of dependsOn) {
          const depCheck = { plan: planFile, dependency: dep, status: "unknown" };
          const depPhaseMatch = dep.toString().match(/^(\d+)/);
          if (!depPhaseMatch) {
            depCheck.status = "unparseable";
            depCheck.message = `Cannot parse dependency: ${dep}`;
            issues.push(depCheck);
            checked.push(depCheck);
            continue;
          }
          const depPhaseNum = depPhaseMatch[1];
          const depPhaseTree = getPhaseTree(cwd);
          const depNorm = normalizePhaseName(depPhaseNum);
          const depEntry = depPhaseTree.get(depNorm);
          if (!depEntry) {
            depCheck.status = "missing";
            depCheck.message = `Dependency phase ${depPhaseNum} has no directory`;
            issues.push(depCheck);
          } else {
            if (depEntry.plans.length === 0) {
              depCheck.status = "not_planned";
              depCheck.message = `Dependency phase ${depPhaseNum} has no plans`;
              issues.push(depCheck);
            } else if (depEntry.summaries.length < depEntry.plans.length) {
              depCheck.status = "incomplete";
              depCheck.message = `Dependency phase ${depPhaseNum}: ${depEntry.summaries.length}/${depEntry.plans.length} plans complete`;
              issues.push(depCheck);
            } else {
              depCheck.status = "satisfied";
            }
          }
          checked.push(depCheck);
        }
      }
      try {
        const roadmap = cachedReadFile(path.join(cwd, ".planning", "ROADMAP.md"));
        const phaseSection = roadmap ? roadmap.match(cachedRegex(`###?\\s*Phase\\s+${phase}[\\s\\S]*?(?=###?\\s*Phase\\s+\\d|$)`, "i")) : null;
        if (phaseSection) {
          const depMatch = phaseSection[0].match(/\*\*Depends on:?\*\*:?\s*([^\n]+)/i);
          if (depMatch && !depMatch[1].toLowerCase().includes("nothing")) {
            const depPhases = depMatch[1].match(/Phase\s+(\d+)/gi) || [];
            for (const dp of depPhases) {
              const num = dp.match(/\d+/)[0];
              const existing = checked.find((c) => c.dependency.toString().startsWith(num));
              if (!existing) {
                checked.push({ plan: "ROADMAP", dependency: dp, status: "info", message: "Roadmap-level dependency (not in plan frontmatter)" });
              }
            }
          }
        }
      } catch (e) {
        debugLog("validate.dependencies", "read failed", e);
      }
      output({
        phase,
        valid: issues.length === 0,
        issue_count: issues.length,
        issues,
        checked
      }, raw);
    }
    function cmdSearchLessons(cwd, query, raw) {
      if (!query) {
        error("Query string required for lessons search");
      }
      const queryLower = query.toLowerCase();
      const queryWords = queryLower.split(/\s+/);
      const results = [];
      const candidatePaths = [
        path.join(cwd, "tasks", "lessons.md"),
        path.join(cwd, ".planning", "lessons.md")
      ];
      const searchPaths = candidatePaths.filter((p) => {
        try {
          fs.statSync(p);
          return true;
        } catch {
          return false;
        }
      });
      if (searchPaths.length === 0) {
        output({ query, match_count: 0, lessons: [], message: "No lessons file found (checked tasks/lessons.md and .planning/lessons.md)" }, raw);
        return;
      }
      for (const searchPath of searchPaths) {
        const content = cachedReadFile(searchPath);
        if (!content) continue;
        const sections = content.split(/(?=^#{1,3}\s)/m).filter(Boolean);
        for (const section of sections) {
          const titleMatch = section.match(/^#{1,3}\s+(.+)/);
          const title = titleMatch ? titleMatch[1].trim() : "Untitled";
          const body = section.replace(/^#{1,3}\s+.+\n?/, "").trim();
          let score = 0;
          const sectionLower = section.toLowerCase();
          for (const word of queryWords) {
            if (sectionLower.includes(word)) score += 1;
            if (title.toLowerCase().includes(word)) score += 2;
          }
          if (score > 0) {
            results.push({
              title,
              body: body.slice(0, 300) + (body.length > 300 ? "..." : ""),
              score,
              source: path.relative(cwd, searchPath)
            });
          }
        }
      }
      results.sort((a, b) => b.score - a.score);
      output({
        query,
        match_count: results.length,
        lessons: results.slice(0, 15)
      }, raw);
    }
    function cmdCodebaseImpact(cwd, filePaths, raw) {
      if (!filePaths || filePaths.length === 0) {
        error("File paths required for impact estimation");
      }
      try {
        const intel = readIntel(cwd);
        if (intel && intel.dependencies) {
          const graphResults = [];
          for (const filePath of filePaths) {
            const fullPath = path.join(cwd, filePath);
            if (!fs.existsSync(fullPath)) {
              graphResults.push({ path: filePath, exists: false, dependent_count: 0, dependents: [], risk: "low" });
              continue;
            }
            const result = getTransitiveDependents(intel.dependencies, filePath);
            const allDependents = [
              ...result.direct_dependents || [],
              ...(result.transitive_dependents || []).map((d) => d.file)
            ];
            const dependents = allDependents.slice(0, 20);
            graphResults.push({
              path: filePath,
              exists: true,
              dependent_count: result.fan_in || allDependents.length,
              dependents,
              risk: allDependents.length > 10 ? "high" : allDependents.length > 5 ? "medium" : "low"
            });
          }
          const totalDependents2 = graphResults.reduce((sum, r) => sum + r.dependent_count, 0);
          output({
            files_analyzed: graphResults.length,
            total_dependents: totalDependents2,
            overall_risk: totalDependents2 > 20 ? "high" : totalDependents2 > 10 ? "medium" : "low",
            files: graphResults,
            source: "cached_graph"
          }, raw);
          return;
        }
      } catch (e) {
        debugLog("feature.codebaseImpact", "graph fallback to grep", e);
      }
      const results = [];
      for (const filePath of filePaths) {
        const fullPath = path.join(cwd, filePath);
        if (!fs.existsSync(fullPath)) {
          results.push({ path: filePath, exists: false, dependents: [] });
          continue;
        }
        const dependents = [];
        const basename = path.basename(filePath, path.extname(filePath));
        const ext = path.extname(filePath);
        const searchPatterns = [];
        if ([".ex", ".exs"].includes(ext)) {
          const moduleName = basename.split("_").map((w) => w.charAt(0).toUpperCase() + w.slice(1)).join("");
          searchPatterns.push(moduleName);
          searchPatterns.push(basename);
          try {
            const fileContent = fs.readFileSync(fullPath, "utf-8");
            const defmodMatch = fileContent.match(/defmodule\s+([\w.]+)/);
            if (defmodMatch) {
              const parts = defmodMatch[1].split(".");
              const lastPart = parts[parts.length - 1];
              if (!searchPatterns.includes(lastPart)) searchPatterns.push(lastPart);
              if (!searchPatterns.includes(defmodMatch[1])) searchPatterns.push(defmodMatch[1]);
            }
          } catch (e) {
            debugLog("feature.codebaseImpact", "read failed", e);
          }
        } else if (ext === ".go") {
          const dirName = path.dirname(filePath).split("/").pop();
          searchPatterns.push(`"${dirName}"`);
        } else if ([".ts", ".tsx", ".js", ".jsx"].includes(ext)) {
          searchPatterns.push(basename);
        } else if (ext === ".py") {
          searchPatterns.push(`from.*${basename}`);
          searchPatterns.push(`import.*${basename}`);
        }
        if (searchPatterns.length > 0) {
          const regexMeta = /[.*+?[\]{}()|^$\\]/;
          const fixedPatterns = searchPatterns.filter((p) => !regexMeta.test(p));
          const regexPatterns = searchPatterns.filter((p) => regexMeta.test(p));
          const includeArgs = ["--include=*.ex", "--include=*.exs", "--include=*.go", "--include=*.py", "--include=*.ts", "--include=*.tsx", "--include=*.js"];
          const excludeArgs = ["--exclude-dir=node_modules", "--exclude-dir=_build", "--exclude-dir=deps"];
          const runGrep = (grepArgs) => {
            try {
              const result = execFileSync("grep", grepArgs, {
                cwd,
                encoding: "utf-8",
                timeout: 15e3,
                stdio: ["pipe", "pipe", "pipe"]
              }).trim();
              if (result) {
                for (const dep of result.split("\n").slice(0, 30)) {
                  const relative = dep.replace(/^\.\//, "");
                  if (relative !== filePath && !dependents.includes(relative)) {
                    dependents.push(relative);
                  }
                }
              }
            } catch (e) {
              debugLog("feature.codebaseImpact", "grep failed", e);
            }
          };
          if (fixedPatterns.length > 0) {
            const eArgs = fixedPatterns.flatMap((p) => ["-e", p]);
            runGrep(["-rl", "--fixed-strings", ...eArgs, ...includeArgs, ...excludeArgs, "."]);
          }
          if (regexPatterns.length > 0) {
            const eArgs = regexPatterns.flatMap((p) => ["-e", p]);
            runGrep(["-rl", ...eArgs, ...includeArgs, ...excludeArgs, "."]);
          }
        }
        results.push({
          path: filePath,
          exists: true,
          dependent_count: dependents.length,
          dependents: dependents.slice(0, 20),
          risk: dependents.length > 10 ? "high" : dependents.length > 5 ? "medium" : "low"
        });
      }
      const totalDependents = results.reduce((sum, r) => sum + r.dependent_count, 0);
      output({
        files_analyzed: results.length,
        total_dependents: totalDependents,
        overall_risk: totalDependents > 20 ? "high" : totalDependents > 10 ? "medium" : "low",
        files: results
      }, raw);
    }
    function cmdRollbackInfo(cwd, planId, raw) {
      if (!planId) {
        error("Plan ID required (e.g., 68-01)");
      }
      const phasesDir = path.join(cwd, ".planning", "phases");
      let summaryPath = null;
      let summaryContent = null;
      try {
        const entries = fs.readdirSync(phasesDir, { withFileTypes: true });
        const dirs = entries.filter((e) => e.isDirectory()).map((e) => e.name);
        const phaseMatch = planId.match(/^(\d+)/);
        if (phaseMatch) {
          const phaseNum = phaseMatch[1];
          const dir = dirs.find((d) => d.startsWith(phaseNum + "-") || d === phaseNum);
          if (dir) {
            const files = fs.readdirSync(path.join(phasesDir, dir));
            const summary = files.find((f) => f.includes(planId) && f.endsWith("-SUMMARY.md"));
            if (summary) {
              summaryPath = path.join(".planning", "phases", dir, summary);
              summaryContent = fs.readFileSync(path.join(cwd, summaryPath), "utf-8");
            }
          }
        }
      } catch (e) {
        debugLog("feature.rollbackInfo", "read failed", e);
      }
      if (!summaryContent) {
        output({ found: false, plan_id: planId, message: "No SUMMARY found for this plan" }, raw);
        return;
      }
      const commitPattern = /\b([a-f0-9]{7,40})\b/g;
      const fm = extractFrontmatter(summaryContent);
      const commits = fm.commits || [];
      const candidateShas = [];
      let cm;
      while ((cm = commitPattern.exec(summaryContent)) !== null) {
        const sha = cm[1];
        if (!commits.includes(sha)) {
          candidateShas.push(sha);
        }
      }
      if (candidateShas.length > 0) {
        const verifyResult = execGit(cwd, ["rev-parse", "--verify", ...candidateShas.map((s) => s + "^{commit}")]);
        if (verifyResult.exitCode === 0) {
          for (const sha of candidateShas) {
            if (!commits.includes(sha)) commits.push(sha);
          }
        } else {
          for (const sha of candidateShas) {
            const result = execGit(cwd, ["rev-parse", "--verify", sha + "^{commit}"]);
            if (result.exitCode === 0 && !commits.includes(sha)) {
              commits.push(sha);
            }
          }
        }
      }
      const allCommits = commits;
      const commitDetails = [];
      if (allCommits.length > 0) {
        const logResult = execGit(cwd, ["log", "--no-walk", "--format=%H|%s|%an|%ai", ...allCommits]);
        if (logResult.exitCode === 0 && logResult.stdout) {
          const logLines = logResult.stdout.split("\n").filter(Boolean);
          for (const line of logLines) {
            const [hash, subject, author, date] = line.split("|");
            if (!hash) continue;
            const filesResult = execGit(cwd, ["diff-tree", "--no-commit-id", "--name-only", "-r", hash]);
            const files = filesResult.exitCode === 0 ? filesResult.stdout.split("\n").filter(Boolean) : [];
            commitDetails.push({ sha: hash.slice(0, 7), subject, author, date, files });
          }
        }
      }
      output({
        found: true,
        plan_id: planId,
        summary_path: summaryPath,
        commit_count: commitDetails.length,
        commits: commitDetails,
        rollback_command: allCommits.length > 0 ? `git revert --no-commit ${allCommits.map((c) => c.slice(0, 7)).join(" ")} && git commit -m "rollback: revert plan ${planId}"` : null,
        warning: "Review the commits above before running rollback. This creates a revert commit (non-destructive)."
      }, raw);
    }
    function formatVelocity(result) {
      const lines = [];
      lines.push(banner("Velocity"));
      lines.push(`  Milestone: ${color.bold(result.milestone)}`);
      lines.push("");
      lines.push(sectionHeader("Metrics"));
      lines.push(`  Plans completed: ${color.bold(String(result.metrics.plans_completed))}`);
      lines.push(`  Active days:     ${color.bold(String(result.metrics.active_days))}`);
      lines.push(`  Average:         ${color.bold(String(result.metrics.avg_plans_per_day))} plans/day`);
      lines.push("");
      if (result.plan_metrics && result.plan_metrics.length > 0) {
        lines.push(sectionHeader("Recent Plans"));
        const planRows = result.plan_metrics.slice(-10).map((m) => [
          m.plan,
          m.duration || "-",
          m.tasks != null ? String(m.tasks) : "-",
          m.files != null ? String(m.files) : "-"
        ]);
        lines.push(formatTable(["Plan", "Duration", "Tasks", "Files"], planRows, { maxRows: 10 }));
        lines.push("");
      }
      const fc = result.forecast;
      if (fc && fc.remaining_phases > 0) {
        lines.push(sectionHeader("Forecast"));
        lines.push(`  ${color.bold(String(fc.remaining_phases))} phases, ~${color.bold(String(fc.estimated_remaining_plans))} plans, ~${color.bold(fc.estimated_days_remaining != null ? String(fc.estimated_days_remaining) : "?")} days`);
        lines.push("");
      }
      lines.push(summaryLine(`${result.metrics.avg_plans_per_day} plans/day ${SYMBOLS.dash} ${fc ? fc.remaining_phases : 0} phases remaining`));
      return lines.join("\n");
    }
    function cmdVelocity(cwd, raw) {
      const milestone = getMilestoneInfo(cwd);
      const metrics = [];
      try {
        const state = cachedReadFile(path.join(cwd, ".planning", "STATE.md"));
        const metricsSection = state.match(/### Performance Metrics[\s\S]*?\|[\s\S]*?(?=\n###|\n---|\n$)/);
        if (metricsSection) {
          const rows = metricsSection[0].match(/\|\s*[\d.]+-[\d.]+\s*\|[^\n]+/g) || [];
          for (const row of rows) {
            const cols = row.split("|").map((c) => c.trim()).filter(Boolean);
            if (cols.length >= 2) {
              metrics.push({
                plan: cols[0],
                duration: cols[1],
                tasks: cols[2] ? parseInt(cols[2]) : null,
                files: cols[3] ? parseInt(cols[3]) : null
              });
            }
          }
        }
      } catch (e) {
        debugLog("feature.velocity", "read STATE.md metrics failed", e);
      }
      let plansPerDay = {};
      const velocityLog = execGit(cwd, ["log", "--oneline", "--format=%ai|%s", "--", ".planning/"]);
      if (velocityLog.exitCode === 0 && velocityLog.stdout) {
        for (const line of velocityLog.stdout.split("\n")) {
          const [dateTime, ...msgParts] = line.split("|");
          const date = dateTime.split(" ")[0];
          const msg = msgParts.join("|");
          if (msg.toLowerCase().includes("summary") || msg.toLowerCase().includes("complete")) {
            plansPerDay[date] = (plansPerDay[date] || 0) + 1;
          }
        }
      }
      const daysList = Object.entries(plansPerDay).sort((a, b) => a[0].localeCompare(b[0]));
      const totalDays = daysList.length || 1;
      const totalCompletedPlans = daysList.reduce((sum, [, count]) => sum + count, 0);
      const avgPerDay = (totalCompletedPlans / totalDays).toFixed(1);
      let remainingPhases = 0;
      try {
        const roadmap = cachedReadFile(path.join(cwd, ".planning", "ROADMAP.md"));
        const unchecked = (roadmap.match(/- \[ \] \*\*Phase/g) || []).length;
        remainingPhases = unchecked;
      } catch (e) {
        debugLog("feature.velocity", "read failed", e);
      }
      const avgPlansPerPhase = metrics.length > 0 ? Math.ceil(metrics.length / Math.max(1, metrics.length / 4)) : 4;
      const estimatedRemainingPlans = remainingPhases * avgPlansPerPhase;
      const estimatedDaysRemaining = totalCompletedPlans > 0 ? Math.ceil(estimatedRemainingPlans / (totalCompletedPlans / totalDays)) : null;
      output({
        milestone: milestone.version,
        metrics: {
          plans_completed: totalCompletedPlans,
          active_days: totalDays,
          avg_plans_per_day: parseFloat(avgPerDay),
          daily_breakdown: daysList.slice(-7)
          // Last 7 days
        },
        plan_metrics: metrics,
        forecast: {
          remaining_phases: remainingPhases,
          estimated_remaining_plans: estimatedRemainingPlans,
          estimated_days_remaining: estimatedDaysRemaining
        }
      }, { formatter: formatVelocity });
    }
    function cmdTraceRequirement(cwd, reqId, raw) {
      if (!reqId) {
        error("Requirement ID required (e.g., ANOM-01)");
      }
      const reqUpper = reqId.toUpperCase();
      const trace = { requirement: reqUpper, phase: null, plans: [], files: [], status: "unknown" };
      try {
        const roadmap = cachedReadFile(path.join(cwd, ".planning", "ROADMAP.md"));
        const coverageMatch = roadmap.match(cachedRegex(`${reqUpper}\\s*\\|\\s*(\\d+)`, "i"));
        if (coverageMatch) {
          trace.phase = coverageMatch[1];
        }
        if (!trace.phase) {
          const reqLine = roadmap.match(cachedRegex(`Phase\\s+(\\d+)[\\s\\S]*?Requirements:?\\*\\*:?\\s*[^\\n]*${reqUpper}`, "i"));
          if (reqLine) trace.phase = reqLine[1];
        }
      } catch (e) {
        debugLog("feature.traceRequirement", "read failed", e);
      }
      if (!trace.phase) {
        output({ ...trace, status: "unmapped", message: `${reqUpper} not found in ROADMAP.md coverage map` }, raw);
        return;
      }
      const phaseTree = getPhaseTree(cwd);
      const phaseNorm = normalizePhaseName(trace.phase);
      const phaseEntry = phaseTree.get(phaseNorm);
      if (phaseEntry) {
        for (const plan of phaseEntry.plans) {
          const content = cachedReadFile(path.join(phaseEntry.fullPath, plan));
          if (!content) continue;
          const fm = extractFrontmatter(content);
          const reqs = fm.requirements || [];
          if (reqs.some((r) => r.toUpperCase().includes(reqUpper))) {
            trace.plans.push({
              file: plan,
              has_summary: phaseEntry.summaries.includes(plan.replace("-PLAN.md", "-SUMMARY.md"))
            });
            const planFiles = fm.files_modified || [];
            trace.files.push(...planFiles);
          }
        }
        const allSummariesExist = trace.plans.every((p) => p.has_summary);
        if (trace.plans.length === 0) {
          trace.status = "planned_no_plans";
        } else if (allSummariesExist) {
          trace.status = "implemented";
        } else {
          trace.status = "in_progress";
        }
      } else {
        trace.status = "not_started";
      }
      trace.files = [...new Set(trace.files)];
      trace.files = trace.files.map((f) => ({
        path: f,
        exists: fs.existsSync(path.join(cwd, f))
      }));
      const assertionsContent = cachedReadFile(path.join(cwd, ".planning", "ASSERTIONS.md"));
      if (assertionsContent) {
        const allAssertions = parseAssertionsMd(assertionsContent);
        const reqAssertions = allAssertions[reqUpper];
        if (reqAssertions) {
          const planTruths = /* @__PURE__ */ new Set();
          if (phaseEntry) {
            for (const plan of phaseEntry.plans) {
              const planContent = cachedReadFile(path.join(phaseEntry.fullPath, plan));
              if (!planContent) continue;
              const fm = extractFrontmatter(planContent);
              if (fm.must_haves && fm.must_haves.truths) {
                const truths = Array.isArray(fm.must_haves.truths) ? fm.must_haves.truths : [fm.must_haves.truths];
                for (const t of truths) {
                  if (typeof t === "string") planTruths.add(t.toLowerCase());
                }
              }
            }
          }
          const hasSummaries = trace.plans.length > 0 && trace.plans.every((p) => p.has_summary);
          const assertionEntries = reqAssertions.assertions.map((a) => {
            const assertLower = a.assert.toLowerCase();
            const planned = planTruths.size > 0 && [...planTruths].some(
              (t) => t.includes(assertLower.slice(0, 30)) || assertLower.includes(t.slice(0, 30))
            );
            const implemented = planned && hasSummaries;
            return {
              assert: a.assert,
              priority: a.priority,
              type: a.type || null,
              planned,
              implemented,
              gap: !planned
            };
          });
          trace.assertions = assertionEntries;
          trace.assertion_count = assertionEntries.length;
          trace.must_have_count = assertionEntries.filter((a) => a.priority === "must-have").length;
          const passCount = assertionEntries.filter((a) => a.implemented).length;
          const failCount = assertionEntries.filter((a) => !a.implemented && a.priority === "must-have").length;
          const planRef = trace.plans.length > 0 ? trace.plans.map((p) => p.file.replace(/-PLAN\.md$/, "")).join(", ") : "no plan";
          const verificationStatus = passCount === assertionEntries.length ? "PASSED" : failCount > 0 ? "partial" : "pending";
          trace.chain = `${reqUpper} \u2192 ${assertionEntries.length} assertions (${trace.must_have_count} must-have) \u2192 ${planRef} \u2192 VERIFICATION: ${verificationStatus}`;
        }
      }
      output(trace, raw);
    }
    function cmdValidateConfig(cwd, raw) {
      const configPath = path.join(cwd, ".planning", "config.json");
      if (!fs.existsSync(configPath)) {
        output({ exists: false, message: "No config.json found" }, raw);
        return;
      }
      let config;
      try {
        config = JSON.parse(fs.readFileSync(configPath, "utf-8"));
      } catch (e) {
        debugLog("feature.validateConfig", "read failed", e);
        output({ exists: true, valid_json: false, error: e.message }, raw);
        return;
      }
      const knownKeys = {};
      for (const [key, def] of Object.entries(CONFIG_SCHEMA)) {
        knownKeys[key] = { type: def.type, default: def.default, description: def.description };
        for (const alias of def.aliases) {
          knownKeys[alias] = { type: def.type, default: def.default, description: `Alias for ${key}: ${def.description}` };
        }
      }
      const sectionNames = /* @__PURE__ */ new Set();
      for (const [, def] of Object.entries(CONFIG_SCHEMA)) {
        if (def.nested) sectionNames.add(def.nested.section);
      }
      for (const section of sectionNames) {
        knownKeys[section] = { type: "object", default: {}, description: `${section} configuration section` };
      }
      const warnings = [];
      const effective = {};
      for (const key of Object.keys(config)) {
        if (!knownKeys[key]) {
          warnings.push({ type: "unknown_key", key, value: config[key], message: `Unknown config key: "${key}" \u2014 possible typo?` });
        }
      }
      for (const [key, schema] of Object.entries(knownKeys)) {
        const hasExplicit = key in config;
        const value = hasExplicit ? config[key] : schema.default;
        if (hasExplicit) {
          const actualType = typeof config[key];
          if (actualType !== schema.type && !(schema.type === "object" && actualType === "object")) {
            warnings.push({
              type: "type_mismatch",
              key,
              expected: schema.type,
              actual: actualType,
              message: `"${key}" should be ${schema.type}, got ${actualType}`
            });
          }
        }
        effective[key] = { value, source: hasExplicit ? "explicit" : "default", description: schema.description };
      }
      output({
        exists: true,
        valid_json: true,
        warning_count: warnings.length,
        warnings,
        effective_config: effective
      }, raw);
    }
    function formatQuickSummary(result) {
      const lines = [];
      lines.push(banner("Quick Summary"));
      lines.push(`  Milestone: ${color.bold(result.milestone)}`);
      lines.push(`  Total quick tasks: ${color.bold(String(result.total_quick_tasks))}`);
      lines.push("");
      if (result.tasks && result.tasks.length > 0) {
        const rows = result.tasks.map((t) => [
          t.number || "-",
          t.description || "-",
          t.date || "-",
          t.status || "-"
        ]);
        lines.push(formatTable(["#", "Description", "Date", "Status"], rows));
        lines.push("");
      }
      lines.push(summaryLine(`${result.total_quick_tasks} quick tasks completed`));
      return lines.join("\n");
    }
    function cmdQuickTaskSummary(cwd, raw) {
      const milestone = getMilestoneInfo(cwd);
      const quickTasks = [];
      try {
        const state = cachedReadFile(path.join(cwd, ".planning", "STATE.md"));
        const quickSection = state.match(/### Quick Tasks Completed[\s\S]*?\|[\s\S]*?(?=\n###|\n---|\n$)/);
        if (quickSection) {
          const rows = quickSection[0].match(/\|\s*\d+\s*\|[^\n]+/g) || [];
          for (const row of rows) {
            const cols = row.split("|").map((c) => c.trim()).filter(Boolean);
            if (cols.length >= 4) {
              quickTasks.push({
                number: cols[0],
                description: cols[1],
                date: cols[2],
                commit: cols[3],
                status: cols[4] || "unknown"
              });
            }
          }
        }
      } catch (e) {
        debugLog("feature.quickSummary", "parse STATE.md quick tasks failed", e);
      }
      output({
        milestone: milestone.version,
        total_quick_tasks: quickTasks.length,
        tasks: quickTasks
      }, { formatter: formatQuickSummary });
    }
    function extractSectionsFromFile(filePath, sectionNames) {
      const content = safeReadFile(filePath);
      if (content === null) {
        return { error: "File not found", file: filePath };
      }
      const lines = content.split("\n");
      const sections = [];
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const markerMatch = line.match(/<!--\s*section:\s*(.+?)\s*-->/i);
        if (markerMatch) {
          const name = markerMatch[1].trim();
          sections.push({ name, startLine: i, endLine: -1, type: "marker" });
          continue;
        }
        const endMarkerMatch = line.match(/<!--\s*\/section\s*-->/i);
        if (endMarkerMatch) {
          for (let j = sections.length - 1; j >= 0; j--) {
            if (sections[j].type === "marker" && sections[j].endLine === -1) {
              sections[j].endLine = i;
              break;
            }
          }
          continue;
        }
        const headerMatch = line.match(/^(#{2,3})\s+(.+)/);
        if (headerMatch) {
          const level = headerMatch[1].length;
          const name = headerMatch[2].trim();
          sections.push({ name, startLine: i, endLine: -1, type: "header", level });
        }
      }
      for (let i = 0; i < sections.length; i++) {
        const sec = sections[i];
        if (sec.endLine !== -1) continue;
        if (sec.type === "header") {
          let closed = false;
          for (let j = i + 1; j < sections.length; j++) {
            if (sections[j].type === "header" && sections[j].level <= sec.level) {
              sec.endLine = sections[j].startLine - 1;
              closed = true;
              break;
            }
          }
          if (!closed) {
            sec.endLine = lines.length - 1;
          }
        } else if (sec.type === "marker" && sec.endLine === -1) {
          sec.endLine = lines.length - 1;
        }
      }
      const availableSections = sections.map((s) => s.name);
      if (!sectionNames || sectionNames.length === 0) {
        return {
          file: filePath,
          available_sections: availableSections
        };
      }
      const found = [];
      const missing = [];
      const contentParts = [];
      for (const requestedName of sectionNames) {
        const requestedLower = requestedName.toLowerCase();
        const match = sections.find((s) => s.name.toLowerCase() === requestedLower);
        if (match) {
          found.push(match.name);
          const sectionLines = lines.slice(match.startLine, match.endLine + 1);
          contentParts.push(sectionLines.join("\n"));
        } else {
          missing.push(requestedName);
        }
      }
      return {
        file: filePath,
        sections_found: found,
        sections_missing: missing,
        content: contentParts.join("\n\n")
      };
    }
    function cmdExtractSections(cwd, args, raw) {
      const filePath = args[0];
      if (!filePath) {
        error("Usage: extract-sections <file-path> [section1] [section2] ...");
      }
      const resolvedPath = path.isAbsolute(filePath) ? filePath : path.join(cwd, filePath);
      const sectionNames = args.slice(1);
      const result = extractSectionsFromFile(resolvedPath, sectionNames);
      if (result.error) {
        error(`File not found: ${filePath}`);
      }
      output(result, raw);
    }
    var { extractAtReferences } = require_helpers();
    function measureAllWorkflows(cwd) {
      let pluginDir = process.env.GSD_PLUGIN_DIR;
      if (!pluginDir) {
        pluginDir = path.resolve(__dirname, "..");
      }
      const workflowsDir = path.join(pluginDir, "workflows");
      if (!fs.existsSync(workflowsDir)) {
        return { error: `Workflows directory not found: ${workflowsDir}`, workflows: [] };
      }
      const workflowFiles = fs.readdirSync(workflowsDir).filter((f) => f.endsWith(".md")).sort();
      const workflows = [];
      let totalTokens = 0;
      for (const file of workflowFiles) {
        const filePath = path.join(workflowsDir, file);
        let content;
        try {
          content = fs.readFileSync(filePath, "utf-8");
        } catch (e) {
          debugLog("baseline.measure", `read workflow failed: ${file}`, e);
          continue;
        }
        const workflowTokens = estimateTokens(content);
        const refs = extractAtReferences(content);
        let refTokens = 0;
        let resolvedRefs = 0;
        for (const ref of refs) {
          let refPath;
          if (path.isAbsolute(ref)) {
            refPath = ref;
          } else {
            const pluginRef = path.join(pluginDir, ref);
            const cwdRef = path.join(cwd, ref);
            if (fs.existsSync(pluginRef)) {
              refPath = pluginRef;
            } else if (fs.existsSync(cwdRef)) {
              refPath = cwdRef;
            } else {
              continue;
            }
          }
          try {
            const refContent = fs.readFileSync(refPath, "utf-8");
            refTokens += estimateTokens(refContent);
            resolvedRefs++;
          } catch (e) {
            debugLog("baseline.measure", `read ref failed: ${ref}`, e);
          }
        }
        const total = workflowTokens + refTokens;
        totalTokens += total;
        workflows.push({
          name: file,
          workflow_tokens: workflowTokens,
          ref_count: resolvedRefs,
          ref_tokens: refTokens,
          total_tokens: total
        });
      }
      workflows.sort((a, b) => b.total_tokens - a.total_tokens);
      return {
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        workflow_count: workflows.length,
        total_tokens: totalTokens,
        workflows
      };
    }
    function cmdContextBudgetBaseline(cwd, raw) {
      const measurement = measureAllWorkflows(cwd);
      if (measurement.error) {
        error(measurement.error);
      }
      const baselinesDir = path.join(cwd, ".planning", "baselines");
      if (!fs.existsSync(baselinesDir)) {
        fs.mkdirSync(baselinesDir, { recursive: true });
      }
      const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
      const baselinePath = path.join(baselinesDir, `baseline-${timestamp}.json`);
      fs.writeFileSync(baselinePath, JSON.stringify(measurement, null, 2), "utf-8");
      const maxNameLen = Math.max(25, ...measurement.workflows.map((w) => w.name.length));
      const header = `${"Workflow".padEnd(maxNameLen)} | Tokens  | Refs | Ref Tokens | Total`;
      const sep = "-".repeat(maxNameLen) + "-|---------|------|------------|--------";
      process.stderr.write("\n## Workflow Token Baseline\n\n");
      process.stderr.write(header + "\n");
      process.stderr.write(sep + "\n");
      for (const w of measurement.workflows) {
        const name = w.name.padEnd(maxNameLen);
        const tokens = String(w.workflow_tokens).padStart(7);
        const refs = String(w.ref_count).padStart(4);
        const refTokens = String(w.ref_tokens).padStart(10);
        const total = String(w.total_tokens).padStart(7);
        process.stderr.write(`${name} | ${tokens} | ${refs} | ${refTokens} | ${total}
`);
      }
      process.stderr.write(sep + "\n");
      process.stderr.write(`${"TOTAL".padEnd(maxNameLen)} | ${String(measurement.total_tokens).padStart(7)} |      |            |
`);
      process.stderr.write(`
Baseline saved: ${path.relative(cwd, baselinePath)}

`);
      measurement.baseline_file = path.relative(cwd, baselinePath);
      output(measurement, raw);
    }
    function cmdContextBudgetCompare(cwd, baselinePath, raw) {
      let baseline;
      const baselinesDir = path.join(cwd, ".planning", "baselines");
      if (baselinePath) {
        const fullPath = path.isAbsolute(baselinePath) ? baselinePath : path.join(cwd, baselinePath);
        if (!fs.existsSync(fullPath)) {
          error(`Baseline file not found: ${baselinePath}`);
        }
        try {
          baseline = JSON.parse(fs.readFileSync(fullPath, "utf-8"));
        } catch (e) {
          error(`Invalid baseline file: ${e.message}`);
        }
      } else {
        if (!fs.existsSync(baselinesDir)) {
          error("No baselines directory. Run `context-budget baseline` first.");
        }
        const files = fs.readdirSync(baselinesDir).filter((f) => f.startsWith("baseline-") && f.endsWith(".json")).sort().reverse();
        if (files.length === 0) {
          error("No baseline found. Run `context-budget baseline` first.");
        }
        const latestFile = path.join(baselinesDir, files[0]);
        try {
          baseline = JSON.parse(fs.readFileSync(latestFile, "utf-8"));
          baselinePath = path.relative(cwd, latestFile);
        } catch (e) {
          error(`Invalid baseline file: ${e.message}`);
        }
      }
      const current = measureAllWorkflows(cwd);
      if (current.error) {
        error(current.error);
      }
      const baselineMap = {};
      for (const w of baseline.workflows || []) {
        baselineMap[w.name] = w;
      }
      const currentMap = {};
      for (const w of current.workflows) {
        currentMap[w.name] = w;
      }
      const allNames = /* @__PURE__ */ new Set([...Object.keys(baselineMap), ...Object.keys(currentMap)]);
      const comparisons = [];
      let beforeTotal = 0;
      let afterTotal = 0;
      let improved = 0;
      let unchanged = 0;
      let worsened = 0;
      for (const name of allNames) {
        const before = baselineMap[name];
        const after = currentMap[name];
        if (before && after) {
          const delta = after.total_tokens - before.total_tokens;
          const pctChange = before.total_tokens > 0 ? Math.round(delta / before.total_tokens * 1e3) / 10 : 0;
          beforeTotal += before.total_tokens;
          afterTotal += after.total_tokens;
          if (delta < 0) improved++;
          else if (delta > 0) worsened++;
          else unchanged++;
          comparisons.push({ name, before: before.total_tokens, after: after.total_tokens, delta, percent_change: pctChange });
        } else if (before && !after) {
          beforeTotal += before.total_tokens;
          comparisons.push({ name, before: before.total_tokens, after: 0, delta: -before.total_tokens, percent_change: -100, status: "removed" });
          improved++;
        } else if (!before && after) {
          afterTotal += after.total_tokens;
          comparisons.push({ name, before: 0, after: after.total_tokens, delta: after.total_tokens, percent_change: 100, status: "new" });
          worsened++;
        }
      }
      comparisons.sort((a, b) => a.delta - b.delta);
      const totalDelta = afterTotal - beforeTotal;
      const totalPctChange = beforeTotal > 0 ? Math.round(totalDelta / beforeTotal * 1e3) / 10 : 0;
      const result = {
        baseline_file: baselinePath || "unknown",
        baseline_date: baseline.timestamp || "unknown",
        current_date: current.timestamp,
        summary: {
          before_total: beforeTotal,
          after_total: afterTotal,
          delta: totalDelta,
          percent_change: totalPctChange,
          workflows_improved: improved,
          workflows_unchanged: unchanged,
          workflows_worsened: worsened
        },
        workflows: comparisons
      };
      const maxNameLen = Math.max(25, ...comparisons.map((c) => c.name.length));
      const header = `${"Workflow".padEnd(maxNameLen)} | Before  | After   | Delta   | Change`;
      const sep = "-".repeat(maxNameLen) + "-|---------|---------|---------|-------";
      process.stderr.write("\n## Context Budget Comparison\n\n");
      process.stderr.write(`Baseline: ${baselinePath} (${baseline.timestamp || "unknown"})

`);
      process.stderr.write(header + "\n");
      process.stderr.write(sep + "\n");
      for (const c of comparisons) {
        const name = c.name.padEnd(maxNameLen);
        const before = String(c.before).padStart(7);
        const after = String(c.after).padStart(7);
        const delta = (c.delta >= 0 ? "+" + c.delta : String(c.delta)).padStart(7);
        const pct = (c.percent_change >= 0 ? "+" + c.percent_change : String(c.percent_change)) + "%";
        process.stderr.write(`${name} | ${before} | ${after} | ${delta} | ${pct.padStart(6)}
`);
      }
      process.stderr.write(sep + "\n");
      const totalDeltaStr = (totalDelta >= 0 ? "+" + totalDelta : String(totalDelta)).padStart(7);
      const totalPctStr = (totalPctChange >= 0 ? "+" + totalPctChange : String(totalPctChange)) + "%";
      process.stderr.write(`${"TOTAL".padEnd(maxNameLen)} | ${String(beforeTotal).padStart(7)} | ${String(afterTotal).padStart(7)} | ${totalDeltaStr} | ${totalPctStr.padStart(6)}
`);
      process.stderr.write(`
Improved: ${improved} | Unchanged: ${unchanged} | Worsened: ${worsened}

`);
      output(result, raw);
    }
    function cmdContextBudgetMeasure(cwd, raw) {
      const measurements = [];
      function measureInProcess(label, fn) {
        try {
          let captured = null;
          const origStdoutWrite = process.stdout.write;
          process.stdout.write = (chunk) => {
            captured = chunk;
            return true;
          };
          try {
            fn();
          } finally {
            process.stdout.write = origStdoutWrite;
          }
          const jsonStr = typeof captured === "string" ? captured : captured ? captured.toString() : "";
          const tokens = estimateTokens(jsonStr);
          return { tokens, bytes: Buffer.byteLength(jsonStr, "utf-8") };
        } catch (e) {
          debugLog("measure", `in-process measurement failed: ${label}`, e);
          return { tokens: 0, bytes: 0, error: e.message ? e.message.split("\n")[0] : "unknown" };
        }
      }
      const { cmdHistoryDigest } = require_misc();
      const { cmdInitProgress, cmdInitExecutePhase, cmdInitPlanPhase } = require_init();
      let testPhase = null;
      const phaseTree = getPhaseTree(cwd);
      if (phaseTree.size > 0) {
        const firstEntry = phaseTree.values().next().value;
        if (firstEntry) testPhase = firstEntry.phaseNumber;
      }
      const hdFull = measureInProcess("history-digest", () => cmdHistoryDigest(cwd, {}, true));
      const hdLimit5 = measureInProcess("history-digest --limit 5", () => cmdHistoryDigest(cwd, { limit: 5 }, true));
      const hdSlim = measureInProcess("history-digest --slim", () => cmdHistoryDigest(cwd, { compact: true }, true));
      const hdSlimLimit5 = measureInProcess("history-digest --slim --limit 5", () => cmdHistoryDigest(cwd, { limit: 5, compact: true }, true));
      if (!hdFull.error) {
        measurements.push({
          command: "history-digest",
          variant: "--limit 5",
          full_tokens: hdFull.tokens,
          slim_tokens: hdLimit5.tokens,
          saved_tokens: hdFull.tokens - hdLimit5.tokens,
          saved_percent: hdFull.tokens > 0 ? Math.round((hdFull.tokens - hdLimit5.tokens) / hdFull.tokens * 100) : 0,
          full_bytes: hdFull.bytes,
          slim_bytes: hdLimit5.bytes
        });
        measurements.push({
          command: "history-digest",
          variant: "--slim",
          full_tokens: hdFull.tokens,
          slim_tokens: hdSlim.tokens,
          saved_tokens: hdFull.tokens - hdSlim.tokens,
          saved_percent: hdFull.tokens > 0 ? Math.round((hdFull.tokens - hdSlim.tokens) / hdFull.tokens * 100) : 0,
          full_bytes: hdFull.bytes,
          slim_bytes: hdSlim.bytes
        });
        measurements.push({
          command: "history-digest",
          variant: "--slim --limit 5",
          full_tokens: hdFull.tokens,
          slim_tokens: hdSlimLimit5.tokens,
          saved_tokens: hdFull.tokens - hdSlimLimit5.tokens,
          saved_percent: hdFull.tokens > 0 ? Math.round((hdFull.tokens - hdSlimLimit5.tokens) / hdFull.tokens * 100) : 0,
          full_bytes: hdFull.bytes,
          slim_bytes: hdSlimLimit5.bytes
        });
      }
      const savedCompact = global._gsdCompactMode;
      global._gsdCompactMode = false;
      const progressVerbose = measureInProcess("init progress --verbose", () => cmdInitProgress(cwd, true));
      global._gsdCompactMode = true;
      const progressCompact = measureInProcess("init progress", () => cmdInitProgress(cwd, true));
      global._gsdCompactMode = savedCompact;
      if (!progressVerbose.error) {
        measurements.push({
          command: "init progress",
          variant: "compact (default) vs verbose",
          full_tokens: progressVerbose.tokens,
          slim_tokens: progressCompact.tokens,
          saved_tokens: progressVerbose.tokens - progressCompact.tokens,
          saved_percent: progressVerbose.tokens > 0 ? Math.round((progressVerbose.tokens - progressCompact.tokens) / progressVerbose.tokens * 100) : 0,
          full_bytes: progressVerbose.bytes,
          slim_bytes: progressCompact.bytes
        });
      }
      if (testPhase) {
        global._gsdCompactMode = false;
        const execVerbose = measureInProcess(`init execute-phase ${testPhase} --verbose`, () => cmdInitExecutePhase(cwd, testPhase, true));
        global._gsdCompactMode = true;
        const execCompact = measureInProcess(`init execute-phase ${testPhase}`, () => cmdInitExecutePhase(cwd, testPhase, true));
        global._gsdCompactMode = savedCompact;
        if (!execVerbose.error) {
          measurements.push({
            command: `init execute-phase ${testPhase}`,
            variant: "compact (default) vs verbose",
            full_tokens: execVerbose.tokens,
            slim_tokens: execCompact.tokens,
            saved_tokens: execVerbose.tokens - execCompact.tokens,
            saved_percent: execVerbose.tokens > 0 ? Math.round((execVerbose.tokens - execCompact.tokens) / execVerbose.tokens * 100) : 0,
            full_bytes: execVerbose.bytes,
            slim_bytes: execCompact.bytes
          });
        }
        global._gsdCompactMode = false;
        const planVerbose = measureInProcess(`init plan-phase ${testPhase} --verbose`, () => cmdInitPlanPhase(cwd, testPhase, true));
        global._gsdCompactMode = true;
        const planCompact = measureInProcess(`init plan-phase ${testPhase}`, () => cmdInitPlanPhase(cwd, testPhase, true));
        global._gsdCompactMode = savedCompact;
        if (!planVerbose.error) {
          measurements.push({
            command: `init plan-phase ${testPhase}`,
            variant: "compact (default) vs verbose",
            full_tokens: planVerbose.tokens,
            slim_tokens: planCompact.tokens,
            saved_tokens: planVerbose.tokens - planCompact.tokens,
            saved_percent: planVerbose.tokens > 0 ? Math.round((planVerbose.tokens - planCompact.tokens) / planVerbose.tokens * 100) : 0,
            full_bytes: planVerbose.bytes,
            slim_bytes: planCompact.bytes
          });
        }
      }
      const totalFullTokens = measurements.reduce((sum, m) => sum + m.full_tokens, 0);
      const totalSlimTokens = measurements.reduce((sum, m) => sum + m.slim_tokens, 0);
      const totalSavedTokens = totalFullTokens - totalSlimTokens;
      const totalSavedPercent = totalFullTokens > 0 ? Math.round(totalSavedTokens / totalFullTokens * 100) : 0;
      output({
        measurements,
        total_full_tokens: totalFullTokens,
        total_slim_tokens: totalSlimTokens,
        total_saved_tokens: totalSavedTokens,
        total_saved_percent: totalSavedPercent,
        note: 'Measures real JSON output token counts. "full" = verbose/unfiltered, "slim" = compact/filtered.'
      }, raw);
    }
    var WORKFLOW_BUDGETS = {
      "execute-phase": 15e3,
      "plan-phase": 15e3,
      "execute-plan": 12e3,
      "new-project": 25e3,
      "quick": 1e4,
      "progress": 8e3,
      "verify-work": 12e3,
      "resume-project": 8e3,
      "help": 1e4,
      "pause-work": 5e3
    };
    function cmdTokenBudget(cwd, raw) {
      let pluginDir = process.env.GSD_PLUGIN_DIR;
      if (!pluginDir) {
        pluginDir = path.resolve(__dirname, "..");
      }
      const searchDirs = [
        path.join(cwd, "workflows"),
        path.join(pluginDir, "workflows")
      ];
      const homeConfig = process.env.HOME ? path.join(process.env.HOME, ".config", "opencode", "get-shit-done", "workflows") : null;
      if (homeConfig) searchDirs.push(homeConfig);
      let workflowsDir = null;
      for (const dir of searchDirs) {
        if (fs.existsSync(dir)) {
          workflowsDir = dir;
          break;
        }
      }
      const workflows = [];
      let overBudgetCount = 0;
      for (const [name, budgetTokens] of Object.entries(WORKFLOW_BUDGETS)) {
        const fileName = `${name}.md`;
        let content = null;
        if (workflowsDir) {
          const filePath = path.join(workflowsDir, fileName);
          if (fs.existsSync(filePath)) {
            try {
              content = fs.readFileSync(filePath, "utf-8");
            } catch (e) {
              debugLog("feature.tokenBudget", `read workflow failed: ${fileName}`, e);
            }
          }
        }
        if (content === null) {
          workflows.push({ name, actual_tokens: null, budget_tokens: budgetTokens, over_budget: false, percent_of_budget: null, status: "not_found" });
          continue;
        }
        const actualTokens = Math.ceil(content.length / 4);
        const overBudget = actualTokens > budgetTokens;
        const percentOfBudget = Math.round(actualTokens / budgetTokens * 100);
        if (overBudget) overBudgetCount++;
        workflows.push({ name, actual_tokens: actualTokens, budget_tokens: budgetTokens, over_budget: overBudget, percent_of_budget: percentOfBudget });
      }
      output({ workflows, over_budget_count: overBudgetCount, total_workflows: workflows.length }, raw);
    }
    function cmdTestCoverage(cwd, raw) {
      const config = loadConfig(cwd);
      const testFile = config.test_file || "bin/gsd-tools.test.cjs";
      const testPath = path.join(cwd, testFile);
      if (!fs.existsSync(testPath)) {
        error(`Test file not found: ${testFile}`);
      }
      const routerFile = config.router_file || "src/router.js";
      const routerPath = path.join(cwd, routerFile);
      if (!fs.existsSync(routerPath)) {
        error(`Router file not found: ${routerFile}`);
      }
      const testContent = fs.readFileSync(testPath, "utf-8");
      const routerContent = fs.readFileSync(routerPath, "utf-8");
      const routerCommands = /* @__PURE__ */ new Set();
      const casePattern = /^\s{4}case\s+'([^']+)'/gm;
      let caseMatch;
      while ((caseMatch = casePattern.exec(routerContent)) !== null) {
        routerCommands.add(caseMatch[1]);
      }
      const initPattern = /^\s{8}case\s+'([^']+)'/gm;
      let initMatch;
      while ((initMatch = initPattern.exec(routerContent)) !== null) {
        routerCommands.add("init " + initMatch[1]);
      }
      const testedCommands = /* @__PURE__ */ new Set();
      const runPattern = /runGsdTools\(\s*['"`]([^'"`]+)['"`]/g;
      let runMatch;
      while ((runMatch = runPattern.exec(testContent)) !== null) {
        const fullCmd = runMatch[1].trim();
        const words = fullCmd.split(/\s+/);
        const cmd = words[0];
        testedCommands.add(cmd);
        if (words.length > 1 && ["init", "state", "verify", "memory", "roadmap", "phase", "phases", "frontmatter", "template", "validate", "milestone", "requirements", "context-budget", "todo"].includes(cmd)) {
          testedCommands.add(cmd + " " + words[1]);
        }
      }
      const templatePattern = /runGsdTools\(\s*`([^`]+)`/g;
      let templateMatch;
      while ((templateMatch = templatePattern.exec(testContent)) !== null) {
        const fullCmd = templateMatch[1].replace(/\$\{[^}]+\}/g, "X").trim();
        const words = fullCmd.split(/\s+/);
        const cmd = words[0];
        testedCommands.add(cmd);
        if (words.length > 1 && ["init", "state", "verify", "memory", "roadmap", "phase", "phases", "frontmatter", "template", "validate", "milestone", "requirements", "context-budget", "todo"].includes(cmd)) {
          testedCommands.add(cmd + " " + words[1]);
        }
      }
      const describePattern = /describe\(\s*['"`]([^'"`]+)['"`]/g;
      let describeMatch;
      while ((describeMatch = describePattern.exec(testContent)) !== null) {
        const desc = describeMatch[1].trim();
        const descWords = desc.split(/[\s:]+/);
        for (const word of descWords) {
          if (routerCommands.has(word)) {
            testedCommands.add(word);
          }
        }
      }
      const testMatches = testContent.match(/\btest\s*\(/g) || [];
      const testCount = testMatches.length;
      const allCommands = [...routerCommands].sort();
      const covered = allCommands.filter((cmd) => {
        if (testedCommands.has(cmd)) return true;
        const base = cmd.split(" ")[0];
        if (testedCommands.has(base) && cmd.startsWith("init ")) {
          return testedCommands.has(cmd);
        }
        return false;
      });
      const uncovered = allCommands.filter((cmd) => !covered.includes(cmd));
      const totalCommands = allCommands.length;
      const commandsWithTests = covered.length;
      const coveragePercent = totalCommands > 0 ? Math.round(commandsWithTests / totalCommands * 100) : 0;
      output({
        total_commands: totalCommands,
        commands_with_tests: commandsWithTests,
        coverage_percent: coveragePercent,
        covered,
        uncovered,
        test_count: testCount
      }, raw);
    }
    function cmdSessionSummary(cwd, raw) {
      const pd = path.join(cwd, ".planning");
      const sc = safeReadFile(path.join(pd, "STATE.md"));
      if (!sc) {
        output({ error: "STATE.md not found" }, raw);
        return;
      }
      const xf = (f) => {
        const m = sc.match(new RegExp(`\\*\\*${f}:\\*\\*\\s*(.+)`, "i"));
        return m ? m[1].trim() : null;
      };
      const pm = (xf("Phase") || "").match(/(\d+)\s*of\s*(\d+)\s*\(([^)]+)\)/);
      const phaseNum = pm ? pm[1] : xf("Phase");
      const phaseName = pm ? pm[3] : null;
      const plan = xf("Current Plan") || "Not started";
      const status = xf("Status") || "Unknown";
      const lastAct = xf("Last Activity");
      const completed = [];
      if (lastAct && isValidDateString(lastAct)) {
        const sessionLog = execGit(cwd, ["log", `--since=${lastAct}`, "--oneline", "--no-merges", "--", ".planning/"]);
        if (sessionLog.exitCode === 0 && sessionLog.stdout) {
          for (const l of sessionLog.stdout.split("\n")) {
            const m = l.match(/(?:feat|fix|docs|chore|refactor|test|perf)\((\d+-\d+)\)/);
            if (m && !completed.includes(m[1])) completed.push(m[1]);
          }
        }
      }
      const ds = sc.match(/### Decisions\s*\n([\s\S]*?)(?=\n###|\n## |\n$)/);
      const decisions = [];
      if (ds) for (const l of ds[1].split("\n")) {
        const m = l.match(/^-\s*(?:\[Phase \d+\]:\s*)?(.{10,})/);
        if (m && !m[1].startsWith("All v")) decisions.push(m[1].trim());
      }
      let next = { command: "/gsd-resume", description: "Resume project work" };
      const rc = safeReadFile(path.join(pd, "ROADMAP.md"));
      if (rc && phaseNum) {
        const unchecked = [];
        let um;
        const up = /- \[ \] \*\*Phase (\d+):\s*([^*]+)\*\*/g;
        while ((um = up.exec(rc)) !== null) unchecked.push({ n: um[1], name: um[2].trim() });
        const pDir = path.join(pd, "phases");
        const countPlans = (num) => {
          try {
            const dirs = fs.readdirSync(pDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name);
            const d = dirs.find((d2) => d2.startsWith(normalizePhaseName(num) + "-"));
            if (!d) return { plans: 0, summaries: 0 };
            const files = fs.readdirSync(path.join(pDir, d));
            return { plans: files.filter((f) => f.endsWith("-PLAN.md")).length, summaries: files.filter((f) => f.endsWith("-SUMMARY.md")).length };
          } catch (e) {
            return { plans: 0, summaries: 0 };
          }
        };
        const cur = countPlans(phaseNum);
        if (cur.plans > 0 && cur.summaries < cur.plans) {
          next = { command: `/gsd-execute-phase ${phaseNum}`, description: `Continue Phase ${phaseNum}: ${phaseName || "current"}` };
        } else if (unchecked.length > 0) {
          const np = unchecked.find((p) => parseInt(p.n) > parseInt(phaseNum));
          if (np) {
            const nc = countPlans(np.n);
            next = nc.plans > 0 ? { command: `/gsd-execute-phase ${np.n}`, description: `Execute Phase ${np.n}: ${np.name}` } : { command: `/gsd-plan-phase ${np.n}`, description: `Plan Phase ${np.n}: ${np.name}` };
          } else {
            next = { command: "/gsd-complete-milestone", description: "All phases done \u2014 complete milestone" };
          }
        } else {
          next = { command: "/gsd-complete-milestone", description: "All phases done \u2014 complete milestone" };
        }
      }
      const sa = sc.match(/Stopped at:\s*(.+)/);
      const rf = sc.match(/Resume file:\s*(.+)/);
      output({
        current_position: { phase: pm ? `${pm[1]} of ${pm[2]}` : phaseNum || "Unknown", phase_name: phaseName || "Unknown", plan, status },
        session_activity: { plans_completed: completed, decisions_made: decisions.slice(-5), blockers_resolved: [], last_activity: lastAct || "Unknown" },
        next_action: next,
        session_continuity: { stopped_at: sa ? sa[1].trim() : `Phase ${phaseNum || "?"} \u2014 ${status}`, resume_file: rf ? rf[1].trim() : "None" }
      }, raw);
    }
    module2.exports = {
      cmdSessionDiff,
      cmdContextBudget,
      cmdContextBudgetBaseline,
      cmdContextBudgetCompare,
      cmdContextBudgetMeasure,
      cmdTestRun,
      cmdSearchDecisions,
      cmdValidateDependencies,
      cmdSearchLessons,
      cmdCodebaseImpact,
      cmdRollbackInfo,
      cmdVelocity,
      cmdTraceRequirement,
      cmdValidateConfig,
      cmdQuickTaskSummary,
      cmdExtractSections,
      extractSectionsFromFile,
      cmdTokenBudget,
      cmdTestCoverage,
      cmdSessionSummary
    };
  }
});

// src/commands/memory.js
var require_memory = __commonJS({
  "src/commands/memory.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    var { output, error, debugLog } = require_output();
    var VALID_STORES = ["decisions", "bookmarks", "lessons", "todos"];
    var SACRED_STORES = ["decisions", "lessons"];
    var BOOKMARKS_MAX = 20;
    var COMPACT_THRESHOLD = 50;
    var COMPACT_KEEP_RECENT = 10;
    function cmdMemoryEnsureDir(cwd) {
      const dir = path.join(cwd, ".planning", "memory");
      fs.mkdirSync(dir, { recursive: true });
      output({ ensured: true, memory_dir: dir });
    }
    function cmdMemoryWrite(cwd, options, raw) {
      const { store, entry: entryJson } = options;
      if (!store || !VALID_STORES.includes(store)) {
        error(`Invalid or missing store. Must be one of: ${VALID_STORES.join(", ")}`);
      }
      if (!entryJson) {
        error("Missing --entry (JSON string)");
      }
      let entry;
      try {
        entry = JSON.parse(entryJson);
      } catch (e) {
        error(`Invalid JSON in --entry: ${e.message}`);
      }
      const memDir = path.join(cwd, ".planning", "memory");
      fs.mkdirSync(memDir, { recursive: true });
      const filePath = path.join(memDir, `${store}.json`);
      let entries = [];
      try {
        const raw2 = fs.readFileSync(filePath, "utf-8");
        entries = JSON.parse(raw2);
        if (!Array.isArray(entries)) entries = [];
      } catch (e) {
        debugLog("memory.write", "read failed, starting fresh", e);
        entries = [];
      }
      if (!entry.timestamp) {
        entry.timestamp = (/* @__PURE__ */ new Date()).toISOString();
      }
      if (store === "bookmarks") {
        entries.unshift(entry);
        if (entries.length > BOOKMARKS_MAX) {
          entries = entries.slice(0, BOOKMARKS_MAX);
        }
      } else {
        entries.push(entry);
      }
      fs.writeFileSync(filePath, JSON.stringify(entries, null, 2), "utf-8");
      const result = { written: true, store, entry_count: entries.length };
      if (!SACRED_STORES.includes(store) && entries.length > COMPACT_THRESHOLD) {
        result.compact_needed = true;
        result.threshold = COMPACT_THRESHOLD;
      }
      output(result);
    }
    function cmdMemoryRead(cwd, options, raw) {
      const { store, limit, query, phase } = options;
      if (!store || !VALID_STORES.includes(store)) {
        error(`Invalid or missing store. Must be one of: ${VALID_STORES.join(", ")}`);
      }
      const filePath = path.join(cwd, ".planning", "memory", `${store}.json`);
      let entries = [];
      try {
        const raw2 = fs.readFileSync(filePath, "utf-8");
        entries = JSON.parse(raw2);
        if (!Array.isArray(entries)) entries = [];
      } catch (e) {
        debugLog("memory.read", "read failed", e);
        entries = [];
      }
      const total = entries.length;
      if (phase) {
        entries = entries.filter((e) => e.phase && String(e.phase) === String(phase));
      }
      if (query) {
        const q = query.toLowerCase();
        entries = entries.filter((e) => {
          return Object.values(e).some((v) => {
            if (typeof v === "string") return v.toLowerCase().includes(q);
            return false;
          });
        });
      }
      if (limit && parseInt(limit, 10) > 0) {
        entries = entries.slice(0, parseInt(limit, 10));
      }
      output({ entries, count: entries.length, store, total });
    }
    function cmdMemoryList(cwd, options, raw) {
      const memDir = path.join(cwd, ".planning", "memory");
      const stores = [];
      try {
        const files = fs.readdirSync(memDir);
        for (const file of files) {
          if (!file.endsWith(".json")) continue;
          const filePath = path.join(memDir, file);
          const stat = fs.statSync(filePath);
          let entryCount = 0;
          try {
            const data = JSON.parse(fs.readFileSync(filePath, "utf-8"));
            if (Array.isArray(data)) entryCount = data.length;
          } catch (e) {
            debugLog("memory.list", `parse failed for ${file}`, e);
          }
          stores.push({
            name: file.replace(".json", ""),
            entry_count: entryCount,
            size_bytes: stat.size,
            last_modified: stat.mtime.toISOString()
          });
        }
      } catch (e) {
        debugLog("memory.list", "readdir failed", e);
      }
      output({ stores, memory_dir: memDir });
    }
    function cmdMemoryCompact(cwd, options, raw) {
      const { store, threshold: thresholdStr, dryRun } = options;
      const threshold = thresholdStr ? parseInt(thresholdStr, 10) : COMPACT_THRESHOLD;
      if (store && !VALID_STORES.includes(store)) {
        error(`Invalid store. Must be one of: ${VALID_STORES.join(", ")}`);
      }
      const memDir = path.join(cwd, ".planning", "memory");
      const storesToProcess = store ? [store] : VALID_STORES;
      const result = {
        compacted: false,
        stores_processed: [],
        entries_before: {},
        entries_after: {},
        summaries_created: {},
        sacred_skipped: []
      };
      for (const s of storesToProcess) {
        if (SACRED_STORES.includes(s)) {
          result.sacred_skipped.push(s);
          continue;
        }
        const filePath = path.join(memDir, `${s}.json`);
        let entries = [];
        try {
          const rawData = fs.readFileSync(filePath, "utf-8");
          entries = JSON.parse(rawData);
          if (!Array.isArray(entries)) entries = [];
        } catch (e) {
          debugLog("memory.compact", `read failed for ${s}`, e);
          continue;
        }
        const beforeCount = entries.length;
        result.entries_before[s] = beforeCount;
        if (beforeCount <= threshold) {
          result.entries_after[s] = beforeCount;
          result.summaries_created[s] = 0;
          result.stores_processed.push(s);
          continue;
        }
        let compactedEntries;
        let summariesCreated = 0;
        if (s === "bookmarks") {
          const kept = entries.slice(0, COMPACT_KEEP_RECENT);
          const old = entries.slice(COMPACT_KEEP_RECENT);
          const summarized = old.map((e) => {
            const ts = e.timestamp || "";
            const date = ts ? ts.split("T")[0] : "unknown";
            const phase = e.phase || "?";
            const plan = e.plan || "?";
            const task = e.task !== void 0 ? e.task : "?";
            return {
              summary: `${date}: Phase ${phase}, Plan ${plan}, Task ${task}`,
              original_timestamp: ts
            };
          });
          summariesCreated = summarized.length;
          compactedEntries = [...kept, ...summarized];
        } else if (s === "todos") {
          const active = [];
          const completedSummaries = [];
          for (const e of entries) {
            const isCompleted = e.completed === true || e.status === "completed" || e.status === "done";
            if (isCompleted) {
              const ts = e.timestamp || "";
              const date = ts ? ts.split("T")[0] : "unknown";
              const text = e.text || e.summary || e.title || "todo";
              completedSummaries.push({
                summary: `${date}: [completed] ${text}`,
                original_timestamp: ts
              });
            } else {
              active.push(e);
            }
          }
          summariesCreated = completedSummaries.length;
          compactedEntries = [...active, ...completedSummaries];
        } else {
          result.entries_after[s] = beforeCount;
          result.summaries_created[s] = 0;
          result.stores_processed.push(s);
          continue;
        }
        result.entries_after[s] = compactedEntries.length;
        result.summaries_created[s] = summariesCreated;
        result.stores_processed.push(s);
        if (summariesCreated > 0) {
          result.compacted = true;
        }
        if (!dryRun) {
          fs.mkdirSync(memDir, { recursive: true });
          fs.writeFileSync(filePath, JSON.stringify(compactedEntries, null, 2), "utf-8");
        }
      }
      if (store && SACRED_STORES.includes(store)) {
        output({ compacted: false, reason: "sacred_data" });
        return;
      }
      if (dryRun) {
        result.dry_run = true;
      }
      output(result);
    }
    module2.exports = { cmdMemoryWrite, cmdMemoryRead, cmdMemoryList, cmdMemoryEnsureDir, cmdMemoryCompact };
  }
});

// src/commands/mcp.js
var require_mcp = __commonJS({
  "src/commands/mcp.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var { output, error, debugLog } = require_output();
    var MCP_KNOWN_SERVERS = [
      { name: "postgres", patterns: [/postgres/i, /toolbox.*postgres/i], tool_count: 12, base_tokens: 700, total_estimate: 4500 },
      { name: "github", patterns: [/github/i], tool_count: 30, base_tokens: 1500, total_estimate: 46e3 },
      { name: "brave-search", patterns: [/brave[_-]?search/i, /server-brave-search/i], tool_count: 3, base_tokens: 500, total_estimate: 2500 },
      { name: "context7", patterns: [/context7/i], tool_count: 2, base_tokens: 300, total_estimate: 1500 },
      { name: "terraform", patterns: [/terraform/i], tool_count: 8, base_tokens: 800, total_estimate: 6e3 },
      { name: "docker", patterns: [/^docker$/i, /docker-mcp/i], tool_count: 10, base_tokens: 500, total_estimate: 5e3 },
      { name: "podman", patterns: [/podman/i], tool_count: 10, base_tokens: 500, total_estimate: 5e3 },
      { name: "filesystem", patterns: [/filesystem/i, /server-filesystem/i], tool_count: 8, base_tokens: 500, total_estimate: 3e3 },
      { name: "puppeteer", patterns: [/puppeteer/i], tool_count: 12, base_tokens: 800, total_estimate: 8e3 },
      { name: "sqlite", patterns: [/sqlite/i], tool_count: 6, base_tokens: 500, total_estimate: 3e3 },
      { name: "redis", patterns: [/redis/i], tool_count: 8, base_tokens: 500, total_estimate: 3500 },
      { name: "rabbitmq", patterns: [/rabbitmq/i, /queue[_-]?pilot/i], tool_count: 6, base_tokens: 500, total_estimate: 3e3 },
      { name: "pulsar", patterns: [/pulsar/i, /snmcp/i], tool_count: 8, base_tokens: 500, total_estimate: 4e3 },
      { name: "consul", patterns: [/consul/i], tool_count: 5, base_tokens: 400, total_estimate: 2500 },
      { name: "vault", patterns: [/vault/i], tool_count: 8, base_tokens: 500, total_estimate: 4e3 },
      { name: "slack", patterns: [/slack/i], tool_count: 15, base_tokens: 1e3, total_estimate: 12e3 },
      { name: "linear", patterns: [/linear/i], tool_count: 20, base_tokens: 1e3, total_estimate: 15e3 },
      { name: "notion", patterns: [/notion/i], tool_count: 12, base_tokens: 800, total_estimate: 6e3 },
      { name: "sentry", patterns: [/sentry/i], tool_count: 8, base_tokens: 600, total_estimate: 4e3 },
      { name: "datadog", patterns: [/datadog/i], tool_count: 10, base_tokens: 800, total_estimate: 5e3 }
    ];
    var DEFAULT_TOKENS_PER_TOOL = 150;
    var DEFAULT_BASE_TOKENS = 400;
    var DEFAULT_CONTEXT_WINDOW = 2e5;
    var LOW_COST_THRESHOLD = 1e3;
    var RELEVANCE_INDICATORS = {
      postgres: { files: ["prisma/schema.prisma", "migrations/", "db/", "ecto/", "schema.sql", "knexfile.js", "drizzle.config.ts"], patterns: ["*.sql"], description: "Database schema or migrations detected" },
      github: { files: [".github/", ".git/"], description: "Git repository detected" },
      terraform: { files: ["terraform/", ".terraform/"], patterns: ["*.tf"], description: "Terraform configuration files detected" },
      docker: { files: ["Dockerfile", "docker-compose.yml", "docker-compose.yaml", ".dockerignore"], description: "Docker configuration detected" },
      "brave-search": { description: "General-purpose web search (always useful)", always_relevant: true },
      context7: { description: "Documentation lookup (always useful)", always_relevant: true },
      redis: { files: ["redis.conf"], env_hints: ["REDIS_URL", "REDIS_HOST"], description: "Redis configuration or environment hints detected" },
      rabbitmq: { files: ["schemas/", "rabbitmq.conf"], env_hints: ["RABBITMQ_URL", "AMQP_URL"], description: "Message queue schemas or config detected" },
      pulsar: { env_hints: ["PULSAR_SERVICE_URL"], description: "Pulsar connection configured" },
      consul: { files: ["consul.hcl", "consul/"], env_hints: ["CONSUL_HTTP_ADDR"], description: "Consul configuration detected" },
      vault: { files: ["vault.hcl", "vault/"], env_hints: ["VAULT_ADDR"], description: "Vault configuration detected" },
      sqlite: { patterns: ["*.sqlite", "*.db"], description: "SQLite database files detected" },
      puppeteer: { files: ["puppeteer.config.js", ".puppeteerrc"], description: "Puppeteer/browser automation config detected" },
      slack: { files: ["slack.json", ".slack/"], env_hints: ["SLACK_BOT_TOKEN", "SLACK_WEBHOOK_URL"], description: "Slack integration detected" },
      filesystem: { description: "Filesystem access (always useful for coding)", always_relevant: true },
      podman: { files: ["Containerfile", "Dockerfile", "podman-compose.yml"], description: "Container configuration detected" }
    };
    function safeReadJson(filePath) {
      try {
        if (!fs.existsSync(filePath)) return null;
        return JSON.parse(fs.readFileSync(filePath, "utf-8"));
      } catch {
        debugLog("mcp.discovery", `failed to parse ${filePath}`);
        return null;
      }
    }
    function extractFromMcpJson(filePath) {
      const data = safeReadJson(filePath);
      if (!data || !data.mcpServers || typeof data.mcpServers !== "object") return [];
      const servers = [];
      for (const [name, config] of Object.entries(data.mcpServers)) {
        if (!config || typeof config !== "object") continue;
        servers.push({ name, source: ".mcp.json", transport: "stdio", command: (typeof config.command === "string" ? config.command : null) || "unknown", args: Array.isArray(config.args) ? config.args : [] });
      }
      return servers;
    }
    function extractFromOpencodeJson(filePath, sourceName) {
      const data = safeReadJson(filePath);
      if (!data || !data.mcp || typeof data.mcp !== "object") return [];
      const servers = [];
      for (const [name, config] of Object.entries(data.mcp)) {
        if (!config || typeof config !== "object") continue;
        const transport = config.type === "remote" ? "remote" : "stdio";
        let command = "unknown", args = [];
        if (transport === "remote") {
          command = config.url || "unknown";
        } else if (Array.isArray(config.command)) {
          command = config.command[0] || "unknown";
          args = config.command.slice(1);
        } else if (typeof config.command === "string") {
          command = config.command;
        }
        servers.push({ name, source: sourceName || path.basename(filePath), transport, command, args });
      }
      return servers;
    }
    function discoverMcpServers(cwd) {
      const mcpJsonServers = extractFromMcpJson(path.join(cwd, ".mcp.json"));
      const opencodeServers = extractFromOpencodeJson(path.join(cwd, "opencode.json"), "opencode.json");
      const homeConfig = path.join(process.env.HOME || process.env.USERPROFILE || "~", ".config", "opencode", "opencode.json");
      const userServers = extractFromOpencodeJson(homeConfig, "~/.config/opencode/opencode.json");
      const serverMap = /* @__PURE__ */ new Map();
      for (const s of mcpJsonServers) serverMap.set(s.name, s);
      for (const s of opencodeServers) {
        if (!serverMap.has(s.name)) serverMap.set(s.name, s);
      }
      for (const s of userServers) {
        if (!serverMap.has(s.name)) serverMap.set(s.name, s);
      }
      return Array.from(serverMap.values()).sort((a, b) => a.name.localeCompare(b.name));
    }
    function estimateTokenCost(server, knownServers) {
      const db = knownServers || MCP_KNOWN_SERVERS;
      for (const known of db) {
        for (const pattern of known.patterns) {
          const testStr = `${server.name} ${server.command} ${(server.args || []).join(" ")}`;
          if (pattern instanceof RegExp) {
            if (pattern.test(server.name) || pattern.test(server.command) || pattern.test(testStr)) {
              return {
                matched: true,
                server_name: known.name,
                tool_count: known.tool_count,
                token_estimate: known.total_estimate,
                source: "known-db"
              };
            }
          } else if (typeof pattern === "string") {
            const lowerTest = testStr.toLowerCase();
            if (lowerTest.includes(pattern.toLowerCase())) {
              return {
                matched: true,
                server_name: known.name,
                tool_count: known.tool_count,
                token_estimate: known.total_estimate,
                source: "known-db"
              };
            }
          }
        }
      }
      const defaultToolCount = 5;
      const estimate = defaultToolCount * DEFAULT_TOKENS_PER_TOOL + DEFAULT_BASE_TOKENS;
      return {
        matched: false,
        server_name: server.name,
        tool_count: defaultToolCount,
        token_estimate: estimate,
        source: "default-estimate"
      };
    }
    function matchIndicatorKey(serverName) {
      const lower = serverName.toLowerCase();
      if (RELEVANCE_INDICATORS[lower]) return lower;
      for (const key of Object.keys(RELEVANCE_INDICATORS)) {
        if (lower.includes(key) || key.includes(lower)) return key;
      }
      return null;
    }
    function checkEnvHints(envHints, cwd) {
      if (!envHints || envHints.length === 0) return false;
      const envFiles = [".env", ".env.local", ".env.development", "docker-compose.yml", "docker-compose.yaml"];
      for (const envFile of envFiles) {
        const filePath = path.join(cwd, envFile);
        try {
          if (!fs.existsSync(filePath)) continue;
          const content = fs.readFileSync(filePath, "utf-8");
          for (const hint of envHints) {
            if (content.includes(hint)) return true;
          }
        } catch {
        }
      }
      return false;
    }
    function scoreServerRelevance(server, cwd) {
      const indicatorKey = matchIndicatorKey(server.name);
      if (indicatorKey) {
        const indicator = RELEVANCE_INDICATORS[indicatorKey];
        if (indicator.always_relevant) {
          return { score: "relevant", reason: indicator.description };
        }
        if (server.token_estimate && server.token_estimate < LOW_COST_THRESHOLD) {
          return { score: "relevant", reason: "Low cost (<1K tokens) \u2014 not worth disabling" };
        }
        const files = indicator.files || [];
        for (const file of files) {
          try {
            if (fs.existsSync(path.join(cwd, file))) return { score: "relevant", reason: indicator.description };
          } catch {
          }
        }
        const patterns = indicator.patterns || [];
        for (const pattern of patterns) {
          if (pattern.startsWith("*.")) {
            const ext = pattern.slice(1);
            try {
              if (fs.readdirSync(cwd).some((e) => e.endsWith(ext))) return { score: "relevant", reason: indicator.description };
            } catch {
            }
          }
        }
        if (checkEnvHints(indicator.env_hints, cwd)) {
          return { score: "possibly-relevant", reason: "Environment hints found but no project files" };
        }
        return { score: "not-relevant", reason: "No project files matching this server type" };
      }
      if (server.token_estimate && server.token_estimate < LOW_COST_THRESHOLD) {
        return { score: "relevant", reason: "Low cost (<1K tokens) \u2014 not worth disabling" };
      }
      return { score: "possibly-relevant", reason: "Unknown server \u2014 manual review recommended" };
    }
    function generateRecommendations(servers, cwd, contextWindow) {
      contextWindow = contextWindow || DEFAULT_CONTEXT_WINDOW;
      let totalPotentialSavings = 0;
      const summary = { keep: 0, disable: 0, review: 0 };
      const enriched = servers.map((server) => {
        const { score, reason } = scoreServerRelevance(server, cwd);
        let recommendation;
        let recommendationReason;
        if (score === "relevant") {
          recommendation = "keep";
          recommendationReason = reason;
          summary.keep++;
        } else if (score === "possibly-relevant") {
          recommendation = "review";
          recommendationReason = "Check if this server is needed for your workflow";
          summary.review++;
        } else {
          recommendation = "disable";
          const tokenSave = server.token_estimate || 0;
          const pct = (tokenSave / contextWindow * 100).toFixed(1);
          recommendationReason = `No matching project files found \u2014 saves ${tokenSave} tokens (${pct}%)`;
          totalPotentialSavings += tokenSave;
          summary.disable++;
        }
        return {
          ...server,
          relevance: score,
          recommendation,
          recommendation_reason: recommendationReason
        };
      });
      const totalTokens = servers.reduce((sum, s) => sum + (s.token_estimate || 0), 0);
      const potentialSavingsPercent = totalTokens > 0 ? (totalPotentialSavings / contextWindow * 100).toFixed(1) + "%" : "0.0%";
      return {
        servers: enriched,
        total_potential_savings: totalPotentialSavings,
        potential_savings_percent: potentialSavingsPercent,
        recommendations_summary: summary
      };
    }
    function applyRecommendations(cwd, servers) {
      const cfgPath = path.join(cwd, "opencode.json");
      const bakPath = path.join(cwd, "opencode.json.bak");
      if (!fs.existsSync(cfgPath)) return { applied: false, reason: "No opencode.json found \u2014 only OpenCode configs support disable" };
      let config;
      try {
        config = JSON.parse(fs.readFileSync(cfgPath, "utf-8"));
      } catch (e) {
        return { applied: false, reason: `Failed to parse opencode.json: ${e.message}` };
      }
      if (!config.mcp || typeof config.mcp !== "object") return { applied: false, reason: "No mcp section in opencode.json" };
      fs.copyFileSync(cfgPath, bakPath);
      const toDisable = servers.filter((s) => s.recommendation === "disable" && s.source === "opencode.json");
      const disabled = [];
      let saved = 0;
      for (const s of toDisable) {
        if (config.mcp[s.name]) {
          config.mcp[s.name].enabled = false;
          disabled.push(s.name);
          saved += s.token_estimate || 0;
        }
      }
      fs.writeFileSync(cfgPath, JSON.stringify(config, null, 2) + "\n");
      const skipped = servers.filter((s) => s.recommendation === "disable" && s.source === ".mcp.json").map((s) => s.name);
      return { applied: true, backup_path: "opencode.json.bak", disabled_count: disabled.length, disabled_servers: disabled, tokens_saved: saved, skipped_mcp_json: skipped.length > 0 ? skipped : void 0 };
    }
    function restoreBackup(cwd) {
      const cfgPath = path.join(cwd, "opencode.json");
      const bakPath = path.join(cwd, "opencode.json.bak");
      if (!fs.existsSync(bakPath)) return { restored: false, reason: "No backup found (opencode.json.bak)" };
      fs.copyFileSync(bakPath, cfgPath);
      fs.unlinkSync(bakPath);
      return { restored: true, message: "Restored opencode.json from backup" };
    }
    function cmdMcpProfile(cwd, args, raw) {
      const hasApply = args.includes("--apply");
      const hasRestore = args.includes("--restore");
      const hasDryRun = args.includes("--dry-run");
      if (hasRestore) {
        const result2 = restoreBackup(cwd);
        output(result2, raw);
        return;
      }
      let contextWindow = DEFAULT_CONTEXT_WINDOW;
      const windowIdx = args.indexOf("--window");
      if (windowIdx !== -1 && args[windowIdx + 1]) {
        const parsed = parseInt(args[windowIdx + 1], 10);
        if (!isNaN(parsed) && parsed > 0) {
          contextWindow = parsed;
        }
      }
      const servers = discoverMcpServers(cwd);
      let totalTokens = 0;
      let knownCount = 0;
      let unknownCount = 0;
      const serverResults = servers.map((server) => {
        const cost = estimateTokenCost(server);
        totalTokens += cost.token_estimate;
        if (cost.source === "known-db") {
          knownCount++;
        } else {
          unknownCount++;
        }
        const contextPercent = (cost.token_estimate / contextWindow * 100).toFixed(1) + "%";
        return {
          name: server.name,
          source: server.source,
          transport: server.transport,
          command: server.command,
          tool_count: cost.tool_count,
          token_estimate: cost.token_estimate,
          token_source: cost.source,
          context_percent: contextPercent
        };
      });
      const recommendations = generateRecommendations(serverResults, cwd, contextWindow);
      const totalContextPercent = (totalTokens / contextWindow * 100).toFixed(1) + "%";
      const result = {
        servers: recommendations.servers,
        total_tokens: totalTokens,
        total_context_percent: totalContextPercent,
        context_window: contextWindow,
        server_count: servers.length,
        known_count: knownCount,
        unknown_count: unknownCount,
        total_potential_savings: recommendations.total_potential_savings,
        potential_savings_percent: recommendations.potential_savings_percent,
        recommendations_summary: recommendations.recommendations_summary
      };
      if (hasApply && !hasDryRun) {
        result.apply_result = applyRecommendations(cwd, recommendations.servers);
      } else if (hasApply && hasDryRun) {
        const wd = recommendations.servers.filter((s) => s.recommendation === "disable" && s.source === "opencode.json");
        result.dry_run = { would_disable: wd.map((s) => s.name), would_disable_count: wd.length, tokens_would_save: wd.reduce((sum, s) => sum + (s.token_estimate || 0), 0), skipped_mcp_json: recommendations.servers.filter((s) => s.recommendation === "disable" && s.source === ".mcp.json").map((s) => s.name) };
      }
      output(result, raw);
    }
    module2.exports = {
      cmdMcpProfile,
      discoverMcpServers,
      estimateTokenCost,
      scoreServerRelevance,
      generateRecommendations,
      applyRecommendations,
      restoreBackup,
      MCP_KNOWN_SERVERS,
      RELEVANCE_INDICATORS,
      DEFAULT_CONTEXT_WINDOW,
      DEFAULT_TOKENS_PER_TOOL,
      DEFAULT_BASE_TOKENS,
      LOW_COST_THRESHOLD,
      // Internal helpers exported for testing
      extractFromMcpJson,
      extractFromOpencodeJson,
      safeReadJson,
      matchIndicatorKey,
      checkEnvHints
    };
  }
});

// src/lib/profiler.js
var require_profiler = __commonJS({
  "src/lib/profiler.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var enabled = process.env.GSD_PROFILE === "1";
    var timings = [];
    function isProfilingEnabled() {
      return enabled;
    }
    function mark(label) {
      if (!enabled) return;
      const { performance } = require("node:perf_hooks");
      performance.mark(label);
    }
    function measure(label, startMark, endMark) {
      if (!enabled) return;
      const { performance } = require("node:perf_hooks");
      try {
        const m = performance.measure(label, startMark, endMark);
        timings.push({ label, duration_ms: Math.round(m.duration * 100) / 100 });
      } catch (e) {
      }
    }
    function startTimer(label) {
      if (!enabled) return null;
      const { performance } = require("node:perf_hooks");
      return { label, start: performance.now() };
    }
    function endTimer(timer) {
      if (!enabled || !timer) return null;
      const { performance } = require("node:perf_hooks");
      const duration_ms = Math.round((performance.now() - timer.start) * 100) / 100;
      const entry = { label: timer.label, duration_ms };
      timings.push(entry);
      return entry;
    }
    function getTimings() {
      return [...timings];
    }
    function writeBaseline(cwd, commandName) {
      if (!enabled) return;
      const totalMs = timings.reduce((sum, t) => sum + t.duration_ms, 0);
      const timestamp = (/* @__PURE__ */ new Date()).toISOString();
      const safeTimestamp = timestamp.replace(/[:.]/g, "-");
      const baseline = {
        command: commandName,
        timestamp,
        node_version: process.version,
        timings: [...timings],
        total_ms: Math.round(totalMs * 100) / 100
      };
      const baselinesDir = path.join(cwd, ".planning", "baselines");
      try {
        fs.mkdirSync(baselinesDir, { recursive: true });
        const filename = `${commandName}-${safeTimestamp}.json`;
        fs.writeFileSync(path.join(baselinesDir, filename), JSON.stringify(baseline, null, 2) + "\n", "utf-8");
      } catch (e) {
        if (process.env.GSD_DEBUG) {
          process.stderr.write(`[GSD_DEBUG] profiler.writeBaseline: ${e.message}
`);
        }
      }
    }
    module2.exports = { isProfilingEnabled, mark, measure, startTimer, endTimer, getTimings, writeBaseline };
  }
});

// src/router.js
var require_router = __commonJS({
  "src/router.js"(exports2, module2) {
    "use strict";
    var { COMMAND_HELP } = require_constants();
    var { error } = require_output();
    var _modules = {};
    function lazyState() {
      return _modules.state || (_modules.state = require_state());
    }
    function lazyRoadmap() {
      return _modules.roadmap || (_modules.roadmap = require_roadmap());
    }
    function lazyPhase() {
      return _modules.phase || (_modules.phase = require_phase());
    }
    function lazyVerify() {
      return _modules.verify || (_modules.verify = require_verify());
    }
    function lazyInit() {
      return _modules.init || (_modules.init = require_init());
    }
    function lazyFeatures() {
      return _modules.features || (_modules.features = require_features());
    }
    function lazyMisc() {
      return _modules.misc || (_modules.misc = require_misc());
    }
    function lazyMemory() {
      return _modules.memory || (_modules.memory = require_memory());
    }
    function lazyIntent() {
      return _modules.intent || (_modules.intent = require_intent());
    }
    function lazyEnv() {
      return _modules.env || (_modules.env = require_env());
    }
    function lazyMcp() {
      return _modules.mcp || (_modules.mcp = require_mcp());
    }
    function lazyWorktree() {
      return _modules.worktree || (_modules.worktree = require_worktree());
    }
    function lazyCodebase() {
      return _modules.codebase || (_modules.codebase = require_codebase());
    }
    function lazyGit() {
      return _modules.git || (_modules.git = require_git());
    }
    function lazyOrchestration() {
      return _modules.orchestration || (_modules.orchestration = require_orchestration());
    }
    async function main2() {
      const args = process.argv.slice(2);
      const prettyIdx = args.indexOf("--pretty");
      if (prettyIdx !== -1) {
        global._gsdOutputMode = "pretty";
        args.splice(prettyIdx, 1);
      }
      if (global._gsdOutputMode === void 0) {
        global._gsdOutputMode = process.stdout.isTTY ? "formatted" : "json";
      }
      const rawIndex = args.indexOf("--raw");
      if (rawIndex !== -1) args.splice(rawIndex, 1);
      const raw = global._gsdOutputMode === "json" || global._gsdOutputMode !== "pretty" && !process.stdout.isTTY;
      const fieldsIdx = args.indexOf("--fields");
      if (fieldsIdx !== -1) {
        const fieldsValue = args[fieldsIdx + 1];
        const requestedFields = fieldsValue ? fieldsValue.split(",") : null;
        args.splice(fieldsIdx, 2);
        if (requestedFields) {
          global._gsdRequestedFields = requestedFields;
        }
      }
      const verboseIdx = args.indexOf("--verbose");
      if (verboseIdx !== -1) {
        global._gsdCompactMode = false;
        args.splice(verboseIdx, 1);
      } else if (global._gsdCompactMode === void 0) {
        global._gsdCompactMode = true;
      }
      const compactIdx = args.indexOf("--compact");
      if (compactIdx !== -1) {
        global._gsdCompactMode = true;
        args.splice(compactIdx, 1);
      }
      const manifestIdx = args.indexOf("--manifest");
      if (manifestIdx !== -1) {
        global._gsdManifestMode = true;
        args.splice(manifestIdx, 1);
      }
      const command = args[0];
      const cwd = process.cwd();
      const { startTimer: profStart, endTimer: profEnd, writeBaseline, isProfilingEnabled } = require_profiler();
      const cmdTimer = profStart("command:" + (command || "unknown"));
      if (isProfilingEnabled()) {
        const profSub = args[1] && !args[1].startsWith("-") ? args[1] : "";
        process.on("exit", () => {
          profEnd(cmdTimer);
          writeBaseline(cwd, (command || "unknown") + (profSub ? "-" + profSub : ""));
        });
      }
      if (!command) {
        error("Usage: gsd-tools <command> [args] [--pretty] [--verbose]\nCommands: assertions, classify, codebase, codebase-impact, commit, config-ensure-section, config-get, config-migrate, config-set, context-budget, current-timestamp, env, extract-sections, find-phase, frontmatter, generate-slug, git, history-digest, init, intent, list-todos, mcp, mcp-profile, memory, milestone, phase, phase-plan-index, phases, progress, quick-summary, requirements, resolve-model, review, roadmap, rollback-info, scaffold, search-decisions, search-lessons, session-diff, state, state-snapshot, summary-extract, tdd, template, test-coverage, test-run, todo, token-budget, trace-requirement, validate, validate-config, validate-dependencies, velocity, verify, verify-path-exists, verify-summary, websearch, worktree");
      }
      if (args.includes("--help") || args.includes("-h")) {
        const subForHelp = args[1] && !args[1].startsWith("-") ? args[1] : "";
        const compoundKey = subForHelp ? `${command} ${subForHelp}` : "";
        const helpKey = compoundKey && COMMAND_HELP[compoundKey] ? compoundKey : command || "";
        const helpText = COMMAND_HELP[helpKey];
        if (helpText) {
          process.stderr.write(helpText + "\n");
        } else {
          process.stderr.write(`No help available for "${helpKey}". Available commands:
`);
          process.stderr.write(Object.keys(COMMAND_HELP).sort().join(", ") + "\n");
        }
        process.exit(0);
      }
      switch (command) {
        case "state": {
          const subcommand = args[1];
          if (subcommand === "update") {
            lazyState().cmdStateUpdate(cwd, args[2], args[3]);
          } else if (subcommand === "get") {
            lazyState().cmdStateGet(cwd, args[2], raw);
          } else if (subcommand === "patch") {
            const patches = {};
            for (let i = 2; i < args.length; i += 2) {
              const key = args[i].replace(/^--/, "");
              const value = args[i + 1];
              if (key && value !== void 0) {
                patches[key] = value;
              }
            }
            lazyState().cmdStatePatch(cwd, patches, raw);
          } else if (subcommand === "advance-plan") {
            lazyState().cmdStateAdvancePlan(cwd, raw);
          } else if (subcommand === "record-metric") {
            const phaseIdx = args.indexOf("--phase");
            const planIdx = args.indexOf("--plan");
            const durationIdx = args.indexOf("--duration");
            const tasksIdx = args.indexOf("--tasks");
            const filesIdx = args.indexOf("--files");
            lazyState().cmdStateRecordMetric(cwd, {
              phase: phaseIdx !== -1 ? args[phaseIdx + 1] : null,
              plan: planIdx !== -1 ? args[planIdx + 1] : null,
              duration: durationIdx !== -1 ? args[durationIdx + 1] : null,
              tasks: tasksIdx !== -1 ? args[tasksIdx + 1] : null,
              files: filesIdx !== -1 ? args[filesIdx + 1] : null
            }, raw);
          } else if (subcommand === "update-progress") {
            lazyState().cmdStateUpdateProgress(cwd, raw);
          } else if (subcommand === "add-decision") {
            const phaseIdx = args.indexOf("--phase");
            const summaryIdx = args.indexOf("--summary");
            const rationaleIdx = args.indexOf("--rationale");
            lazyState().cmdStateAddDecision(cwd, {
              phase: phaseIdx !== -1 ? args[phaseIdx + 1] : null,
              summary: summaryIdx !== -1 ? args[summaryIdx + 1] : null,
              rationale: rationaleIdx !== -1 ? args[rationaleIdx + 1] : ""
            }, raw);
          } else if (subcommand === "add-blocker") {
            const textIdx = args.indexOf("--text");
            lazyState().cmdStateAddBlocker(cwd, textIdx !== -1 ? args[textIdx + 1] : null, raw);
          } else if (subcommand === "resolve-blocker") {
            const textIdx = args.indexOf("--text");
            lazyState().cmdStateResolveBlocker(cwd, textIdx !== -1 ? args[textIdx + 1] : null, raw);
          } else if (subcommand === "record-session") {
            const stoppedIdx = args.indexOf("--stopped-at");
            const resumeIdx = args.indexOf("--resume-file");
            lazyState().cmdStateRecordSession(cwd, {
              stopped_at: stoppedIdx !== -1 ? args[stoppedIdx + 1] : null,
              resume_file: resumeIdx !== -1 ? args[resumeIdx + 1] : "None"
            }, raw);
          } else if (subcommand === "validate") {
            const fix = args.includes("--fix");
            lazyState().cmdStateValidate(cwd, { fix }, raw);
          } else {
            lazyState().cmdStateLoad(cwd, raw);
          }
          break;
        }
        case "resolve-model": {
          lazyMisc().cmdResolveModel(cwd, args[1], raw);
          break;
        }
        case "find-phase": {
          lazyMisc().cmdFindPhase(cwd, args[1], raw);
          break;
        }
        case "commit": {
          const amend = args.includes("--amend");
          const forceFlag = args.includes("--force");
          const agentIdx = args.indexOf("--agent");
          const agentType = agentIdx !== -1 ? args[agentIdx + 1] : null;
          const tddPhaseIdx = args.indexOf("--tdd-phase");
          const tddPhase = tddPhaseIdx !== -1 ? args[tddPhaseIdx + 1] : null;
          const message = args[1];
          const filesIndex = args.indexOf("--files");
          const files = filesIndex !== -1 ? args.slice(filesIndex + 1).filter((a) => !a.startsWith("--")) : [];
          lazyMisc().cmdCommit(cwd, message, files, raw, amend, forceFlag, agentType, tddPhase);
          break;
        }
        case "verify-summary": {
          const summaryPath = args[1];
          const countIndex = args.indexOf("--check-count");
          const checkCount = countIndex !== -1 ? parseInt(args[countIndex + 1], 10) : 2;
          lazyMisc().cmdVerifySummary(cwd, summaryPath, checkCount, raw);
          break;
        }
        case "template": {
          const subcommand = args[1];
          if (subcommand === "select") {
            lazyMisc().cmdTemplateSelect(cwd, args[2], raw);
          } else if (subcommand === "fill") {
            const templateType = args[2];
            const phaseIdx = args.indexOf("--phase");
            const planIdx = args.indexOf("--plan");
            const nameIdx = args.indexOf("--name");
            const typeIdx = args.indexOf("--type");
            const waveIdx = args.indexOf("--wave");
            const fieldsIdx2 = args.indexOf("--fields");
            lazyMisc().cmdTemplateFill(cwd, templateType, {
              phase: phaseIdx !== -1 ? args[phaseIdx + 1] : null,
              plan: planIdx !== -1 ? args[planIdx + 1] : null,
              name: nameIdx !== -1 ? args[nameIdx + 1] : null,
              type: typeIdx !== -1 ? args[typeIdx + 1] : "execute",
              wave: waveIdx !== -1 ? args[waveIdx + 1] : "1",
              fields: fieldsIdx2 !== -1 ? JSON.parse(args[fieldsIdx2 + 1]) : {}
            }, raw);
          } else {
            error("Unknown template subcommand. Available: select, fill");
          }
          break;
        }
        case "frontmatter": {
          const subcommand = args[1];
          const file = args[2];
          if (subcommand === "get") {
            const fieldIdx = args.indexOf("--field");
            lazyMisc().cmdFrontmatterGet(cwd, file, fieldIdx !== -1 ? args[fieldIdx + 1] : null, raw);
          } else if (subcommand === "set") {
            const fieldIdx = args.indexOf("--field");
            const valueIdx = args.indexOf("--value");
            lazyMisc().cmdFrontmatterSet(cwd, file, fieldIdx !== -1 ? args[fieldIdx + 1] : null, valueIdx !== -1 ? args[valueIdx + 1] : void 0, raw);
          } else if (subcommand === "merge") {
            const dataIdx = args.indexOf("--data");
            lazyMisc().cmdFrontmatterMerge(cwd, file, dataIdx !== -1 ? args[dataIdx + 1] : null, raw);
          } else if (subcommand === "validate") {
            const schemaIdx = args.indexOf("--schema");
            lazyMisc().cmdFrontmatterValidate(cwd, file, schemaIdx !== -1 ? args[schemaIdx + 1] : null, raw);
          } else {
            error("Unknown frontmatter subcommand. Available: get, set, merge, validate");
          }
          break;
        }
        case "verify": {
          const subcommand = args[1];
          if (subcommand === "plan-structure") {
            lazyVerify().cmdVerifyPlanStructure(cwd, args[2], raw);
          } else if (subcommand === "phase-completeness") {
            lazyVerify().cmdVerifyPhaseCompleteness(cwd, args[2], raw);
          } else if (subcommand === "references") {
            lazyVerify().cmdVerifyReferences(cwd, args[2], raw);
          } else if (subcommand === "commits") {
            lazyVerify().cmdVerifyCommits(cwd, args.slice(2), raw);
          } else if (subcommand === "artifacts") {
            lazyVerify().cmdVerifyArtifacts(cwd, args[2], raw);
          } else if (subcommand === "key-links") {
            lazyVerify().cmdVerifyKeyLinks(cwd, args[2], raw);
          } else if (subcommand === "analyze-plan") {
            lazyVerify().cmdAnalyzePlan(cwd, args[2], raw);
          } else if (subcommand === "deliverables") {
            const planIdx = args.indexOf("--plan");
            lazyVerify().cmdVerifyDeliverables(cwd, {
              plan: planIdx !== -1 ? args[planIdx + 1] : null
            }, raw);
          } else if (subcommand === "requirements") {
            lazyVerify().cmdVerifyRequirements(cwd, {}, raw);
          } else if (subcommand === "regression") {
            const beforeIdx = args.indexOf("--before");
            const afterIdx = args.indexOf("--after");
            lazyVerify().cmdVerifyRegression(cwd, {
              before: beforeIdx !== -1 ? args[beforeIdx + 1] : null,
              after: afterIdx !== -1 ? args[afterIdx + 1] : null
            }, raw);
          } else if (subcommand === "plan-wave") {
            lazyVerify().cmdVerifyPlanWave(cwd, args[2], raw);
          } else if (subcommand === "plan-deps") {
            lazyVerify().cmdVerifyPlanDeps(cwd, args[2], raw);
          } else if (subcommand === "quality") {
            const planIdx = args.indexOf("--plan");
            const phaseIdx = args.indexOf("--phase");
            lazyVerify().cmdVerifyQuality(cwd, {
              plan: planIdx !== -1 ? args[planIdx + 1] : null,
              phase: phaseIdx !== -1 ? args[phaseIdx + 1] : null
            }, raw);
          } else {
            error("Unknown verify subcommand. Available: plan-structure, phase-completeness, references, commits, artifacts, key-links, analyze-plan, deliverables, requirements, regression, plan-wave, plan-deps, quality");
          }
          break;
        }
        case "generate-slug": {
          lazyMisc().cmdGenerateSlug(args[1], raw);
          break;
        }
        case "current-timestamp": {
          lazyMisc().cmdCurrentTimestamp(args[1] || "full", raw);
          break;
        }
        case "list-todos": {
          lazyMisc().cmdListTodos(cwd, args[1], raw);
          break;
        }
        case "verify-path-exists": {
          lazyMisc().cmdVerifyPathExists(cwd, args[1], raw);
          break;
        }
        case "config-ensure-section": {
          lazyMisc().cmdConfigEnsureSection(cwd, raw);
          break;
        }
        case "config-set": {
          lazyMisc().cmdConfigSet(cwd, args[1], args[2], raw);
          break;
        }
        case "config-get": {
          lazyMisc().cmdConfigGet(cwd, args[1], raw);
          break;
        }
        case "config-migrate": {
          lazyMisc().cmdConfigMigrate(cwd, raw);
          break;
        }
        case "history-digest": {
          const hdLimitIdx = args.indexOf("--limit");
          const hdPhasesIdx = args.indexOf("--phases");
          const hdSlim = args.includes("--slim");
          const hdOptions = {
            limit: hdLimitIdx !== -1 ? parseInt(args[hdLimitIdx + 1], 10) : null,
            phases: hdPhasesIdx !== -1 ? args[hdPhasesIdx + 1].split(",").map((s) => s.trim()) : null,
            compact: hdSlim
          };
          lazyMisc().cmdHistoryDigest(cwd, hdOptions, raw);
          break;
        }
        case "phases": {
          const subcommand = args[1];
          if (subcommand === "list") {
            const typeIndex = args.indexOf("--type");
            const phaseIndex = args.indexOf("--phase");
            const options = {
              type: typeIndex !== -1 ? args[typeIndex + 1] : null,
              phase: phaseIndex !== -1 ? args[phaseIndex + 1] : null,
              includeArchived: args.includes("--include-archived")
            };
            lazyPhase().cmdPhasesList(cwd, options, raw);
          } else {
            error("Unknown phases subcommand. Available: list");
          }
          break;
        }
        case "roadmap": {
          const subcommand = args[1];
          if (subcommand === "get-phase") {
            lazyRoadmap().cmdRoadmapGetPhase(cwd, args[2], raw);
          } else if (subcommand === "analyze") {
            lazyRoadmap().cmdRoadmapAnalyze(cwd, raw);
          } else if (subcommand === "update-plan-progress") {
            lazyRoadmap().cmdRoadmapUpdatePlanProgress(cwd, args[2], raw);
          } else {
            error("Unknown roadmap subcommand. Available: get-phase, analyze, update-plan-progress");
          }
          break;
        }
        case "requirements": {
          const subcommand = args[1];
          if (subcommand === "mark-complete") {
            lazyPhase().cmdRequirementsMarkComplete(cwd, args.slice(2), raw);
          } else {
            error("Unknown requirements subcommand. Available: mark-complete");
          }
          break;
        }
        case "phase": {
          const subcommand = args[1];
          if (subcommand === "next-decimal") {
            lazyPhase().cmdPhaseNextDecimal(cwd, args[2], raw);
          } else if (subcommand === "add") {
            lazyPhase().cmdPhaseAdd(cwd, args.slice(2).join(" "), raw);
          } else if (subcommand === "insert") {
            lazyPhase().cmdPhaseInsert(cwd, args[2], args.slice(3).join(" "), raw);
          } else if (subcommand === "remove") {
            const forceFlag = args.includes("--force");
            lazyPhase().cmdPhaseRemove(cwd, args[2], { force: forceFlag }, raw);
          } else if (subcommand === "complete") {
            lazyPhase().cmdPhaseComplete(cwd, args[2], raw);
          } else {
            error("Unknown phase subcommand. Available: next-decimal, add, insert, remove, complete");
          }
          break;
        }
        case "milestone": {
          const subcommand = args[1];
          if (subcommand === "complete") {
            const nameIndex = args.indexOf("--name");
            const archivePhases = args.includes("--archive-phases");
            let milestoneName = null;
            if (nameIndex !== -1) {
              const nameArgs = [];
              for (let i = nameIndex + 1; i < args.length; i++) {
                if (args[i].startsWith("--")) break;
                nameArgs.push(args[i]);
              }
              milestoneName = nameArgs.join(" ") || null;
            }
            lazyPhase().cmdMilestoneComplete(cwd, args[2], { name: milestoneName, archivePhases }, raw);
          } else {
            error("Unknown milestone subcommand. Available: complete");
          }
          break;
        }
        case "validate": {
          const subcommand = args[1];
          if (subcommand === "consistency") {
            lazyVerify().cmdValidateConsistency(cwd, raw);
          } else if (subcommand === "health") {
            const repairFlag = args.includes("--repair");
            lazyVerify().cmdValidateHealth(cwd, { repair: repairFlag }, raw);
          } else {
            error("Unknown validate subcommand. Available: consistency, health");
          }
          break;
        }
        case "progress": {
          const subcommand = args[1] || "json";
          lazyMisc().cmdProgressRender(cwd, subcommand, raw);
          break;
        }
        case "todo": {
          const subcommand = args[1];
          if (subcommand === "complete") {
            lazyMisc().cmdTodoComplete(cwd, args[2], raw);
          } else {
            error("Unknown todo subcommand. Available: complete");
          }
          break;
        }
        case "scaffold": {
          const scaffoldType = args[1];
          const phaseIndex = args.indexOf("--phase");
          const nameIndex = args.indexOf("--name");
          const scaffoldOptions = {
            phase: phaseIndex !== -1 ? args[phaseIndex + 1] : null,
            name: nameIndex !== -1 ? args.slice(nameIndex + 1).join(" ") : null
          };
          lazyMisc().cmdScaffold(cwd, scaffoldType, scaffoldOptions, raw);
          break;
        }
        case "init": {
          const workflow = args[1];
          switch (workflow) {
            case "execute-phase":
              lazyInit().cmdInitExecutePhase(cwd, args[2], raw);
              break;
            case "plan-phase":
              lazyInit().cmdInitPlanPhase(cwd, args[2], raw);
              break;
            case "new-project":
              lazyInit().cmdInitNewProject(cwd, raw);
              break;
            case "new-milestone":
              lazyInit().cmdInitNewMilestone(cwd, raw);
              break;
            case "quick":
              lazyInit().cmdInitQuick(cwd, args.slice(2).join(" "), raw);
              break;
            case "resume":
              lazyInit().cmdInitResume(cwd, raw);
              break;
            case "verify-work":
              lazyInit().cmdInitVerifyWork(cwd, args[2], raw);
              break;
            case "phase-op":
              lazyInit().cmdInitPhaseOp(cwd, args[2], raw);
              break;
            case "todos":
              lazyInit().cmdInitTodos(cwd, args[2], raw);
              break;
            case "milestone-op":
              lazyInit().cmdInitMilestoneOp(cwd, raw);
              break;
            case "map-codebase":
              lazyInit().cmdInitMapCodebase(cwd, raw);
              break;
            case "progress":
              lazyInit().cmdInitProgress(cwd, raw);
              break;
            case "memory":
              lazyInit().cmdInitMemory(cwd, args.slice(2), raw);
              break;
            default:
              error(`Unknown init workflow: ${workflow}
Available: execute-phase, plan-phase, new-project, new-milestone, quick, resume, verify-work, phase-op, todos, milestone-op, map-codebase, progress, memory`);
          }
          break;
        }
        case "phase-plan-index": {
          lazyMisc().cmdPhasePlanIndex(cwd, args[1], raw);
          break;
        }
        case "state-snapshot": {
          lazyMisc().cmdStateSnapshot(cwd, raw);
          break;
        }
        case "summary-extract": {
          const summaryPath = args[1];
          const fieldsIndex = args.indexOf("--fields");
          const fields = fieldsIndex !== -1 ? args[fieldsIndex + 1].split(",") : null;
          lazyMisc().cmdSummaryExtract(cwd, summaryPath, fields, raw);
          break;
        }
        case "websearch": {
          const query = args[1];
          const limitIdx = args.indexOf("--limit");
          const freshnessIdx = args.indexOf("--freshness");
          await lazyMisc().cmdWebsearch(query, {
            limit: limitIdx !== -1 ? parseInt(args[limitIdx + 1], 10) : 10,
            freshness: freshnessIdx !== -1 ? args[freshnessIdx + 1] : null
          }, raw);
          break;
        }
        case "session-diff": {
          lazyFeatures().cmdSessionDiff(cwd, raw);
          break;
        }
        case "session-summary": {
          lazyFeatures().cmdSessionSummary(cwd, raw);
          break;
        }
        case "context-budget": {
          const subcommand = args[1];
          if (subcommand === "baseline") {
            lazyFeatures().cmdContextBudgetBaseline(cwd, raw);
          } else if (subcommand === "compare") {
            lazyFeatures().cmdContextBudgetCompare(cwd, args[2], raw);
          } else if (subcommand === "measure") {
            lazyFeatures().cmdContextBudgetMeasure(cwd, raw);
          } else {
            lazyFeatures().cmdContextBudget(cwd, subcommand, raw);
          }
          break;
        }
        case "test-run": {
          lazyFeatures().cmdTestRun(cwd, raw);
          break;
        }
        case "search-decisions": {
          lazyFeatures().cmdSearchDecisions(cwd, args.slice(1).join(" "), raw);
          break;
        }
        case "validate-dependencies": {
          lazyFeatures().cmdValidateDependencies(cwd, args[1], raw);
          break;
        }
        case "search-lessons": {
          lazyFeatures().cmdSearchLessons(cwd, args.slice(1).join(" "), raw);
          break;
        }
        case "codebase": {
          const sub = args[1];
          if (sub === "analyze") {
            lazyCodebase().cmdCodebaseAnalyze(cwd, args.slice(2), raw);
          } else if (sub === "status") {
            lazyCodebase().cmdCodebaseStatus(cwd, args.slice(2), raw);
          } else if (sub === "conventions") {
            lazyCodebase().cmdCodebaseConventions(cwd, args.slice(2), raw);
          } else if (sub === "rules") {
            lazyCodebase().cmdCodebaseRules(cwd, args.slice(2), raw);
          } else if (sub === "deps") {
            lazyCodebase().cmdCodebaseDeps(cwd, args.slice(2), raw);
          } else if (sub === "impact") {
            lazyCodebase().cmdCodebaseImpact(cwd, args.slice(2), raw);
          } else if (sub === "context") {
            lazyCodebase().cmdCodebaseContext(cwd, args.slice(2), raw);
          } else if (sub === "lifecycle") {
            lazyCodebase().cmdCodebaseLifecycle(cwd, args.slice(2), raw);
          } else if (sub === "ast") {
            lazyCodebase().cmdCodebaseAst(cwd, args.slice(2), raw);
          } else if (sub === "exports") {
            lazyCodebase().cmdCodebaseExports(cwd, args.slice(2), raw);
          } else if (sub === "complexity") {
            lazyCodebase().cmdCodebaseComplexity(cwd, args.slice(2), raw);
          } else if (sub === "repo-map") {
            lazyCodebase().cmdCodebaseRepoMap(cwd, args.slice(2), raw);
          } else {
            error("Usage: codebase <analyze|status|conventions|rules|deps|impact|context|lifecycle|ast|exports|complexity|repo-map>");
          }
          break;
        }
        case "codebase-impact": {
          lazyFeatures().cmdCodebaseImpact(cwd, args.slice(1), raw);
          break;
        }
        case "rollback-info": {
          lazyFeatures().cmdRollbackInfo(cwd, args[1], raw);
          break;
        }
        case "velocity": {
          lazyFeatures().cmdVelocity(cwd, raw);
          break;
        }
        case "trace-requirement": {
          lazyFeatures().cmdTraceRequirement(cwd, args[1], raw);
          break;
        }
        case "validate-config": {
          lazyFeatures().cmdValidateConfig(cwd, raw);
          break;
        }
        case "quick-summary": {
          lazyFeatures().cmdQuickTaskSummary(cwd, raw);
          break;
        }
        case "extract-sections": {
          lazyFeatures().cmdExtractSections(cwd, args.slice(1), raw);
          break;
        }
        case "test-coverage": {
          lazyFeatures().cmdTestCoverage(cwd, raw);
          break;
        }
        case "token-budget": {
          lazyFeatures().cmdTokenBudget(cwd, raw);
          break;
        }
        case "memory": {
          const subcommand = args[1];
          if (subcommand === "write") {
            const storeIdx = args.indexOf("--store");
            const entryIdx = args.indexOf("--entry");
            lazyMemory().cmdMemoryWrite(cwd, {
              store: storeIdx !== -1 ? args[storeIdx + 1] : null,
              entry: entryIdx !== -1 ? args[entryIdx + 1] : null
            }, raw);
          } else if (subcommand === "read") {
            const storeIdx = args.indexOf("--store");
            const limitIdx = args.indexOf("--limit");
            const queryIdx = args.indexOf("--query");
            const phaseIdx = args.indexOf("--phase");
            lazyMemory().cmdMemoryRead(cwd, {
              store: storeIdx !== -1 ? args[storeIdx + 1] : null,
              limit: limitIdx !== -1 ? args[limitIdx + 1] : null,
              query: queryIdx !== -1 ? args[queryIdx + 1] : null,
              phase: phaseIdx !== -1 ? args[phaseIdx + 1] : null
            }, raw);
          } else if (subcommand === "list") {
            lazyMemory().cmdMemoryList(cwd, {}, raw);
          } else if (subcommand === "ensure-dir") {
            lazyMemory().cmdMemoryEnsureDir(cwd);
          } else if (subcommand === "compact") {
            const storeIdx = args.indexOf("--store");
            const thresholdIdx = args.indexOf("--threshold");
            const dryRun = args.includes("--dry-run");
            lazyMemory().cmdMemoryCompact(cwd, {
              store: storeIdx !== -1 ? args[storeIdx + 1] : null,
              threshold: thresholdIdx !== -1 ? args[thresholdIdx + 1] : null,
              dryRun
            }, raw);
          } else {
            error("Unknown memory subcommand. Available: write, read, list, ensure-dir, compact");
          }
          break;
        }
        case "intent": {
          const subcommand = args[1];
          if (subcommand === "create") {
            lazyIntent().cmdIntentCreate(cwd, args.slice(2), raw);
          } else if (subcommand === "show") {
            lazyIntent().cmdIntentShow(cwd, args.slice(2), raw);
          } else if (subcommand === "read") {
            lazyIntent().cmdIntentShow(cwd, args.slice(2), true);
          } else if (subcommand === "update") {
            lazyIntent().cmdIntentUpdate(cwd, args.slice(2), raw);
          } else if (subcommand === "validate") {
            lazyIntent().cmdIntentValidate(cwd, args.slice(2), raw);
          } else if (subcommand === "trace") {
            lazyIntent().cmdIntentTrace(cwd, args.slice(2), raw);
          } else if (subcommand === "drift") {
            lazyIntent().cmdIntentDrift(cwd, args.slice(2), raw);
          } else {
            error("Unknown intent subcommand. Available: create, show, read, update, validate, trace, drift");
          }
          break;
        }
        case "env": {
          const subcommand = args[1];
          if (subcommand === "scan") {
            lazyEnv().cmdEnvScan(cwd, args.slice(2), raw);
          } else if (subcommand === "status") {
            lazyEnv().cmdEnvStatus(cwd, args.slice(2), raw);
          } else {
            error("Unknown env subcommand. Available: scan, status");
          }
          break;
        }
        case "mcp-profile": {
          lazyMcp().cmdMcpProfile(cwd, args.slice(1), raw);
          break;
        }
        case "mcp": {
          const subcommand = args[1];
          if (subcommand === "profile") {
            lazyMcp().cmdMcpProfile(cwd, args.slice(2), raw);
          } else {
            error("Unknown mcp subcommand. Available: profile");
          }
          break;
        }
        case "assertions": {
          const subcommand = args[1];
          if (subcommand === "list") {
            const reqIdx = args.indexOf("--req");
            lazyVerify().cmdAssertionsList(cwd, {
              reqId: reqIdx !== -1 ? args[reqIdx + 1] : null
            }, raw);
          } else if (subcommand === "validate") {
            lazyVerify().cmdAssertionsValidate(cwd, raw);
          } else {
            error("Unknown assertions subcommand. Available: list, validate");
          }
          break;
        }
        case "worktree": {
          const subcommand = args[1];
          if (subcommand === "create") {
            lazyWorktree().cmdWorktreeCreate(cwd, args[2], raw);
          } else if (subcommand === "list") {
            lazyWorktree().cmdWorktreeList(cwd, raw);
          } else if (subcommand === "remove") {
            lazyWorktree().cmdWorktreeRemove(cwd, args[2], raw);
          } else if (subcommand === "cleanup") {
            lazyWorktree().cmdWorktreeCleanup(cwd, raw);
          } else if (subcommand === "merge") {
            lazyWorktree().cmdWorktreeMerge(cwd, args[2], raw);
          } else if (subcommand === "check-overlap") {
            lazyWorktree().cmdWorktreeCheckOverlap(cwd, args[2], raw);
          } else {
            error("Unknown worktree subcommand. Available: create, list, remove, cleanup, merge, check-overlap");
          }
          break;
        }
        case "git": {
          const gitSub = args[1];
          const gitMod = lazyGit();
          const { output: gitOutput } = require_output();
          switch (gitSub) {
            case "log": {
              const countIdx = args.indexOf("--count");
              const sinceIdx = args.indexOf("--since");
              const untilIdx = args.indexOf("--until");
              const authorIdx = args.indexOf("--author");
              const pathIdx = args.indexOf("--path");
              const gitOpts = {
                count: countIdx !== -1 ? parseInt(args[countIdx + 1], 10) : 20,
                since: sinceIdx !== -1 ? args[sinceIdx + 1] : void 0,
                until: untilIdx !== -1 ? args[untilIdx + 1] : void 0,
                author: authorIdx !== -1 ? args[authorIdx + 1] : void 0,
                path: pathIdx !== -1 ? args[pathIdx + 1] : void 0
              };
              gitOutput(gitMod.structuredLog(cwd, gitOpts), raw);
              break;
            }
            case "diff-summary": {
              const fromIdx = args.indexOf("--from");
              const toIdx = args.indexOf("--to");
              const dsPathIdx = args.indexOf("--path");
              gitOutput(gitMod.diffSummary(cwd, {
                from: fromIdx !== -1 ? args[fromIdx + 1] : void 0,
                to: toIdx !== -1 ? args[toIdx + 1] : void 0,
                path: dsPathIdx !== -1 ? args[dsPathIdx + 1] : void 0
              }), raw);
              break;
            }
            case "blame": {
              gitOutput(gitMod.blame(cwd, args[2]), raw);
              break;
            }
            case "branch-info": {
              gitOutput(gitMod.branchInfo(cwd), raw);
              break;
            }
            default:
              error("Unknown git subcommand: " + gitSub + ". Available: log, diff-summary, blame, branch-info");
          }
          break;
        }
        case "review": {
          lazyMisc().cmdReview(cwd, args.slice(1), raw);
          break;
        }
        case "tdd": {
          const tddSub = args[1];
          const tddTestCmdIdx = args.indexOf("--test-cmd");
          const tddTestFileIdx = args.indexOf("--test-file");
          const tddPhaseIdx = args.indexOf("--phase");
          const tddFilesIdx = args.indexOf("--files");
          const tddArgs = {
            "test-cmd": tddTestCmdIdx !== -1 ? args[tddTestCmdIdx + 1] : null,
            "test-file": tddTestFileIdx !== -1 ? args[tddTestFileIdx + 1] : null,
            phase: tddPhaseIdx !== -1 ? args[tddPhaseIdx + 1] : null,
            files: tddFilesIdx !== -1 ? args[tddFilesIdx + 1] : null
          };
          lazyMisc().cmdTdd(cwd, tddSub, tddArgs, raw);
          break;
        }
        case "classify": {
          const sub = args[1];
          if (sub === "plan") {
            lazyOrchestration().cmdClassifyPlan(cwd, args.slice(2), raw);
          } else if (sub === "phase") {
            lazyOrchestration().cmdClassifyPhase(cwd, args.slice(2), raw);
          } else {
            error("Usage: classify <plan|phase> <path-or-number>");
          }
          break;
        }
        default:
          error(`Unknown command: ${command}`);
      }
    }
    module2.exports = { main: main2 };
  }
});

// src/index.js
var { main } = require_router();
main();
